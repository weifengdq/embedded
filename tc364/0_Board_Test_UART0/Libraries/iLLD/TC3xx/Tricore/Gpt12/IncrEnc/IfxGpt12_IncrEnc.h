/**
 * \file IfxGpt12_IncrEnc.h
 * \brief GPT12 INCRENC details
 * \ingroup IfxLld_Gpt12
 *
 * \version iLLD_1_20_0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Gpt12_IncrEnc INCRENC
 * \ingroup IfxLld_Gpt12
 *
 * \defgroup IfxLld_Gpt12_IncrEnc_Usage How to use the GPT12 Incremental Encoder Driver
 * \ingroup IfxLld_Gpt12_IncrEnc
 *
 * The IncrEnc interface can be used in one of the following configurations T3 as core or T2 as core or T4 as core(if no Z signal is present for T2 and T3)
 *
 *  Setup with T3 as core
 *   - T3 as incremental mode
 *      - Multiplication factor:
 *          - twoFold: use both edges of TxIn
 *          - fourFold: use both edges of TxIn and TxEUD
 *          - Reverse of direction supported by GPT12
 *          - T3 value diff is used for speed calculation at high speed (speed > speedModeThreshold)
 *   - T4 used for zero signal detection if  pinZ is not NULL
 *      - interrupt is generated to support turn calculation if zeroIsrPriority != 0
 *      - T4 clears T3 on zero signal event on TxIn input
 *   - T5 used for low speed calculation (speed < speedModeThreshold)
 *          - Rising edge of TxIn or TxEUD captures the T5 timer in CAPREL
 *
 *  Setup with T2 as core
 *   - T2 as incremental mode
 *      - Multiplication factor:
 *          - twoFold: sample on both edges of TxIn
 *          - fourFold: sample on both edges of TxIn and TxEUD
 *          - Reverse of direction supported by GPT12
 *          - T2 value diff is used for speed calculation at high speed
 *   - T4 used for zero signal detection if  pinZeroTxEUD is not NULL
 *   - T4 clears T2 on zero signal event on TxEUD input
 *
 *  Setup with T4 as core
 *  - T4 as incremental mode
 *      - Multiplication factor:
 *         - twoFold: sample on the both edges of TxIn
 *         - fourFold: sample on both edges of Txin and TxEUD
 *         - Reverse of direction supported by GPT12
 *         - T4 value diff is used for speed calculation at high speed
 *
 * \section IfxLld_Gpt12_IncrEnc_Preparation Preparation
 * \subsection IfxLld_Gpt12_IncrEnc_Include Include Files
 *
 * Include following header file into your C code:
 *   \code
 *       #include <Gpt12/Gpt/IfxGpt12_IncrEnc.h>
 *   \endcode
 *
 * \subsection IfxLld_Gpt12_IncrEnc_Variables Variables
 *
 *   \code
 *   // used globally
 *   static IfxGpt12_IncrEnc gpt12;
 *   \endcode
 *
 * \subsection IfxLld_Gpt12_Gpt_Interrupt Interrupt Handler Installation
 *
 * See also \ref IfxLld_Cpu_Irq_Usage
 *
 * Define priorities for the Interrrupt handlers. This is normally done in the Ifx_IntPrioDef.h file:
 *   \code
 *       // priorities are normally defined in Ifx_IntPrioDef.h
 *       #define ISR_PRIORITY_INCRENC_ZERO 6
 *   \endcode
 *
 * Add the interrupt service routines to your C code. They have to call the GPT12 interrupt handlers by passing the gpt12 handle:
 *   \code
 *       IFX_INTERRUPT(ISR_IncrIncZero, 0, ISR_PRIORITY_INCRENC_ZERO)
 *       {
 *           IfxGpt12_IncrEnc_onZeroIrq(&gpt12);
 *       }
 *   \endcode
 *
 * Finally install the interrupt handlers in your initialisation function:
 *   \code
 *       // install interrupt handlers
 *       IfxCpu_Irq_installInterruptHandler(&ISR_IncrIncZero, ISR_PRIORITY_INCRENC_ZERO);
 *       IfxCpu_enableInterrupts();
 *   \endcode
 *
 * \subsection IfxLld_Gpt12_Gpt_Init Module Initialisation
 *
 *   The module initialisation can be done in the same function. Here an example:
 *   \code
 *       // Initialize global clocks
 *       IfxGpt12_enableModule(&MODULE_GPT120);
 *       IfxGpt12_setGpt1BlockPrescaler(&MODULE_GPT120, IfxGpt12_Gpt1BlockPrescaler_8);
 *       IfxGpt12_setGpt2BlockPrescaler(&MODULE_GPT120, IfxGpt12_Gpt2BlockPrescaler_4);
 *
 *       // create module config
 *       IfxGpt12_IncrEnc_Config gpt12Config;
 *       IfxGpt12_IncrEnc_initConfig(&gpt12Config , &MODULE_GPT120);
 *
 *       // implementation with T3 as core
 *       gpt12Config.offset                    = 0;
 *       gpt12Config.reversed                  = FALSE;
 *       gpt12Config.resolution                = 2048;
 *       gpt12Config.periodPerRotation         = 1;
 *       gpt12Config.resolutionFactor          = IfxStdIf_Pos_ResolutionFactor_fourFold;
 *       gpt12Config.updatePeriod              = 100e-6;
 *       gpt12Config.speedModeThreshold        = 200;
 *       gpt12Config.minSpeed                  = 10;
 *       gpt12Config.maxSpeed                  = 500;
 *       gpt12Config.zeroIsrPriority                = ISR_PRIORITY(INTERRUPT_INCRINC_ZERO);
 *       gpt12Config.zeroIsrProvider                = ISR_PROVIDER(INTERRUPT_INCRINC_ZERO);
 *       gpt12Config.pinA                           = &IfxGpt120_T3INA_P02_6_IN;
 *       gpt12Config.pinB                           = &IfxGpt120_T3EUDA_P02_7_IN;
 *       gpt12Config.pinZ                           = &IfxGpt120_T4INA_P02_8_IN;
 *       gpt12Config.pinMode                        = IfxPort_InputMode_noPullDevice;
 *
 *
 *       // initialize module
 *       //IfxGpt12_IncrEnc gpt12; // defined globally
 *       IfxGpt12_IncrEnc_init(&gpt12, &gpt12Config);
 *   \endcode
 *
 * \section IfxLld_Gpt12_IncrEnc_Update Update
 *
 * speed, position and direction of the incremental encoder can be collected by the following
 *
 *   \code
 *       float32 speed, rawPosition;
 *       IfxStdIf_Pos_Dir direction;
 *
 *       Ifx_TickTime tickRefresh     = gpt12.updatePeriod * TimeConst_1s;
 *
 *       Ifx_TickTime refreshDeadLine = now();
 *
 *       if (isDeadLine(refreshDeadLine))
 *       {
 *           refreshDeadLine = addTTime(refreshDeadLine, tickRefresh);
 *           IfxGpt12_IncrEnc_update(&gpt12);
 *
 *           speed       = IfxGpt12_IncrEnc_getSpeed(&gpt12);
 *           rawPosition = IfxGpt12_IncrEnc_getRawPosition(&gpt12);
 *           direction   = IfxGpt12_IncrEnc_getDirection(&gpt12);
 *       }
 *   \endcode
 *
 * \defgroup IfxLld_Gpt12_IncrEnc INCRENC
 * \ingroup IfxLld_Gpt12
 * \defgroup IfxLld_Gpt12_IncrEnc_Datastructures Data structures
 * \ingroup IfxLld_Gpt12_IncrEnc
 * \defgroup IfxLld_Gpt12_IncrEnc_Functions Functions
 * \ingroup IfxLld_Gpt12_IncrEnc
 * \defgroup IfxLld_Gpt12_IncrEnc_StdIf_Functions StdIf Functions
 * \ingroup IfxLld_Gpt12_IncrEnc
 * \defgroup IfxLld_Gpt12_IncrEnc_Enumerations Enumerations
 * \ingroup IfxLld_Gpt12_IncrEnc
 */

#ifndef IFXGPT12_INCRENC_H
#define IFXGPT12_INCRENC_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Gpt12/Std/IfxGpt12.h"

/******************************************************************************/
/*------------------------------Type Definitions------------------------------*/
/******************************************************************************/

typedef void (*IfxGpt12_IncrEnc_Update)(void *driver);

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Gpt12_IncrEnc_Enumerations
 * \{ */
/** \brief Enumeration for direction of rotation of encoder
 */
typedef enum
{
    IfxGpt12_IncrEnc_Direction_forward  = 0,  /**< \brief Forward direction. For rotating position sensor, forward is clockwise rotation */
    IfxGpt12_IncrEnc_Direction_backward = 1,  /**< \brief Backward direction. For rotating position sensor, backward is counter-clockwise rotation */
    IfxGpt12_IncrEnc_Direction_unknown  = 2   /**< \brief Unknown direction */
} IfxGpt12_IncrEnc_Direction;

/** \brief Enumeration for resolution of encoder
 */
typedef enum
{
    IfxGpt12_IncrEnc_ResolutionFactor_oneFold  = 1, /**< \brief Default, no multipluication factor */
    IfxGpt12_IncrEnc_ResolutionFactor_twoFold  = 2, /**< \brief 2-fold resolution. Valid for encoder */
    IfxGpt12_IncrEnc_ResolutionFactor_fourFold = 4  /**< \brief 4-fold resolution. Valid for encoder */
} IfxGpt12_IncrEnc_ResolutionFactor;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Gpt12_IncrEnc_Datastructures
 * \{ */
/** \brief Incremental encoder object
 */
typedef struct
{
    sint32                     rawPosition;                  /**< \brief raw position in ticks. \note: the value already contains the offset */
    float32                    speed;                        /**< \brief mechanical speed in rad/s */
    sint32                     turn;                         /**< \brief number of mechanical turns */
    sint32                     offset;                       /**< \brief raw position offset */
    sint32                     resolution;                   /**< \brief resolution of this position sensor interface */
    float32                    updatePeriod;                 /**< \brief update period in seconds */
    float32                    speedConstPulseCount;         /**< \brief constant for calculating mechanical speed (in rad/s) from raw speed in pulse count mode */
    float32                    speedConstTimeDiff;           /**< \brief constant for calculating mechanical speed (in rad/s) from raw speed in time diff mode */
    float32                    positionConst;                /**< \brief constant for calculating mechanical position (in rad) from raw position */
    float32                    speedModeThreshold;           /**< \brief treshold used for speed calculation using pulse count mode or time diff mode in rad/s */
    sint32                     speedModeThresholdTick;       /**< \brief treshold used for speed calculation using pulse count mode or time diff mode in ticks */
    float32                    minSpeed;                     /**< \brief Absolute minimal allowed speed. below speed is recognized as 0rad/s */
    float32                    maxSpeed;                     /**< \brief Absolute maximal allowed speed. Above speed is recognized as error */
    Ifx_GPT12                 *module;                       /**< \brief Pointer to the GPT12 module */
    IfxGpt12_IncrEnc_Update    update;                       /**< \brief Update call back API */
    IfxGpt12_IncrEnc_Direction direction;                    /**< \brief rotation direction */
    boolean                    notSynchronised;              /**< \brief Sensor is not synchronized */
} IfxGpt12_IncrEnc;

/** \brief Configuration structure for GPT12
 */
typedef struct
{
    sint32                            offset;                   /**< \brief Position sensor offset */
    sint32                            resolution;               /**< \brief Sensor resolution. For encoder with 1024 pulse per revolution, the value should be 1024 */
    float32                           updatePeriod;             /**< \brief period in seconds, at which the application calls IfxStdIf_Pos_update() */
    float32                           speedModeThreshold;       /**< \brief Speed threshold used for the speed calculation mode. For encoder, above the threshold the pulse count mode is used, below the threshold, the time delta is used.Applicable only if T3 is used */
    float32                           minSpeed;                 /**< \brief Absolute minimal allowed speed. below speed is recognized as 0rad/s */
    float32                           maxSpeed;                 /**< \brief Absolute maximal allowed speed. Above speed is recognized as error */
    Ifx_GPT12                        *module;                   /**< \brief Pointer to module base address */
    IfxGpt12_TxIn_In                 *pinA;                     /**< \brief Encoder A signal. Should be connecting to T2 or T3  or T4(If no Z signal) TxIN. See \ref IfxLld_Gpt12__Pinmap "GPT12 pin map data" */
    IfxGpt12_TxEud_In                *pinB;                     /**< \brief Encoder B signal. Should be connecting to T2 or T3 or T4(If no Z signal) TxEUD. See \ref IfxLld_Gpt12__Pinmap "GPT12 pin map data" */
    IfxGpt12_TxIn_In                 *pinZ;                     /**< \brief Encoder Z signal. Should be connecting to T4 TxIn for use with T3 and TxEUD (Ignore compiler type conflict warning) for use with T2.  See \ref IfxLld_Gpt12__Pinmap "GPT12 pin map data" */
    IfxPort_InputMode                 pinMode;                  /**< \brief Pin mode for A, B and Z inputs */
    Ifx_Priority                      zeroIsrPriority;          /**< \brief Interrupt isrPriority of the zero interrupt, if 0 the interrupt is disable */
    IfxSrc_Tos                        zeroIsrProvider;          /**< \brief Interrupt service provider for the zero interrupt */
    IfxPort_PadDriver                 pinDriver;                /**< \brief Pad Driver */
    IfxGpt12_IncrEnc_ResolutionFactor resolutionFactor;         /**< \brief Resolution multiplier for encoder interface, valid is 2, 4. */
    boolean                           reversed;                 /**< \brief If true, the sensor direction is reversed */
    boolean                           initPins;                 /**< \brief TRUE: Initialize pins in driver
                                                                 * FALSE: Don't initialize pins. User handles separately. */
} IfxGpt12_IncrEnc_Config;

/** \} */

/** \addtogroup IfxLld_Gpt12_IncrEnc_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Initializes the incremental encoder interface with the provided configuration.
 *
 * \param[inout] driver Pointer to the incremental encoder driver handle.
 * \param[in]    config Pointer to the configuration structure to be initialized.
 *
 * \retval TRUE If the initialization was successful.
 *         FALSE If the initialization failed.
 *
 * \code
 *     // create module config
 *     IfxGpt12_IncrEnc_Config gptConfig;
 *     IfxGpt12_IncrEnc_initConfig(&gptConfig , &MODULE_GPT120);
 *
 *     // initialize module
 *     //IfxGpt12_IncrEnc gpt12; // defined globally
 *
 *     IfxGpt12_IncrEnc_init(&gpt12, &gptConfig);
 * \endcode
 *
 */
IFX_EXTERN boolean IfxGpt12_IncrEnc_init(IfxGpt12_IncrEnc *driver, const IfxGpt12_IncrEnc_Config *config);

/**
 * \brief Initializes the configuration structure to default values for the incremental encoder.
 * 
 * \param[inout] config Pointer to the configuration structure to be initialized.
 * \param[in]    gpt12  Pointer to the GPT12 module base address.
 *
 * \retval None
 *
 * see \ref IfxGpt12_IncrEnc_init
 *
 */
IFX_EXTERN void IfxGpt12_IncrEnc_initConfig(IfxGpt12_IncrEnc_Config *config, Ifx_GPT12 *gpt12);

/** \} */

/** \addtogroup IfxLld_Gpt12_IncrEnc_StdIf_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Retrieves the absolute position of the incremental encoder sensor in radians,
 * including the total number of complete mechanical turns.
 *
 * \param[in] driver Pointer to the incremental encoder driver handle.
 *
 * \retval float32 Absolute position of the sensor.
 *
 */
IFX_EXTERN float32 IfxGpt12_IncrEnc_getAbsolutePosition(IfxGpt12_IncrEnc *driver);

/**
 * \brief Retrieves the current rotation direction of the incremental encoder.
 *
 * \param[in] driver Pointer to the incremental encoder driver handle.
 *
 * \retval IfxGpt12_IncrEnc_Direction The current rotation direction, which can be either forward or reverse.
 *                                    Range: \ref IfxGpt12_IncrEnc_Direction.
 *
 */
IFX_EXTERN IfxGpt12_IncrEnc_Direction IfxGpt12_IncrEnc_getDirection(IfxGpt12_IncrEnc *driver);

/**
 * \brief Retrieves the raw position sensor offset value from the incremental encoder driver.
 *
 * \param[in] driver Pointer to the incremental encoder driver handle.
 *
 * \retval sint32 The raw position sensor offset value stored in the driver object.
 *
 */
IFX_EXTERN sint32 IfxGpt12_IncrEnc_getOffset(IfxGpt12_IncrEnc *driver);

/**
 * \brief Returns the current position of the incremental encoder sensor in radians.
 * For rotating sensor, the position is always between 0 and 2*IFX_PI.
 *
 * \param[in] driver Pointer to the incremental encoder driver handle.
 *
 * \retval float32 The current position of the sensor.
 * 
 */
IFX_EXTERN float32 IfxGpt12_IncrEnc_getPosition(IfxGpt12_IncrEnc *driver);

/**
 * \brief Returns the sensor's raw position in ticks.
 *
 * \param[in] driver Pointer to the incremental encoder driver handle.
 *
 * \retval sint32 The raw position value in ticks, incorporating any offset.
 *
 */
IFX_EXTERN sint32 IfxGpt12_IncrEnc_getRawPosition(IfxGpt12_IncrEnc *driver);

/**
 * \brief Get the refresh period of the incremental encoder.
 *
 * \param[in] driver Pointer to the incremental encoder driver handle.
 *
 * \retval float32 The update period in seconds.
 * 
 */
IFX_EXTERN float32 IfxGpt12_IncrEnc_getRefreshPeriod(IfxGpt12_IncrEnc *driver);

/**
 * \brief Get the resolution of the incremental encoder
 *
 * \param[in] driver Pointer to the incremental encoder driver handle.
 *
 * \retval sint32 The resolution of the incremental encoder as a signed 32-bit integer.
 *
 */
IFX_EXTERN sint32 IfxGpt12_IncrEnc_getResolution(IfxGpt12_IncrEnc *driver);

/**
 * \brief Returns the mechanical speed of the incremental encoder in radians per second.
 *
 * \param[in] driver Pointer to the incremental encoder driver handle.
 *
 * \retval float32 The mechanical speed in radians per second (rad/s).
 *
 */
IFX_EXTERN float32 IfxGpt12_IncrEnc_getSpeed(IfxGpt12_IncrEnc *driver);

/**
 * \brief Retrieves the number of mechanical turns counted by the incremental encoder.
 *
 * \param[in] driver Pointer to the incremental encoder driver handle.
 *
 * \retval sint32 The number of complete mechanical turns as a signed 32-bit integer.
 *
 */
IFX_EXTERN sint32 IfxGpt12_IncrEnc_getTurn(IfxGpt12_IncrEnc *driver);

/**
 * \brief Handles the zero interrupt for the incremental encoder.
 *
 * \param[inout] driver Pointer to the incremental encoder driver handle.
 *
 * \retval None
 * 
 */
IFX_EXTERN void IfxGpt12_IncrEnc_onZeroIrq(IfxGpt12_IncrEnc *driver);

/**
* \brief Resets the incremental encoder driver to its initial state.
*
* \param[inout] driver Pointer to the incremental encoder driver handle.
*
* \retval None
*
*/
IFX_EXTERN void IfxGpt12_IncrEnc_reset(IfxGpt12_IncrEnc *driver);

/**
 * \brief Sets the raw position offset for the incremental encoder.
 *
 * \param[inout] driver Pointer to the incremental encoder driver handle.
 * \param[in]    offset The new offset value to be applied to the raw position.
 *
 * \retval None
 *
 */
IFX_EXTERN void IfxGpt12_IncrEnc_setOffset(IfxGpt12_IncrEnc *driver, sint32 offset);

/**
 * \brief Configures the update period for the incremental encoder driver.
 *
 * \param[inout] driver        Pointer to the incremental encoder driver handle.
 * \param[in]    updatePeriod  The new update period in seconds to be set.
 *
 * \retval None
 * 
 */
IFX_EXTERN void IfxGpt12_IncrEnc_setRefreshPeriod(IfxGpt12_IncrEnc *driver, float32 updatePeriod);

/**
 * \brief Updates the incremental encoder's state like speed, position, status, taking into account the updatePeriod.
 *
 * \param[in] driver Pointer to the incremental encoder driver handle.
 *
 * \retval None
 *
 */
IFX_EXTERN void IfxGpt12_IncrEnc_update(IfxGpt12_IncrEnc *driver);

/** \} */

#endif /* IFXGPT12_INCRENC_H */
