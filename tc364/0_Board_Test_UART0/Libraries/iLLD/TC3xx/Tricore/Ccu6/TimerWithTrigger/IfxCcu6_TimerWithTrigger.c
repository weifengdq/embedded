/**
 * \file IfxCcu6_TimerWithTrigger.c
 * \brief CCU6 TIMERWITHTRIGGER details
 *
 * \version iLLD_1_20_0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxCcu6_TimerWithTrigger.h"
#include "_Utilities/Ifx_Assert.h"
#include "stddef.h"
#include "string.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

boolean IfxCcu6_TimerWithTrigger_acknowledgeTimerIrq(IfxCcu6_TimerWithTrigger *driver)
{
    boolean event;
    event = driver->ccu6->IS.B.T12OM != 0;

    if (event)
    {
        driver->ccu6->ISR.B.RT12OM = 1;
    }
    else
    {}

    return event;
}


boolean IfxCcu6_TimerWithTrigger_acknowledgeTriggerIrq(IfxCcu6_TimerWithTrigger *driver)
{
    boolean event;
    event = driver->ccu6->IS.B.T13CM != 0;

    if (event)
    {
        driver->ccu6->ISR.B.RT13CM = 1;
    }
    else
    {}

    return event;
}


void IfxCcu6_TimerWithTrigger_applyUpdate(IfxCcu6_TimerWithTrigger *driver)
{
    /* enable shadow transfer */
    IfxCcu6_enableShadowTransfer(driver->ccu6, TRUE, TRUE);
}


void IfxCcu6_TimerWithTrigger_disableUpdate(IfxCcu6_TimerWithTrigger *driver)
{
    /* Nothing to do */
    IFX_UNUSED_PARAMETER(driver)
}


float32 IfxCcu6_TimerWithTrigger_getFrequency(IfxCcu6_TimerWithTrigger *driver)
{
    /*  returns ticks / clockFreq */
    return 1.0f / ( driver->base.period/driver->base.clockFreq );
}


float32 IfxCcu6_TimerWithTrigger_getInputFrequency(IfxCcu6_TimerWithTrigger *driver)
{
    return driver->base.clockFreq;
}


Ifx_TimerValue IfxCcu6_TimerWithTrigger_getPeriod(IfxCcu6_TimerWithTrigger *driver)
{
    return driver->base.period;
}


volatile uint32 *IfxCcu6_TimerWithTrigger_getPointer(IfxCcu6_TimerWithTrigger *driver)
{
    return (volatile uint32 *)&driver->ccu6->T12PR ;
}


float32 IfxCcu6_TimerWithTrigger_getResolution(IfxCcu6_TimerWithTrigger *driver)
{
    return 1.0f / driver->base.clockFreq;
}


boolean IfxCcu6_TimerWithTrigger_init(IfxCcu6_TimerWithTrigger *driver, IfxCcu6_TimerWithTrigger_Config *config)
{
    boolean                        result = TRUE;
    IfxCcu6_TimerWithTrigger_Base *base   = &driver->base;
    Ifx_CCU6                      *module;

    driver->ccu6         = config->ccu6;
    module               = driver->ccu6;

    base->triggerEnabled = config->base.trigger.enabled;

    /** - Enable/initialise the CCU6 if it has not been enabled. See IfxCcu6_isModuleEnabled() */
    if (IfxCcu6_isModuleEnabled(module) == FALSE)
    {
	/* Enable the module */
        IfxCcu6_enableModule(module);
    }

    /* Initialize the timer part */
    result = IfxCcu6_TimerWithTrigger_initTimer(driver, config);

    /* Initialize the trigger part */
    if (base->triggerEnabled)
    {
        result = IfxCcu6_TimerWithTrigger_initTrigger(driver, config);
    }
    else
    {}

    /* Interrupt configuration */
    {
        boolean timerHasIrq   = config->base.isrPriority > 0;
        boolean triggerHasIrq = (config->base.trigger.isrPriority > 0) && base->triggerEnabled;

        if (timerHasIrq || triggerHasIrq)
        {
	    /* -- interrupt initialisation -- */
            IfxCcu6_TimerWithTrigger_initInterrupt(driver, config);
        }
    }

    /* Transfer the shadow registers */
    IfxCcu6_TimerWithTrigger_applyUpdate(driver);
    return result;
}


boolean IfxCcu6_TimerWithTrigger_initTimer(IfxCcu6_TimerWithTrigger *driver, IfxCcu6_TimerWithTrigger_Config *config)
{
    boolean                        result = TRUE;
    Ifx_CCU6                       *module = config->ccu6;
    IfxCcu6_TimerWithTrigger_Base *base   = &driver->base;

    module->TCTR0.B.CTM = (config->base.countDir == IfxCcu6_Timer_CountDir_upAndDown) ? IfxCcu6_T12CountMode_centerAligned : IfxCcu6_T12CountMode_edgeAligned;

    driver->base.countDir = config->base.countDir;

    uint16  prescaler;
    float32 freqT12 = 0, periodT12;
    float32 freqCC6 = (float32)IfxScuCcu_getSpbFrequency();

    for (prescaler = 0; prescaler < 16; prescaler++)
    {
        freqT12   = freqCC6 / (1U << prescaler);
        periodT12 = freqT12 / config->base.frequency;

        if ((periodT12 <= 65535.0f) && (periodT12 > config->base.minResolution))
        {
            break;
        }
    }

    if (prescaler < 16)
    {
        Ifx_CCU6_TCTR0 tctr0;
        tctr0.U         = module->TCTR0.U;
        tctr0.B.T12CLK  = (prescaler & 0x7U);
        tctr0.B.T12PRE  = ((prescaler & 0x8U) != 0);
        module->TCTR0.U = tctr0.U;
    }
    else
    {
        /** \retval IfxCcu6_Stat_wrongPwmFreq if the T12 prescaler can't fulfill the
         * required frequency */
        result = FALSE;
    }

    /* Update the input frequency */
    IfxCcu6_TimerWithTrigger_updateInputFrequency(driver);

    if ((config->base.minResolution > 0) && ((1.0f / base->clockFreq) > config->base.minResolution))
    {
        result = FALSE;
	/* Application has not provided any pointer to a buffer */
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }
    else
    {}

    /* Set the frequency */
    IfxCcu6_TimerWithTrigger_setFrequency(driver, config->base.frequency);

    return result;
}


boolean IfxCcu6_TimerWithTrigger_initTrigger(IfxCcu6_TimerWithTrigger *driver, IfxCcu6_TimerWithTrigger_Config *config)
{
    boolean                        result = TRUE;
    Ifx_CCU6                       *module = config->ccu6;
    IfxCcu6_TimerWithTrigger_Base *base   = &driver->base;


    /** - The T13 is used to generate additional PWM for internal trigger purpose (e.g.
         *  ADC) or external trigger purpose (e.g. sensor synchronisation). */

    Ifx_CCU6_TCTR0 tctr0 = module->TCTR0;
    module->TCTR0.B.T13CLK = tctr0.B.T12CLK;
    module->TCTR0.B.T13PRE = tctr0.B.T12PRE;
    module->T13PR.B.T13PV = (uint16)(base->period - 1);

    module->MODCTR.B.T13MODEN = 0;
    /* enable modulation output path */
    IfxCcu6_enableModulationOutput(module, IfxCcu6_TimerId_t13, IfxCcu6_ChannelOut_cout3);

    /* Set the output passive level for Cout3 */
    IfxCcu6_setOutputPassiveLevel(module, IfxCcu6_ChannelOut_cout3, config->base.trigger.risingEdgeAtPeriod);

    /* Enable the single shot mode for timer t13 */
    IfxCcu6_setSingleShotModeEnable(module, FALSE, TRUE);

    module->TCTR2.B.T13TEC = IfxCcu6_T13TriggerEvent_onT12Zero;
    module->TCTR2.B.T13TED = IfxCcu6_T13TriggerDirection_onT12CountingUp;

    if (config->base.trigger.outputEnabled)
    {
        if (config->triggerOut != NULL_PTR)
        {
            /*Initialize the port */
            IfxCcu6_initCout63Pin(config->triggerOut, config->base.trigger.outputMode, config->base.trigger.outputDriver);
        }
        else
        {
            result = FALSE;
        }
    }
    else
    {}

    driver->ccu6->CC63SR.U = config->base.trigger.triggerPoint;

    return result;
}


void IfxCcu6_TimerWithTrigger_initInterrupt(IfxCcu6_TimerWithTrigger *driver, IfxCcu6_TimerWithTrigger_Config *config)
{
    IfxCcu6_TimerWithTrigger_Base *base   = &driver->base;
    Ifx_CCU6                       *module = config->ccu6;
    boolean timerHasIrq   = config->base.isrPriority > 0;
    boolean triggerHasIrq = (config->base.trigger.isrPriority > 0) && base->triggerEnabled;


    volatile Ifx_SRC_SRCR *src;

    module->ISR.U = (1U << IfxCcu6_InterruptSource_t12PeriodMatch);
    module->ISR.U = (1U << IfxCcu6_InterruptSource_t12OneMatch);
    module->ISR.U = (1U << IfxCcu6_InterruptSource_t13CompareMatch);

    if (timerHasIrq)
    {
        if (config->base.countDir == IfxCcu6_Timer_CountDir_upAndDown)
        {
            module->IEN.U |= ((1U << IfxCcu6_InterruptSource_t12OneMatch));
        }
        else
        {
            module->IEN.U |= ((1U << IfxCcu6_InterruptSource_t12PeriodMatch));
        }

        module->INP.B.INPT12 = config->serviceReqNrPeriod;
        src                  = IfxCcu6_getSrcAddress(module, config->serviceReqNrPeriod);
        IfxSrc_init(src, config->base.isrProvider, config->base.isrPriority);
        IfxSrc_enable(src);
    }

    if (triggerHasIrq)
    {
        module->IEN.U |= ((1U << IfxCcu6_InterruptSource_t13CompareMatch));
        module->INP.B.INPT13 = config->serviceReqNrTrigger;

        src                  = IfxCcu6_getSrcAddress(module, config->serviceReqNrTrigger);
        IfxSrc_init(src, config->base.trigger.isrProvider, config->base.trigger.isrPriority);
        IfxSrc_enable(src);
    }
}


void IfxCcu6_TimerWithTrigger_initConfig(IfxCcu6_TimerWithTrigger_Config *config, Ifx_CCU6 *ccu6)
{
    config->base.frequency                  = 1000;
    config->base.isrPriority                = 0;
    config->base.isrProvider                = IfxSrc_Tos_cpu0;
    config->base.minResolution              = 0;
    config->base.trigger.outputMode         = IfxPort_OutputMode_pushPull;
    config->base.trigger.outputDriver       = IfxPort_PadDriver_cmosAutomotiveSpeed1;
    config->base.trigger.risingEdgeAtPeriod = FALSE;
    config->base.trigger.outputEnabled      = FALSE;
    config->base.trigger.enabled            = FALSE;
    config->base.trigger.triggerPoint       = 0;
    config->base.trigger.isrPriority        = 0;
    config->base.trigger.isrProvider        = IfxSrc_Tos_cpu0;
    config->base.countDir                   = IfxCcu6_Timer_CountDir_up;
    config->base.startOffset                = 0.0;

    config->ccu6                = ccu6;
    config->serviceReqNrPeriod  = IfxCcu6_ServiceRequest_0;
    config->serviceReqNrTrigger = IfxCcu6_ServiceRequest_1;
    config->triggerOut          = NULL_PTR;
}


void IfxCcu6_TimerWithTrigger_run(IfxCcu6_TimerWithTrigger *driver)
{
    /* Start the timer t12 */
    IfxCcu6_startTimer(driver->ccu6, TRUE, FALSE);
}


boolean IfxCcu6_TimerWithTrigger_setFrequency(IfxCcu6_TimerWithTrigger *driver, float32 frequency)
{
    Ifx_TimerValue period = (1.0f / frequency) * driver->base.clockFreq;

    return IfxCcu6_TimerWithTrigger_setPeriod(driver, period);
}


boolean IfxCcu6_TimerWithTrigger_setPeriod(IfxCcu6_TimerWithTrigger *driver, Ifx_TimerValue period)
{
    driver->base.period = period;
    driver->ccu6->T12PR.B.T12PV = (uint16)((driver->ccu6->TCTR0.B.CTM == 1) ?
                                    ((period / 2) - 1) : (period - 1));
    return TRUE;
}


void IfxCcu6_TimerWithTrigger_setSingleMode(IfxCcu6_TimerWithTrigger *driver, boolean enabled)
{
    if (enabled)
    {
	/* Set the T12 bit in the TCTR2 register to enable single mode for timer T12 */
        driver->ccu6->TCTR2.U |= (1U << IfxCcu6_TimerId_t12);
    }
    else
    {
	/* Clear the T12 bit in the TCTR2 register to disable single mode for timer T12 */
        driver->ccu6->TCTR2.U &= ~(1U << IfxCcu6_TimerId_t12);
    }
}


void IfxCcu6_TimerWithTrigger_setTrigger(IfxCcu6_TimerWithTrigger *driver, Ifx_TimerValue triggerPoint)
{
    driver->ccu6->CC63SR.U = triggerPoint;
}


void IfxCcu6_TimerWithTrigger_stop(IfxCcu6_TimerWithTrigger *driver)
{
    /* Stop the timer t12 and t13 */
    IfxCcu6_stopTimer(driver->ccu6, TRUE, TRUE);
}


void IfxCcu6_TimerWithTrigger_updateInputFrequency(IfxCcu6_TimerWithTrigger *driver)
{
    uint16 prescaler;
    prescaler              = driver->ccu6->TCTR0.B.T12CLK | (driver->ccu6->TCTR0.B.T12PRE << 3);

    driver->base.clockFreq = IfxScuCcu_getSpbFrequency() / (1U << prescaler);
}
