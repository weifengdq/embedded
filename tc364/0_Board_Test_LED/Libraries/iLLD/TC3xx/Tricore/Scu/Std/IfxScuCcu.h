/**
 * \file IfxScuCcu.h
 * \brief SCU  basic functionality
 * \ingroup IfxLld_Scu
 *
 * \version iLLD_1_20_0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Scu SCU
 * \addtogroup IfxLld_Scu
 * \{
 * \defgroup IfxLld_ScuCcu How to use the Scu Clock driver?
 * \addtogroup IfxLld_ScuCcu
 * \{
 *
 * The Scu Clock control unit driver provides a default configuration for pll and Clock initialisation and set of peripheral clock configuration functions.
 *
 * In the following sections it will be described, how to integrate the driver into the application framework.
 *
 * \section IfxLld_ScuCcu_Std_Preparation Preparation
 * \subsection IfxLld_ScuCcu_Std_Include Include Files
 *
 * Include following header file into your C code:
 * \code
 * #include <Scu/Std/IfxScuCcu.h>
 * \endcode
 *
 * \subsection IfxLld_ScuCcu_Std_Variables Variables
 *
 * Declare the Clock Configuration variables in your C code:
 *
 * \code
 * // used globally
 *
 * // configuration for the PLL  steps
 * static IfxScuCcu_PllStepsConfig IfxScuCcu_testPllConfigSteps[] = {
 *     IFXSCU_CFG_PLL_STEPS
 * };
 *
 * static const IfxScuCcu_FlashWaitstateConfig IfxScuCcu_defaultFlashWaitstateConfig = IFXSCU_CFG_FLASH_WAITSTATE;
 * // Default configuration for the Clock Configuration
 * IfxScuCcu_Config                      IfxScuCcu_testClockConfig = {
 *     // IfxScuCcu_InitialStepConfig: Configuration of first step which is same as internal osc frequency.
 *     IFXSCU_CFG_PLL_INITIAL_STEP,
 *     //IfxScuCcu_PllThrottleConfig: Configuration of PLL throttling.
 *     {
 *         sizeof(IfxScuCcu_defaultPllConfigSteps) / sizeof(IfxScuCcu_PllStepConfig),
 *         IfxScuCcu_defaultPllConfigSteps
 *     },
 *     IFXSCU_CFG_CLK_DISTRIBUTION,
 *     &IfxScuCcu_defaultFlashWaitstateConfig,
 *     &IfxScuCcu_defaultModConfig
 * };
 *
 * \endcode
 *
 * \subsection IfxLld_ScuCcu_Std_Init Module Initialisation
 *
 * The module initialisation can be done in the same function. Here an example:
 * \code
 *
 *        // standard PLL & clock initialisation
 *         IfxScuCcu_init(&IfxScuCcu_testClockConfig);
 * \endcode
 *
 *    The SYS PLL, PER PLL1 , PLL2 and clocks are now initialised based on the XTAL and PLL values configured in Ifx_Cfg.h and are ready for use now!
 *
 * Alternately the PLL and clocks can be initialised using below method which provides greater control on the configuration.
 *
 * \code
 * static const IfxScuCcu_PllStepConfig IfxScuCcu_defaultPllConfigSteps[] = {
 *     {                   //Step 0 Config: 150MHz
 *         (4 - 1),        //uint8 k2Step;
 *         0.000100f,       //float32 waitTime;
 *     },
 *     {                   //Step 1 Config: 200MHz
 *         (3 - 1),       //uint8 k2Step;
 *         0.000100f,       //float32 waitTime;
 *     },
 *     {                   //Step 2 Config: 300MHz
 *         (2 - 1),        //uint8 k2Step;
 *         0.000100f,       //float32 waitTime;
 *     }
 * };
 *     IfxScuCcu_Config        IfxScuCcu_sampleClockConfig;
 *
 *     IfxScuCcu_initConfig(&IfxScuCcu_sampleClockConfig);
 *
 *
 *
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.pllInputClockSelection = IfxScuCcu_PllInputClockSelection_fOsc0;
 *
 *     //SYS PLL = 300Mhz, XTAL = 20Mhz
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.sysPllConfig.k2Divider = IfxScuCcu_K2divider_2;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.sysPllConfig.nDivider = IfxScuCcu_Ndivider_60;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.sysPllConfig.pDivider = IfxScuCcu_Pdivider_2;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.waitTime = 0.000200F;  // wait time
 *
 *     IfxScuCcu_sampleClockConfig.sysPllThrottleConfig.numOfSteps = sizeof(IfxScuCcu_defaultPllConfigSteps) / sizeof(IfxScuCcu_PllStepConfig); //  step clock incr
 *     IfxScuCcu_sampleClockConfig.sysPllThrottleConfig.pllSteps = IfxScuCcu_defaultPllConfigSteps;
 *
 *     // PER PLL1 = 240Mhz, PERPLL2 = 50Mhz
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.k2Divider = IfxScuCcu_K2divider_2;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.k3Divider = IfxScuCcu_K3divider_6;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.k3DividerBypass = 0;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.nDivider = IfxScuCcu_Ndivider_24;
 *     IfxScuCcu_sampleClockConfig.pllInitialStepConfig.pllsParameters.perPllConfig.pDivider = IfxScuCcu_Pdivider_1;
 *
 *     // update CCUCON Config use mask and value as below
 *     IfxScuCcu_sampleClockConfig.clockDistribution.ccucon0.mask =IFXSCU_CFG_CCUCON0_MASK;
 *     IfxScuCcu_sampleClockConfig.clockDistribution.ccucon0.value = IFXSCU_CFG_CCUCON0;
 *
 *     // standard PLL & clock initialisation
 *     IfxScuCcu_init(&IfxScuCcu_sampleClockConfig);
 *
 * \endcode
 *
 * ** Modulation Configuration **
 * The SCU CCU module also provides an option to Frequency Modulate the clock.
 * The Modulation configuration can be done as follows:
 *
 * \code
 *
 * //define your modulation configuration structure:
 *
 *  IFX_CONST IfxScuCcu_Mod_Config IfxScuCcu_SampleModConfig = {
 *          IfxScuCcu_ModEn_disabled,          // disable is default //enable / disable modulation
 *          IfxScuCcu_ModulationAmplitude_0p5, // default 0 value  // specify the modulation amplitude %
 *
 *  }
 *  // put this as part of the CCU configuration:
 *  IfxScuCcu_sampleClockConfig.modulationConfig = &IfxScuCcu_SampleModConfig;
 *
 *  // now initalize the CCU PLL and clock with the init function
 *  IfxScuCcu_init(&IfxScuCcu_sampleClockConfig)
 * \endcode
 *
 * \}
 * \}
 *
 * \defgroup IfxLld_Scu_Std_Ccu Ccu Basic Functionality
 * \ingroup IfxLld_Scu_Std
 * \defgroup IfxLld_Scu_Std_Ccu_Ccu Clock Control Functions
 * \ingroup IfxLld_Scu_Std_Ccu
 * \defgroup IfxLld_Scu_Std_Ccu_Ccu_Operative Clock Control Operative Functions
 * \ingroup IfxLld_Scu_Std_Ccu
 * \defgroup IfxLld_Scu_Std_Ccu_Ccu_Configuration Clock Control Configuration Functions
 * \ingroup IfxLld_Scu_Std_Ccu
 * \defgroup IfxLld_Scu_Std_Ccu_Enum Enumerations
 * \ingroup IfxLld_Scu_Std_Ccu
 */

#ifndef IFXSCUCCU_H
#define IFXSCUCCU_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxScu_cfg.h"
#include "Scu/Std/IfxScuWdt.h"
#include "Cpu/Std/IfxCpu.h"
#include "IfxStm_reg.h"
#include "IfxScu_reg.h"
#include "_PinMap/IfxScu_PinMap.h"
#include "IfxSmu_reg.h"
#include "IfxDmu_reg.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Oscillator stability check timeout count
 */
#ifndef IFXSCUCCU_OSC_STABLECHK_TIME
#define IFXSCUCCU_OSC_STABLECHK_TIME               (640)
#endif

/** \brief
 */
#define IFXSCUCCU_SMUALARM_MASK                    (0x1DU)

/** \brief ~40uS max wait time
 */
#ifndef IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT
#define IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT     (0x1000U)
#endif

/** \brief ~122uS max wait time for PLL locking
 */
#define IFXSCUCCU_PLL_LOCK_TIMEOUT_COUNT           (0x3000U)

/** \brief ~122uS max wait time for PLL power down/up state update
 */
#define IFXSCUCCU_SYSPLLSTAT_PWDSTAT_TIMEOUT_COUNT (0x3000U)

/** \brief ~244uS max wait time
 */
#define IFXSCUCCU_PLL_KRDY_TIMEOUT_COUNT           (0x6000U)

/** \brief 3mS max wait time for PLL power down/up state update
 */
#define IFXSCUCCU_OSCCON_PLLLV_OR_HV_TIMEOUT_COUNT (0x493E0U)

#define IFXSCUCCU_LOOP_TIMEOUT_CHECK(tVar, tErr) \
    {                                            \
        if (((sint32)--tVar) <= 0)               \
        {                                        \
            tErr = (uint8)1;                     \
            break;                               \
        }                                        \
        else                                     \
        {                                        \
        }                                        \
    }

/** \brief Modulation frequency
 */
#define IFXSCUCCU_MODULATION_FREQ_HZ               (3600000)

/** \brief MODCFG shift value for SYSPLLCON2
 */
#define IFXSCUCCU_MODCFG_DEFAULT_SHIFT             (10)

/** \brief MODCFG default value - for SYSPLLCON2[15:10]
 */
#define IFXSCUCCU_MODCFG_DEFAULT_VAL               ((uint32)0x3D)

/** \brief get Rgain from MA and FDco
 */
#define IFXSCUCCU_GET_RGAIN_NOM(MA, FDco)  ((2 * (MA / 100) * (FDco / IFXSCUCCU_MODULATION_FREQ_HZ)))

/** \brief Get RGAin HEX from RGain Nominal value
 */
#define IFXSCUCCU_GET_RGAIN_HEX(RGain_Nom) ((uint16)((RGain_Nom * 32) + 0.5f))

/** \brief Get MODCFG from RGAIN_HEX
 */
#define IFXSCUCCU_GET_MODCFG(RGain_Hex)    ((uint16)(IFXSCUCCU_MODCFG_DEFAULT_VAL << IFXSCUCCU_MODCFG_DEFAULT_SHIFT) | (uint16)(RGain_Hex))

/** \brief Define to include the flash wait state check in ScuCcu_init()
 */
#define IFXSCUCCU_FLASHWAITSTATECHECK (0)

/** \brief 10 microsecond wait time between steps to jump back to normal mode.
 */
#ifndef IFXSCUCCU_LPTONORMAL_WAITTIME
#define IFXSCUCCU_LPTONORMAL_WAITTIME (0.00001f)
#endif

/******************************************************************************/
/*------------------------------Type Definitions------------------------------*/
/******************************************************************************/

/** \brief Function pointer type for the hooks
 * \return None
 */
typedef void (*IfxScuCcu_PllStepsFunctionHook)(void);

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Scu_Std_Ccu_Enum
 * \{ */
/** \brief clock source selection
 */
typedef enum
{
    IfxScuCcu_Fsource_0 = 0,      /**< \brief fSource0  */
    IfxScuCcu_Fsource_1,          /**< \brief fSource1  */
    IfxScuCcu_Fsource_2           /**< \brief fSource2  */
} IfxScuCcu_Fsource;

/** \brief MODULE_SCU.PLLCON1.B.K2DIV, specifies the K2-Divider
 */
typedef enum
{
    IfxScuCcu_K2divider_1 = 0,      /**< \brief K2-Divider 1  */
    IfxScuCcu_K2divider_2,          /**< \brief K2-Divider 2  */
    IfxScuCcu_K2divider_3,          /**< \brief K2-Divider 3  */
    IfxScuCcu_K2divider_4,          /**< \brief K2-Divider 4  */
    IfxScuCcu_K2divider_5,          /**< \brief K2-Divider 5  */
    IfxScuCcu_K2divider_6,          /**< \brief K2-Divider 6  */
    IfxScuCcu_K2divider_7,          /**< \brief K2-Divider 7  */
    IfxScuCcu_K2divider_8           /**< \brief K2-Divider 8  */
} IfxScuCcu_K2divider;

/** \brief MODULE_SCU.PLLCON1.B.K3DIV, specifies the K3-Divider
 */
typedef enum
{
    IfxScuCcu_K3divider_1 = 0,      /**< \brief K3-Divider 1  */
    IfxScuCcu_K3divider_2,          /**< \brief K3-Divider 2  */
    IfxScuCcu_K3divider_3,          /**< \brief K3-Divider 3  */
    IfxScuCcu_K3divider_4,          /**< \brief K3-Divider 4  */
    IfxScuCcu_K3divider_5,          /**< \brief K3-Divider 5  */
    IfxScuCcu_K3divider_6,          /**< \brief K3-Divider 6  */
    IfxScuCcu_K3divider_7,          /**< \brief K3-Divider 7  */
    IfxScuCcu_K3divider_8           /**< \brief K3-Divider 8  */
} IfxScuCcu_K3divider;

/** \brief Low Power Division Ratios.
 * Corresponds to values of LPDIV in CCUCON0.
 */
typedef enum
{
    IfxScuCcu_LowPowerDivRatio_divBy30 = 1,  /**< \brief Divide by 30 */
    IfxScuCcu_LowPowerDivRatio_divBy60,      /**< \brief Divide by 60 */
    IfxScuCcu_LowPowerDivRatio_divBy120,     /**< \brief Divide by 120 */
    IfxScuCcu_LowPowerDivRatio_divBy240      /**< \brief Divide by 240 */
} IfxScuCcu_LowPowerDivRatio;

/** \brief ENUM for MA (%) values
 */
typedef enum
{
    IfxScuCcu_ModulationAmplitude_0p5 = 0,      /**< \brief 0.5%  */
    IfxScuCcu_ModulationAmplitude_1p0,          /**< \brief 1.0%  */
    IfxScuCcu_ModulationAmplitude_1p25,         /**< \brief 1.25%  */
    IfxScuCcu_ModulationAmplitude_1p5,          /**< \brief 1.5%  */
    IfxScuCcu_ModulationAmplitude_2p0,          /**< \brief 2%  */
    IfxScuCcu_ModulationAmplitude_2p5,          /**< \brief 2.5%  */
    IfxScuCcu_ModulationAmplitude_count,        /**< \brief range  */
} IfxScuCcu_ModulationAmplitude;

/** \brief MODULE_SCU.PLLCON0.B.NDIV, specifies the N-Divider
 */
typedef enum
{
    IfxScuCcu_Ndivider_1 = 0,      /**< \brief  N-divider 1  */
    IfxScuCcu_Ndivider_2,          /**< \brief  N-divider 2  */
    IfxScuCcu_Ndivider_3,          /**< \brief  N-divider 3  */
    IfxScuCcu_Ndivider_4,          /**< \brief  N-divider 4  */
    IfxScuCcu_Ndivider_5,          /**< \brief  N-divider 5  */
    IfxScuCcu_Ndivider_6,          /**< \brief  N-divider 6  */
    IfxScuCcu_Ndivider_7,          /**< \brief  N-divider 7  */
    IfxScuCcu_Ndivider_8,          /**< \brief  N-divider 8  */
    IfxScuCcu_Ndivider_9,          /**< \brief  N-divider 9  */
    IfxScuCcu_Ndivider_10,         /**< \brief  N-divider 10  */
    IfxScuCcu_Ndivider_11,         /**< \brief  N-divider 11  */
    IfxScuCcu_Ndivider_12,         /**< \brief  N-divider 12  */
    IfxScuCcu_Ndivider_13,         /**< \brief  N-divider 13  */
    IfxScuCcu_Ndivider_14,         /**< \brief  N-divider 14  */
    IfxScuCcu_Ndivider_15,         /**< \brief  N-divider 15  */
    IfxScuCcu_Ndivider_16,         /**< \brief  N-divider 16  */
    IfxScuCcu_Ndivider_17,         /**< \brief  N-divider 17  */
    IfxScuCcu_Ndivider_18,         /**< \brief  N-divider 18  */
    IfxScuCcu_Ndivider_19,         /**< \brief  N-divider 19  */
    IfxScuCcu_Ndivider_20,         /**< \brief  N-divider 20  */
    IfxScuCcu_Ndivider_21,         /**< \brief  N-divider 21  */
    IfxScuCcu_Ndivider_22,         /**< \brief  N-divider 22  */
    IfxScuCcu_Ndivider_23,         /**< \brief  N-divider 23  */
    IfxScuCcu_Ndivider_24,         /**< \brief  N-divider 24  */
    IfxScuCcu_Ndivider_25,         /**< \brief  N-divider 25  */
    IfxScuCcu_Ndivider_26,         /**< \brief  N-divider 26  */
    IfxScuCcu_Ndivider_27,         /**< \brief  N-divider 27  */
    IfxScuCcu_Ndivider_28,         /**< \brief  N-divider 28  */
    IfxScuCcu_Ndivider_29,         /**< \brief  N-divider 29  */
    IfxScuCcu_Ndivider_30,         /**< \brief  N-divider 30  */
    IfxScuCcu_Ndivider_31,         /**< \brief  N-divider 31  */
    IfxScuCcu_Ndivider_32,         /**< \brief  N-divider 32  */
    IfxScuCcu_Ndivider_33,         /**< \brief  N-divider 33  */
    IfxScuCcu_Ndivider_34,         /**< \brief  N-divider 34  */
    IfxScuCcu_Ndivider_35,         /**< \brief  N-divider 35  */
    IfxScuCcu_Ndivider_36,         /**< \brief  N-divider 36  */
    IfxScuCcu_Ndivider_37,         /**< \brief  N-divider 37  */
    IfxScuCcu_Ndivider_38,         /**< \brief  N-divider 38  */
    IfxScuCcu_Ndivider_39,         /**< \brief  N-divider 39  */
    IfxScuCcu_Ndivider_40,         /**< \brief  N-divider 40  */
    IfxScuCcu_Ndivider_41,         /**< \brief  N-divider 41  */
    IfxScuCcu_Ndivider_42,         /**< \brief  N-divider 42  */
    IfxScuCcu_Ndivider_43,         /**< \brief  N-divider 43  */
    IfxScuCcu_Ndivider_44,         /**< \brief  N-divider 44  */
    IfxScuCcu_Ndivider_45,         /**< \brief  N-divider 45  */
    IfxScuCcu_Ndivider_46,         /**< \brief  N-divider 46  */
    IfxScuCcu_Ndivider_47,         /**< \brief  N-divider 47  */
    IfxScuCcu_Ndivider_48,         /**< \brief  N-divider 48  */
    IfxScuCcu_Ndivider_49,         /**< \brief  N-divider 49  */
    IfxScuCcu_Ndivider_50,         /**< \brief  N-divider 50  */
    IfxScuCcu_Ndivider_51,         /**< \brief  N-divider 51  */
    IfxScuCcu_Ndivider_52,         /**< \brief  N-divider 52  */
    IfxScuCcu_Ndivider_53,         /**< \brief  N-divider 53  */
    IfxScuCcu_Ndivider_54,         /**< \brief  N-divider 54  */
    IfxScuCcu_Ndivider_55,         /**< \brief  N-divider 55  */
    IfxScuCcu_Ndivider_56,         /**< \brief  N-divider 56  */
    IfxScuCcu_Ndivider_57,         /**< \brief  N-divider 57  */
    IfxScuCcu_Ndivider_58,         /**< \brief  N-divider 58  */
    IfxScuCcu_Ndivider_59,         /**< \brief  N-divider 59  */
    IfxScuCcu_Ndivider_60,         /**< \brief  N-divider 60  */
    IfxScuCcu_Ndivider_61,         /**< \brief  N-divider 61  */
    IfxScuCcu_Ndivider_62,         /**< \brief  N-divider 62  */
    IfxScuCcu_Ndivider_63,         /**< \brief  N-divider 63  */
    IfxScuCcu_Ndivider_64,         /**< \brief  N-divider 64  */
    IfxScuCcu_Ndivider_65,         /**< \brief  N-divider 65  */
    IfxScuCcu_Ndivider_66,         /**< \brief  N-divider 66  */
    IfxScuCcu_Ndivider_67,         /**< \brief  N-divider 67  */
    IfxScuCcu_Ndivider_68,         /**< \brief  N-divider 68  */
    IfxScuCcu_Ndivider_69,         /**< \brief  N-divider 69  */
    IfxScuCcu_Ndivider_70,         /**< \brief  N-divider 70  */
    IfxScuCcu_Ndivider_71,         /**< \brief  N-divider 71  */
    IfxScuCcu_Ndivider_72,         /**< \brief  N-divider 72  */
    IfxScuCcu_Ndivider_73,         /**< \brief  N-divider 73  */
    IfxScuCcu_Ndivider_74,         /**< \brief  N-divider 74  */
    IfxScuCcu_Ndivider_75,         /**< \brief  N-divider 75  */
    IfxScuCcu_Ndivider_76,         /**< \brief  N-divider 76  */
    IfxScuCcu_Ndivider_77,         /**< \brief  N-divider 77  */
    IfxScuCcu_Ndivider_78,         /**< \brief  N-divider 78  */
    IfxScuCcu_Ndivider_79,         /**< \brief  N-divider 79  */
    IfxScuCcu_Ndivider_80,         /**< \brief  N-divider 80  */
    IfxScuCcu_Ndivider_81,         /**< \brief  N-divider 81  */
    IfxScuCcu_Ndivider_82,         /**< \brief  N-divider 82  */
    IfxScuCcu_Ndivider_83,         /**< \brief  N-divider 83  */
    IfxScuCcu_Ndivider_84,         /**< \brief  N-divider 84  */
    IfxScuCcu_Ndivider_85,         /**< \brief  N-divider 85  */
    IfxScuCcu_Ndivider_86,         /**< \brief  N-divider 86  */
    IfxScuCcu_Ndivider_87,         /**< \brief  N-divider 87  */
    IfxScuCcu_Ndivider_88,         /**< \brief  N-divider 88  */
    IfxScuCcu_Ndivider_89,         /**< \brief  N-divider 89  */
    IfxScuCcu_Ndivider_90,         /**< \brief  N-divider 90  */
    IfxScuCcu_Ndivider_91,         /**< \brief  N-divider 91  */
    IfxScuCcu_Ndivider_92,         /**< \brief  N-divider 92  */
    IfxScuCcu_Ndivider_93,         /**< \brief  N-divider 93  */
    IfxScuCcu_Ndivider_94,         /**< \brief  N-divider 94  */
    IfxScuCcu_Ndivider_95,         /**< \brief  N-divider 95  */
    IfxScuCcu_Ndivider_96,         /**< \brief  N-divider 96  */
    IfxScuCcu_Ndivider_97,         /**< \brief  N-divider 97  */
    IfxScuCcu_Ndivider_98,         /**< \brief  N-divider 98  */
    IfxScuCcu_Ndivider_99,         /**< \brief  N-divider 99  */
    IfxScuCcu_Ndivider_100,        /**< \brief  N-divider 100  */
    IfxScuCcu_Ndivider_101,        /**< \brief  N-divider 101  */
    IfxScuCcu_Ndivider_102,        /**< \brief  N-divider 102  */
    IfxScuCcu_Ndivider_103,        /**< \brief  N-divider 103  */
    IfxScuCcu_Ndivider_104,        /**< \brief  N-divider 104  */
    IfxScuCcu_Ndivider_105,        /**< \brief  N-divider 105  */
    IfxScuCcu_Ndivider_106,        /**< \brief  N-divider 106  */
    IfxScuCcu_Ndivider_107,        /**< \brief  N-divider 107  */
    IfxScuCcu_Ndivider_108,        /**< \brief  N-divider 108  */
    IfxScuCcu_Ndivider_109,        /**< \brief  N-divider 109  */
    IfxScuCcu_Ndivider_110,        /**< \brief  N-divider 110  */
    IfxScuCcu_Ndivider_111,        /**< \brief  N-divider 111  */
    IfxScuCcu_Ndivider_112,        /**< \brief  N-divider 112  */
    IfxScuCcu_Ndivider_113,        /**< \brief  N-divider 113  */
    IfxScuCcu_Ndivider_114,        /**< \brief  N-divider 114  */
    IfxScuCcu_Ndivider_115,        /**< \brief  N-divider 115  */
    IfxScuCcu_Ndivider_116,        /**< \brief  N-divider 116  */
    IfxScuCcu_Ndivider_117,        /**< \brief  N-divider 117  */
    IfxScuCcu_Ndivider_118,        /**< \brief  N-divider 118  */
    IfxScuCcu_Ndivider_119,        /**< \brief  N-divider 119  */
    IfxScuCcu_Ndivider_120,        /**< \brief  N-divider 120  */
    IfxScuCcu_Ndivider_121,        /**< \brief  N-divider 121  */
    IfxScuCcu_Ndivider_122,        /**< \brief  N-divider 122  */
    IfxScuCcu_Ndivider_123,        /**< \brief  N-divider 123  */
    IfxScuCcu_Ndivider_124,        /**< \brief  N-divider 124  */
    IfxScuCcu_Ndivider_125,        /**< \brief  N-divider 125  */
    IfxScuCcu_Ndivider_126,        /**< \brief  N-divider 126  */
    IfxScuCcu_Ndivider_127,        /**< \brief  N-divider 127  */
    IfxScuCcu_Ndivider_128         /**< \brief  N-divider 128  */
} IfxScuCcu_Ndivider;

/** \brief MODULE_SCU.PLLCON0.B.PDIV, specifies the P-Divider
 */
typedef enum
{
    IfxScuCcu_Pdivider_1 = 0,      /**< \brief  P-divider 1  */
    IfxScuCcu_Pdivider_2,          /**< \brief  P-divider 2  */
    IfxScuCcu_Pdivider_3,          /**< \brief  P-divider 3  */
    IfxScuCcu_Pdivider_4,          /**< \brief  P-divider 4  */
    IfxScuCcu_Pdivider_5,          /**< \brief  P-divider 5  */
    IfxScuCcu_Pdivider_6,          /**< \brief  P-divider 6  */
    IfxScuCcu_Pdivider_7,          /**< \brief  P-divider 7  */
    IfxScuCcu_Pdivider_8           /**< \brief  P-divider 8  */
} IfxScuCcu_Pdivider;

/** \brief SysPll & Per Pll input clock selection.
 * SYSPLLCON0.B.INSEL
 */
typedef enum
{
    IfxScuCcu_PllInputClockSelection_fOsc1   = 0, /**< \brief Backup clock select */
    IfxScuCcu_PllInputClockSelection_fOsc0   = 1, /**< \brief fOsc0 or XTAL clock select */
    IfxScuCcu_PllInputClockSelection_fSysclk = 2  /**< \brief fOsc1 */
} IfxScuCcu_PllInputClockSelection;

/** \brief trap request type
 */
typedef enum
{
    IfxScuCcu_Traprequest_esr0 = 0,  /**< \brief external service request 0 */
    IfxScuCcu_Traprequest_esr1,      /**< \brief external service request 1 */
    IfxScuCcu_Traprequest_trap2,     /**< \brief trap2 */
    IfxScuCcu_Traprequest_smu        /**< \brief safety management unit */
} IfxScuCcu_Traprequest;

/** \} */

/** \brief divider mode selection for EXTCLK0
 */
typedef enum
{
    IfxScuCcu_Clk0Mode_normal     = 1, /**< \brief Select normal mode */
    IfxScuCcu_Clk0Mode_fractional = 2  /**< \brief Select fractional mode */
} IfxScuCcu_Clk0Mode;

/** \brief clock line negation selection for EXTCLK1
 */
typedef enum
{
    IfxScuCcu_Clk1Negation_inverted     = 0, /**< \brief Select inverted signal for EXTCLK1 */
    IfxScuCcu_Clk1Negation_Clk1Negation = 1  /**< \brief Select non inverted signal for EXTCLK1 */
} IfxScuCcu_Clk1Negation;

/** \brief External Clock Selection for EXTCLK0
 */
typedef enum
{
    IfxScuCcu_ClkSel0_fOUT  = 0,   /**< \brief Select fOUT as EXTCLK0 */
    IfxScuCcu_ClkSel0_fPLL0 = 1,   /**< \brief Select fPLL0 as EXTCLK0 */
    IfxScuCcu_ClkSel0_fPLL1 = 2,   /**< \brief Select fPLL1 as EXTCLK0 */
    IfxScuCcu_ClkSel0_fOSC0 = 3,   /**< \brief Select fOSC0 as EXTCLK0 */
    IfxScuCcu_ClkSel0_fBACK = 4,   /**< \brief Select fBACK as EXTCLK0 */
    IfxScuCcu_ClkSel0_fPLL2 = 5,   /**< \brief Select fPLL2 as EXTCLK0 */
    IfxScuCcu_ClkSel0_fBBB  = 6,   /**< \brief Select fBBB as EXTCLK0 */
    IfxScuCcu_ClkSel0_fSRI  = 8,   /**< \brief Select fSRI as EXTCLK0 */
    IfxScuCcu_ClkSel0_fSPB  = 9,   /**< \brief Select fSPB as EXTCLK0 */
    IfxScuCcu_ClkSel0_fFSI  = 10,  /**< \brief Select fFSI as EXTCLK0 */
    IfxScuCcu_ClkSel0_fSTM  = 11,  /**< \brief Select fSTM as EXTCLK0 */
    IfxScuCcu_ClkSel0_fGTM  = 12,  /**< \brief Select fGTM as EXTCLK0 */
    IfxScuCcu_ClkSel0_fFSI2 = 14,  /**< \brief Select fFSI2 as EXTCLK0 */
    IfxScuCcu_ClkSel0_fMT0  = 15   /**< \brief Select fMT0 as EXTCLK0 */
} IfxScuCcu_ClkSel0;

/** \brief External Clock Selection for EXTCLK1
 */
typedef enum
{
    IfxScuCcu_ClkSel1_fOUT     = 0,   /**< \brief Select fOUT as EXTCLK1 */
    IfxScuCcu_ClkSel1_fPLL0    = 1,   /**< \brief Select fPLL0 as EXTCLK1 */
    IfxScuCcu_ClkSel1_fPLL1    = 2,   /**< \brief Select fPLL1 as EXTCLK1 */
    IfxScuCcu_ClkSel1_fEBU     = 3,   /**< \brief Select fEBU as EXTCLK1 */
    IfxScuCcu_ClkSel1_fBACK    = 4,   /**< \brief Select fBACK as EXTCLK1 */
    IfxScuCcu_ClkSel1_fMCAN    = 5,   /**< \brief Select fMCAN as EXTCLK1 */
    IfxScuCcu_ClkSel1_fADC     = 6,   /**< \brief Select fADC as EXTCLK1 */
    IfxScuCcu_ClkSel1_fQSPI    = 7,   /**< \brief Select fQSPI as EXTCLK1 */
    IfxScuCcu_ClkSel1_fSRI     = 8,   /**< \brief Select fSRI as EXTCLK1 */
    IfxScuCcu_ClkSel1_fSPB     = 9,   /**< \brief Select fSPB as EXTCLK1 */
    IfxScuCcu_ClkSel1_fI2C     = 10,  /**< \brief Select fI2C as EXTCLK1 */
    IfxScuCcu_ClkSel1_fMSC     = 11,  /**< \brief Select fMSC as EXTCLK1 */
    IfxScuCcu_ClkSel1_fERAY    = 12,  /**< \brief Select fERAY as EXTCLK1 */
    IfxScuCcu_ClkSel1_fASCLINF = 13,  /**< \brief Select fASCLINF as EXTCLK1 */
    IfxScuCcu_ClkSel1_fASCLINS = 14   /**< \brief Select fASCLINS as EXTCLK1 */
} IfxScuCcu_ClkSel1;

/** \brief modulation enable
 */
typedef enum
{
    IfxScuCcu_ModEn_disabled = 0,  /**< \brief disable modulation */
    IfxScuCcu_ModEn_enabled  = 1   /**< \brief enable modulation */
} IfxScuCcu_ModEn;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Configuration
 * \{ */
/** \brief Configuration structure type for the Per Pll step.
 * This structure must be used to configure the P, N and K2, K3 dividers .
 */
typedef struct
{
    uint8 pDivider;              /**< \brief P divider value for basic (initial) step */
    uint8 nDivider;              /**< \brief N divider value for basic (initial) step */
    uint8 k2Divider;             /**< \brief K2 divider value */
    uint8 k3Divider;             /**< \brief K3 divider value */
    uint8 k3DividerBypass;       /**< \brief Divider Bypass
                                  * 0 - The divide by block in front of the K3-Divider is not bypassed.
                                  * 1-  The divide by block in front of the K3-Divider is bypassed. */
} IfxScuCcu_PerPllConfig;

/** \brief Configuration structure type for the Pll initial step.
 * This structure must be used to configure the P, N and K2 dividers for initial step.
 */
typedef struct
{
    uint8 pDivider;        /**< \brief P divider value */
    uint8 nDivider;        /**< \brief N divider value */
    uint8 k2Divider;       /**< \brief K2 divider value */
} IfxScuCcu_SysPllConfig;

/** \} */

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Configuration
 * \{ */
/** \brief Configuration structure type for CCUCON registers.
 */
typedef struct
{
    uint32 value;       /**< \brief CCUCON Register value to be updated. */
    uint32 mask;        /**< \brief CCUCON Mask to select the bit fields to be updated. */
} IfxScuCcu_CcuconRegConfig;

/** \brief Configuration structure type for the Pll Steps for current jump control.
 */
typedef struct
{
    uint8   k2Step;         /**< \brief K2 divider value for this step. */
    float32 waitTime;       /**< \brief Wait time for for this step. */
} IfxScuCcu_PllStepConfig;

/** \brief Configuration structure type for the Pll Parameters.
 */
typedef struct
{
    uint32                           xtalFrequency;                /**< \brief Xtal frequency */
    IfxScuCcu_PllInputClockSelection pllInputClockSelection;       /**< \brief Pll input clock selection */
    IfxScuCcu_SysPllConfig           sysPllConfig;                 /**< \brief System PLL Configurations */
    IfxScuCcu_PerPllConfig           perPllConfig;                 /**< \brief Peripheral PLL Configurations */
} IfxScuCcu_pllsParameterConfig;

/** \} */

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu
 * \{ */
/** \brief Configuration structure type for the Flash waitstate configuration.
 */
typedef struct
{
    uint32 value;       /**< \brief FLASH.FCON Register value to be updated. */
    uint32 mask;        /**< \brief FLASH.FCON Mask to select the bit fields to be updated. */
} IfxScuCcu_FlashWaitstateConfig;

/** \} */

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Configuration
 * \{ */
/** \brief Configuration structure type for all the CCUCON registers to configure clock distribution.
 */
typedef struct
{
    IfxScuCcu_CcuconRegConfig ccucon0;        /**< \brief CCUCON0 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon1;        /**< \brief CCUCON1 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon2;        /**< \brief CCUCON2 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon5;        /**< \brief CCUCON5 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon6;        /**< \brief CCUCON6 Register configuration */
#ifndef DEVICE_TC33X 	
    IfxScuCcu_CcuconRegConfig ccucon7;        /**< \brief CCUCON7 Register configuration */
#endif
#if defined(DEVICE_TC35X) || defined(DEVICE_TC37X) || defined(DEVICE_TC37XED) || defined(DEVICE_TC38EVOX) || defined(DEVICE_TC38X) || defined(DEVICE_TC39XB)
    IfxScuCcu_CcuconRegConfig ccucon8;        /**< \brief CCUCON8 Register configuration */
#endif	
#if defined(DEVICE_TC38EVOX) || defined(DEVICE_TC38X) || defined(DEVICE_TC39XB)
    IfxScuCcu_CcuconRegConfig ccucon9;        /**< \brief CCUCON9 Register configuration */
#endif
#ifdef DEVICE_TC39XB
    IfxScuCcu_CcuconRegConfig ccucon10;       /**< \brief CCUCON10 Register configuration */
    IfxScuCcu_CcuconRegConfig ccucon11;       /**< \brief CCUCON11 Register configuration */
#endif
} IfxScuCcu_ClockDistributionConfig;

/** \brief Configuration structure type for the Pll Initial Step Configuration.
 */
typedef struct
{
    IfxScuCcu_pllsParameterConfig pllsParameters;       /**< \brief Configuration Parameters for both PLLs */
    float32                       waitTime;             /**< \brief Wait time for for basic (initial) step */
} IfxScuCcu_InitialStepConfig;

/** \brief
 */
typedef struct
{
    uint8                              numOfSteps;       /**< \brief Number of PLL divider steps during clock throttling */
    IFX_CONST IfxScuCcu_PllStepConfig *pllSteps;         /**< \brief Pointer to the array of Pll divider step configuration. */
} IfxScuCcu_PllThrottleConfig;

/** \} */

/** \brief modulation config
 */
typedef struct
{
    IfxScuCcu_ModEn               Mod_Enable;       /**< \brief modulation enable */
    IfxScuCcu_ModulationAmplitude Mod_Amp;          /**< \brief modulation amplitude */
} IfxScuCcu_Mod_Config;

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Configuration
 * \{ */
/** \brief Configuration structure SCU module
 */
typedef struct
{
    IfxScuCcu_InitialStepConfig               pllInitialStepConfig;           /**< \brief Configuration of first step which is same as internal osc frequency. */
    IfxScuCcu_PllThrottleConfig               sysPllThrottleConfig;           /**< \brief Configuration of PLL throttling. */
    IfxScuCcu_ClockDistributionConfig         clockDistribution;              /**< \brief Configuration of of bus clocks and other module clock distribution. */
    IFX_CONST IfxScuCcu_FlashWaitstateConfig *flashFconWaitStateConfig;       /**< \brief Configuration of flash waitstate */
    IFX_CONST IfxScuCcu_Mod_Config           *modulationConfig;               /**< \brief modulation configuration */
} IfxScuCcu_Config;

/** \} */

/** \brief structure holding the RGain parameters for modulation
 */
typedef struct
{
    float32 RGainNom;       /**< \brief RGain Nominal value */
    uint16  RGainHex;       /**< \brief RGain Hex value */
} IfxScuCcu_RGain_Values;

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Waits for the specified duration in seconds.
 *
 * \param[in] timeSec The duration to wait, specified in seconds.
 * 			  		  Range: Must be a positive value (timeSec > 0).
 *
 * \retval None
 *
 * \note IfxScuCcu_wait shall not use STM in future,
 * 		 because we can guarantee that STM is enabled after reset
 * 		 but if PLL init is called for changing the frequency during runtime,
 * 		 there is no guarantee that STM is enabled.
 */
IFX_INLINE void IfxScuCcu_wait(float32 timeSec);

/**
 * \brief Waits for the specified duration while servicing the watchdog to
 * 		  prevent chip reset during startup.
 *
 * \param[in] timeSec The duration to wait, specified in seconds.
 * 			  		  Range: Must be a positive value (timeSec > 0).
 *
 * \retval None
 *
 * \note IfxScuCcu_wait shall not use STM in future, because we can guarantee
 * 		 that STM is enabled after reset but if PLL init is called for changing the
 * 		 frequency during runtime, there is no guarantee that STM is enabled.
 */
IFX_INLINE void IfxScuCcu_waitWithWdtService(float32 timeSec);

/**
 * \brief Configures the LPDIV value to enter Low Power mode.
 *
 * Caution:
 * write to LPDIV with non-zero division ratio will cause system to enter low power mode.
 * Low power mode will affect different SPBDIV and SRIDIV ratios.
 *
 * The original CCUCON0 ratios should be preserved by user prior to calling this function.
 * The "normal" CCUCON0 ratios have to be passed to API: "IfxScuCcu_switchToNormalMode"
 * to go back to the original division ratios.
 *
 * \param[in] lpDiv The Low Power Division Ratio to configure.
 *                  Range: \ref IfxScuCcu_LowPowerDivRatio
 *
 * \retval None
 */
IFX_INLINE void IfxScuCcu_switchToLowPowerMode(IfxScuCcu_LowPowerDivRatio lpDiv);

/**
 * \brief Switches back to normal mode from low power mode using the original CCUCON0 settings.
 *
 * Caution:
 * The original CCUCON0 setting has to be saved by user prior to entering Low Power mode.
 * Pass the original CCUCON0 register as a whole word to this function to restore the normal settings.
 *
 * Ramp back to normal mode is done in steps to avoid sudden jump in frequency and power usage.
 *
 * \param[in] ccucon0 The original CCUCON0 value saved from normal mode operation.
 *					  Range: 0x00000000 to 0xFFFF7FFF
 *
 * \retval None
 *
 * Switch to low power mode and back using iLLD functions as below
 * \code
 *     uint32 ccucon0 = SCU_CCUCON0.U;
 *     IfxScuCcu_LowPowerDivRatio lpDiv = IfxScuCcu_LowPowerDivRatio_divBy30;
 *     IfxScuCcu_switchToLowPowerMode(lpDiv);
 * \endcode
 *
 * Switch back to normal mode  with the saved ccucon0 value
 * \code
 *     IfxScuCcu_switchToNormalMode(ccucon0);
 * \endcode
 *
 */
IFX_INLINE void IfxScuCcu_switchToNormalMode(const uint32 ccucon0);

/** \} */

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Operative
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/
#if defined(DEVICE_TC33XED) || defined(DEVICE_TC39XB) || (DEVICE_TC35X)
/**
 * \brief Retrieves the frequency of the ADAS module.
 *
 * This function calculates the ADAS frequency (fADAS) in Hz based on the
 * divider value configured in the CCUCON register and the source frequency (fSOURCE).
 *
 * \retval ADAS frequency (fADAS) in Hz.
 */
IFX_INLINE float32 IfxScuCcu_getAdasFrequency(void);
#endif

/**
 * \brief Retrieves the frequency of the ADC module (EVADC, EDSADC).
 *
 * This function calculates the ADC frequency (fADC) in Hz based on the divider
 * value configured in the CCUCON register and the source frequency (fSOURCE).
 *
 * \retval float32 ADC frequency (fADC) in Hz.
 */
IFX_INLINE float32 IfxScuCcu_getAdcFrequency(void);

/**
 * \brief Retrieves the frequency of the ASCLINF module.
 *
 * This function calculates the ASCLINF frequency (fASCLINF) in Hz based on the divider
 * value configured in the CCUCON register and the source frequency (fSOURCE).
 *
 * \retval float32 ASCLINF frequency (fASCLINF) in Hz.
 */
IFX_INLINE float32 IfxScuCcu_getAsclinFFrequency(void);

#ifdef DEVICE_TC39XB
/**
 * \brief Retrieves the frequency of the External Bus Unit (EBU).
 *
 * This function returns the current operating frequency of the EBU (fEBU) in Hz based on the divider
 * value configured in the CCUCON register and the source frequency (fSOURCE).
 *
 * \retval float32 EBU frequency (fEBU) in Hz.
 */
IFX_INLINE float32 IfxScuCcu_getEbuFrequency(void);
#endif
/**
 * \brief Retrieves the EVR Oscillator frequency for the ScuCcu controller.
 *
 * This function returns the constant representing the EVR Oscillator frequency
 * (fBACK or fEVR) specific to the ScuCcu of the controller.
 *
 * \retval float32 EVR Oscillator frequency (fBACK or fEVR) in Hz.
 */
IFX_INLINE float32 IfxScuCcu_getEvrFrequency(void);

/**
 * \brief Retrieves the current frequency of the GETH clock unit.
 *
 * This function returns the current frequency of the GETH clock unit (fGETH) in Hz based on the divider
 * value configured in the CCUCON register and the source frequency (fSOURCE).
 *
 * \retval float32 GETH frequency (fGETH) in Hz.
 */
#ifndef DEVICE_TC33X
IFX_INLINE float32 IfxScuCcu_getGethFrequency(void);
#endif
/**
 * \brief Retrieves the current frequency of the GTM clock unit.
 *
 * This function returns the current frequency of the GTM clock unit (fGTM) in Hz
 * based on the divider value in CCUCON register and the source frequency (fSOURCE).
 *
 * \retval float32 GTM frequency (fGTM) in Hz.
 */
#ifndef DEVICE_TC35X
IFX_INLINE float32 IfxScuCcu_getGtmFrequency(void);
#endif
/**
 * \brief Retrieves the current frequency of the I2C.
 *
 * This function returns the current frequency of the I2C (fI2C) in Hz
 * based on the divider value in CCUCON register and the source frequency (fSOURCE).
 *
 * \retval float32 I2C frequency (fI2C) in Hz.
 */
#ifndef DEVICE_TC33X
IFX_INLINE float32 IfxScuCcu_getI2cFrequency(void);
#endif
/**
 * \brief Retrieves the current frequency of the MCANH.
 *
 * This function returns the current frequency of the MCANH (fMCANH) in Hz
 * based on the divider value in CCUCON register and the source frequency (fSOURCE).
 *
 * \retval float32 MCANH frequency (fMCANH) in Hz.
 */
IFX_INLINE float32 IfxScuCcu_getMcanhFrequency(void);

/**
 * \brief Retrieves the frequency of the Oscillator 0 (OSC0).
 *
 * This function returns the current frequency of the Oscillator 0 (fOSC0) in Hz
 * based on the divider value in CCUCON register and the source frequency (fSOURCE).
 *
 * \retval float32 OSC0 frequency (fOSC0) in Hz.
 */
IFX_INLINE float32 IfxScuCcu_getOsc0Frequency(void);

/**
 * \brief Retrieves the frequency of the Oscillator.
 *
 * This function returns the current frequency of the Oscillator (fOSC) in Hz
 * based on the divider value in CCUCON register and the source frequency (fSOURCE).
 *
 * \retval float32 OSC frequency (fOSC) in Hz.
 */
IFX_INLINE float32 IfxScuCcu_getOscFrequency(void);

/**
 * \brief Retrieves the current selection of the PLL input clock source.
 *
 * This function retrieves the current selection of the PLL input clock source.
 * The return value indicates which clock source is currently being used by the PLL.
 *
 * \retval IfxScuCcu_PllInputClockSelection The current PLL input clock SOURCE selection.
 *											(\ref IfxScuCcu_PllInputClockSelection)
 * 										    - IfxScuCcu_PllInputClockSelection_fOsc1: Backup clock select is selected
 * 											- IfxScuCcu_PllInputClockSelection_fOsc0: fOsc0 or XTAL clock is selected
 * 											- IfxScuCcu_PllInputClockSelection_fSysclk: fOsc1 clock is selected
 */
IFX_INLINE IfxScuCcu_PllInputClockSelection IfxScuCcu_getSourceSelection(void);

/**
 * \brief Retrieves the frequency of the STM.
 *
 * This function returns the current frequency of the STM (fSTM) in Hz
 * based on the divider value in CCUCON register and the source frequency (fSOURCE).
 *
 * \retval float32 STM frequency (fSTM) in Hz.
 */
IFX_INLINE float32 IfxScuCcu_getStmFrequency(void);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Retrieves the ASCLINS divider frequency.
 *
 * This function returns the current frequency of the ASCLINS (fASCLINS) in Hz
 * based on the divider value in CCUCON register and the source frequency (fSOURCE).
 *
 * \retval float32 ASCLINS frequency (fASCLINS) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_getAsclinSFrequency(void);

/**
 * \brief Retrieves the BBB divider frequency.
 *
 * This function returns the current frequency of the BBB (fBBB) in Hz
 * based on the divider value in CCUCON register and the source frequency (fSOURCE).
 *
 * \retval float32 BBB frequency (fBBB) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_getBbbFrequency(void);

/**
 * \brief This function calculates and returns the CPU frequency in Hz
 * 		  based on the divider value in the CCUCON register and the source frequency (fSOURCE).
 *
 * \param[in] cpu CPU number for which the effective frequency is calculated
 * 				  This is an enumeration representing the CPU resource.
 * 				  Range: \ref IfxCpu_ResourceCpu
 *
 * \retval float32 CPU[x] frequency in Hz, where x is the CPU number passed as the parameter.
 */
IFX_EXTERN float32 IfxScuCcu_getCpuFrequency(const IfxCpu_ResourceCpu cpu);

/**
 * \brief Retrieves the FSI2 divider frequency.
 *
 * This function calculates and returns the FSI2 frequency (fFSI2) in Hz
 * based on the divider value in CCUCON register and the input oscillator frequency.
 *
 * \retval float32 FSI2 frequency (fFSI2) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_getFsi2Frequency(void);

/**
 * \brief Retrieves the FSI divider frequency.
 *
 * This function calculates and returns the FSI frequency (fFSI) in Hz
 * based on the divider value in CCUCON register and the input oscillator frequency.
 *
 * \retval float32 FSI frequency (fFSI) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_getFsiFrequency(void);

/**
 * \brief Retrieves the MCAN divider frequency.
 *
 * This function calculates and returns the MCAN frequency (fMCAN) in Hz
 * based on the divider value in CCUCON register and the source frequency (fSOURCE).
 *
 * \retval float32 MCAN frequency (fMCAN) in Hz
 */
IFX_EXTERN float32 IfxScuCcu_getMcanFrequency(void);

/**
 * \brief Retrieves the MODULE divider frequency.
 *
 * This function calculates and returns the MODULE frequency (fMODULE) in Hz
 * based on the divider value in CCUCON register and the source frequency (fSOURCE).
 *
 * \retval float32 MODULE frequency (fMODULE) in Hz
 */
IFX_EXTERN float32 IfxScuCcu_getModuleFrequency(void);

#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X)
/**
 * \brief Retrieves the MSC divider frequency.
 *
 * This function calculates and returns the MSC frequency (fMSC) in Hz
 * based on the divider value in CCUCON register and the source frequency (fSOURCE).
 *
 * \retval float32 MSC frequency (fMSC) in Hz
 */
IFX_EXTERN float32 IfxScuCcu_getMscFrequency(void);
#endif

/**
 * \brief Retrieves the actual PER PLL1 frequency based on the K2 divider value and VCO frequency.
 *
 * This function calculates the PER PLL1 frequency in Hz using the formula:
 * Fpll1= (Fosc*N)/(P*K2)
 *
 * \retval float32 PER PLL1 (K2 Divider) frequency in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_getPerPllFrequency1(void);

/**
 * \brief Retrieves the actual PER PLL2 frequency based on the K3 divider value and VCO frequency.
 *
 * This function calculates and returns the PER PLL2 frequency in Hz
 * based on the K3 divider value in PLLCON and the VCO frequency.
 
 * The calculation uses one of two formulas depending on the DIVBY setting:
 * Fpll2= (Fosc*N)/(P*K3*1.6f)  // DIVBY = 0,
 * Fpll2= (Fosc*N)/(P*K3*2)     // DIVBY = 1
 *
 * \retval float32 PER PLL2 (K3 Divider) frequency in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_getPerPllFrequency2(void);

/**
 * \brief Retrieves the actual system PLL output frequency.
 *
 * This function calculates and returns the system PLL (fSysPLL) frequency in Hz
 * based on the divider values configured in the CCUCON and PLLCON registers, as well as the input oscillator frequency.
 *
 * \retval float32 System PLL (fSysPLL) frequency in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_getPllFrequency(void);

/**
 * \brief Retrieves the QSPI divider frequency.
 *
 * This function calculates and returns the QSPI frequency (fQSPI) in Hz,
 * based on the divider value in the CCUCON register and the source frequency (fSOURCE).
 *
 * \retval float32 QSPI frequency (fQSPI) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_getQspiFrequency(void);

/**
 * \brief Gets the SOURCE frequency (fSOURCE) in Hz, based on the selected clock source configuration.
 *
 * This function retrieves the effective source frequency (fSOURCE) in Hz for the specified clock source
 * The frequency is determined by the configuration set in the CCUCON register.
 *
 * \param[in] fsource The clock source selection.
 *                	  Range: \ref IfxScuCcu_Fsource
 *
 * \retval float32 effective SOURCE frequency (fSOURCE) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource fsource);

/**
 * \brief Retrieves the SPB divider frequency.
 *
 * This function calculates and returns the SPB frequency (fSPB) in Hz,
 * taking into account the source frequency (fSOURCE), the low power divider mode,
 * and the SPBDIV divider value from the CCUCON registers.
 *
 * \retval float32 SPB frequency (fSPB) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_getSpbFrequency(void);

/**
 * \brief Retrieves the SRI divider frequency.
 *
 * This function returns the current frequency of the SRI (fSRI) in Hz,
 * based on the divider value in CCUCON register and the source frequency (fSOURCE).
 *
 * \retval float32 SRI frequency (fSRI) in Hz
 */
IFX_EXTERN float32 IfxScuCcu_getSriFrequency(void);

#if defined(DEVICE_TC33XED) || defined(DEVICE_TC39XB) || defined(DEVICE_TC35X)
/**
 * \brief Sets the ADAS frequency using the ADAS divider configuration.
 *
 * This function configure ADAS divider values in CCUCON registers
 * to achieve the desired ADAS frequency. The actual frequency depends on the
 * feasibility of the divider value provided.
 *
 * \param[in] adasFreq Desired ADAS frequency (fADAS) in Hz.
 * 			  		   Range: Must be a positive value (adasFreq > 0).
 *
 * \retval float32 Actual ADAS frequency (fADAS) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_setAdasFrequency(float32 adasFreq);
#endif

/**
 * \brief Sets the ASCLINF frequency using the ASCLINF divider configuration.
 *
 * This function configures the ASCLINF divider values in the CCUCON registers
 * to achieve the desired ASCLINF frequency. The actual frequency depends on the
 * feasibility of the divider value provided.
 *
 * \param[in] asclinFFreq Desired AsclinF frequency (fASCLINF) in Hz.
 *                        Range: Must be a positive value (asclinFFreq > 0).
 *
 * \retval float32 Actual ASCLINF frequency (fASCLINF) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_setAsclinFFrequency(float32 asclinFFreq);

/**
 * \brief Sets the ASCLINS frequency using the ASCLINS divider configuration.
 *
 * This function configures the ASCLINS divider values in the CCUCON registers
 * to achieve the desired ASCLINS frequency. The actual frequency depends on the
 * feasibility of the divider value provided.
 *
 * \param[in] asclinSFreq Desired ASCLINS frequency (fASCLINS) in Hz.
 * 			              Range: Must be a positive value (asclinFFreq > 0).
 *
 * \retval float32 Actual ASCLINS frequency (fASCLINS) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_setAsclinSFrequency(float32 asclinSFreq);

/**
 * \brief Sets the BBB frequency using the BBB divider configuration.
 *
 * This function configures the BBB divider values in the CCUCON registers
 * to achieve the desired BBB frequency. The actual frequency depends on the
 * feasibility of the divider value provided.
 *
 * \param[in] bbbFreq Desired BBB frequency (fBBB) in Hz.
 * 					  Range: Must be a positive value (bbbFreq > 0).
 *
 * \retval float32 Actual BBB frequency (fBBB) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_setBbbFrequency(float32 bbbFreq);

/**
 * \brief Sets the CPU frequency by configuring the CPU divider values in CCUCON registers.
 *
 * This function adjusts the CPU divider to achieve the desired CPU frequency.
 * The actual frequency may vary based on the feasibility of the divider value.
 *
 * \param[in] cpu 	  The CPU instance to configure. Specifies which CPU's frequency is to be set.
 * 				      Range: \ref IfxCpu_ResourceCpu
 * \param[in] cpuFreq The desired CPU frequency in Hz. Must be a positive value within reasonable limits.
 * 					  Range: Must be a positive value (cpuFreq > 0).
 *
 * \retval float32 Actual CPU frequency achieved in Hz for the specified CPU instance.
 */
IFX_EXTERN float32 IfxScuCcu_setCpuFrequency(IfxCpu_ResourceCpu cpu, float32 cpuFreq);

/**
 * \brief Sets the FSI2 frequency using the FSI2 divider configuration.
 *
 * This function configures the FSI2 divider values in the CCUCON registers
 * to achieve the desired FSI2 frequency. The actual frequency depends on the
 * feasibility of the divider value provided.
 *
 * \param[in] fsi2Freq Desired FSI2 frequency (fFSI2) in Hz.
 * 			           Range: Must be a positive value (fsi2Freq > 0).
 *
 * \retval float32 Actual FSI2 frequency (fFSI2) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_setFsi2Frequency(float32 fsi2Freq);

/**
 * \brief Sets the FSI frequency using the FSI divider configuration.
 *
 * This function configures FSI divider values in CCUCON registers
 * to achieve the desired FSI frequency. The actual frequency depends on the
 * feasibility of the divider value provided.
 *
 * \param[in] fsiFreq Desired FSI frequency (fFSI) in Hz.
 * 					  Range: Must be a positive value (fsiFreq > 0).
 *
 * \retval float32 Actual FSI frequency (fFSI) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_setFsiFrequency(float32 fsiFreq);

#ifndef DEVICE_TC33X
/**
 * \brief Sets the GETH frequency using the GETH divider configuration.
 *
 * This function configures the GETH divider values in CCUCON registers
 * to achieve the desired GETH frequency. The actual frequency depends on the
 * feasibility of the divider value provided.
 *
 * \param[in] gethFreq Desired GETH frequency (fGETH) in Hz.
 * 				       Range: Must be a positive value (gethFreq > 0).
 *
 * \retval float32 Actual GETH frequency (fGETH) in Hz
 */
IFX_EXTERN float32 IfxScuCcu_setGethFrequency(float32 gethFreq);
#endif
#ifndef DEVICE_TC35X
/**
 * \brief Sets the GTM frequency using the GTM divider configuration.
 *
 * This function sets the GTM divider values in the CCUCON registers
 * to achieve the desired GTM frequency. The actual frequency depends on the
 * feasibility of the divider value provided.
 *
 * \param[in] gtmFreq Desired GTM frequency (fGTM) in Hz.
 * 			          Range: Must be a positive value (gtmFreq > 0).
 *
 * \retval float32 Actual GTM frequency (fGTM) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_setGtmFrequency(float32 gtmFreq);
#endif

#ifndef DEVICE_TC33X
/**
 * \brief Sets the I2C frequency using the I2C divider configuration.
 *
 * This function configure I2C divider values in CCUCON registers
 * to achieve the desired I2C frequency. The actual frequency depends on the
 * feasibility of the divider value provided.
 *
 * \param[in] i2cFreq Desired I2C frequency (fI2C) in Hz.
 * 					  Range: Must be a positive value (i2cFreq > 0).
 *
 * \retval float32 Actual I2C frequency (fI2C) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_setI2cFrequency(float32 i2cFreq);
#endif

/**
 * \brief Sets the MCAN frequency using the MCAN divider configuration.
 *
 * This function configures MCAN divider values in CCUCON registers
 * to achieve the desired MCAN frequency. The actual frequency depends on the
 * feasibility of the divider value provided.
 *
 * \param[in] mcanFreq Desired MCAN frequency (fMCAN) in Hz.
 * 					   Range: Must be a positive value (mcanFreq > 0).
 *
 * \retval float32 Actual MCAN frequency (fMCAN) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_setMcanFrequency(float32 mcanFreq);

/**
 * \brief Sets the MCANH frequency using the MCANH divider configuration.
 *
 * This function configures MCANH divider values in the CCUCON registers
 * to achieve the desired MCANH frequency. The actual frequency depends on the
 * feasibility of the divider value provided.
 *
 * \param[in] mcanhFreq Desired MCANH frequency (fMCANH) in Hz.
 * 						Range: Must be a positive value (mcanhFreq > 0).
 *
 * \retval float32 Actual MCANH frequency (fMCANH) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_setMcanhFrequency(float32 mcanhFreq);

#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)
/**
 * \brief Sets the MSC frequency using the MSC divider configuration.
 *
 * This function configures MSC divider values in CCUCON registers
 * to achieve the desired MSC frequency. The actual frequency depends on the
 * feasibility of the divider value provided.
 *
 * \param[in] mscFreq Desired MSC frequency (fMSC) in Hz.
 * 					  Range: Must be a positive value (mscFreq > 0).
 *
 * \retval float32 Actual MSC frequency (fMSC) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_setMscFrequency(float32 mscFreq);
#endif

/**
 * \brief Sets the QSPI frequency using the QSPI divider configuration.
 *
 * This function sets the QSPI divider values in the CCUCON registers
 * to achieve the desired QSPI frequency. The actual frequency depends on the
 * feasibility of the divider value provided.
 *
 * \param[in] qspiFreq Desired QSPI frequency (fQspi) in Hz.
 * 			           Range: Must be a positive value (qspiFreq > 0).
 *
 * \retval float32 Actual QSPI frequency (fQspi) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_setQspiFrequency(float32 qspiFreq);

/**
 * \brief Sets the SPB frequency using the SPB divider configuration.
 *
 * This function configures SPB divider values in CCUCON registers
 * to achieve the desired SPB frequency. The actual frequency depends on the
 * feasibility of the divider value provided.
 *
 * \param[in] spbFreq Desired SPB frequency (fSPB) in Hz.
 * 					  Range: Must be a positive value (spbFreq > 0).
 *
 * \retval float32 Actual SPB frequency (fSPB) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_setSpbFrequency(float32 spbFreq);

/**
 * \brief Sets the SRI frequency using the SRI divider configuration.
 *
 * This function configures SRI divider values in CCUCON registers
 * to achieve the desired SRI frequency. The actual frequency depends on the
 * feasibility of the divider value provided.
 *
 * \param[in] sriFreq Desired SRI frequency (fSRI) in Hz.
 * 					  Range: Must be a positive value (sriFreq > 0).
 *
 * \retval float32 Actual SRI frequency (fSRI) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_setSriFrequency(float32 sriFreq);

/**
 * \brief Sets the STM frequency using the STM divider configuration.
 *
 * This function configures the STM divider values in CCUCON registers
 * to achieve the desired STM frequency. The actual frequency depends on the
 * feasibility of the divider value provided.
 *
 * \param[in] stmFreq Desired STM frequency (fSTM) in Hz.
 *					  Range: Must be a positive value (stmFreq > 0).
 *
 * \retval float32 Actual STM frequency (fSTM) in Hz.
 */
IFX_EXTERN float32 IfxScuCcu_setStmFrequency(float32 stmFreq);

/** \} */

/** \addtogroup IfxLld_Scu_Std_Ccu_Ccu_Configuration
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Configures the initial step settings for the Ccu SYS and PER PLLs using the provided configuration.
 *
 * \param[in] pllInitStepCfg A pointer to the configuration structure containing PLL parameters and wait time
 *
 * \retval TRUE  Configuration was successful.
 * \retval FALSE Configuration failed.
 *
 * \Note The configuration structure includes parameters for both PLLs and a wait time for the initial step.
 */
IFX_INLINE boolean IfxScuCcu_configureCcuInitialStep(const IfxScuCcu_InitialStepConfig *pllInitStepCfg);

/**
 * \brief Inlined API for distributing clock signals by updating CCUCON registers based on the provided configuration.
 *
 * \param[in] clockDistributionConfig Pointer to the clock distribution configuration structure.
 *
 * \retval TRUE  Operation successful.
 * \retval FALSE Operation failed.
 */
IFX_INLINE boolean IfxScuCcu_distributeClockInline(const IfxScuCcu_ClockDistributionConfig *clockDistributionConfig);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Configures and distributes clock signals according to the provided configuration.
 *
 * This function sets up the clock distribution units based on the parameters specified in the \ref IfxScuCcu_ClockDistributionConfig structure,
 * which includes configurations for various CCUCON registers related to clock control.
 *
 * \param[in] clockDistributionConfig A pointer to the configuration structure that defines the settings for clock distribution.
 *
 * \retval None
 */
IFX_EXTERN void IfxScuCcu_distributeClock(IfxScuCcu_ClockDistributionConfig *clockDistributionConfig);

/**
 * \brief Initializes the SCU Clock Control Unit with the provided configuration.
 *
 * This function configures the System PLL (Sys PLL) with specified ramp steps, bus dividers, and per PLL settings.
 * It calculates the frequencies based on the following formulas:
 * FSyspll = (Fosc * Nsys)/(Psys * K2sys);
 * Fpll1= (Fosc * Nper)/(Pper * K2per);
 * Fpll2= (Fosc * Nper)/(Pper * K3per * 1.6f); // if DIVBY = 0, else Fpll2= (Fosc * Nper)/(Pper * K3per * 2) // if DIVBY = 1
 *
 * \note Following SMU alarms are disabled before the PLL configuration and Enabled at the end of PLL lock in the function.
 * PLL0,1,2 clock out of range frequency
 * PLL0,1 VCO loss of lock event
 * System PLL Oscillator Watchdog, input clock out of range
 * The application should store/restore these alarm configurations if required.
 *
 * \param[in] config Pointer to the configuration structure containing PLL initial steps, throttling settings, clock distribution,
 * 					 flash wait states, and modulation configurations.
 * 
 * \retval TRUE  An error occurred during initialization.
 * \retval FALSE Initialization was successful.
 *
 * \note The function disables SMU alarms related to PLL clock frequency, VCO loss of lock, and oscillator watchdog before configuration. These alarms are re-enabled upon successful PLL lock. Users should handle these alarms as needed.
 */
IFX_EXTERN boolean IfxScuCcu_init(const IfxScuCcu_Config *config);

/**
 * \brief Initializes the SCU CCU configuration structure with default values.
 *
 * This function sets up the provided configuration structure with default settings for the SCU CCU module,
 * including PLL initial step, PLL throttle, clock distribution, flash wait state, and modulation configurations.
 *
 * \param[inout] cfg Pointer to the configuration structure to be initialized.
 *
 * \retval None
 */
IFX_EXTERN void IfxScuCcu_initConfig(IfxScuCcu_Config *cfg);

/**
 * \brief Switches the system clock to the backup clock from the current PLL frequency.
 *
 * This function handles the transition from the current PLL-based clock source to the backup clock.
 * It uses the provided configuration to ensure a smooth transition and maintain system stability.
 *
 * \param[in] cfg Pointer to the configuration structure containing PLL, clock distribution, and other module settings.
 *
 * \retval None
 */
IFX_EXTERN void IfxScuCcu_switchToBackupClock(const IfxScuCcu_Config *cfg);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Clears the specified trap status flag.
 *
 * This function resets the trap status flag corresponding to the given trap request type.
 *
 * \param[in] request Trap request type.
 *      			  Range: \ref IfxScuCcu_Traprequest
 * \retval None
 */
IFX_INLINE void IfxScuCcu_clearTrapStatusFlag(IfxScuCcu_Traprequest request);

/**
 * \brief Get the trap disable flag for a specific trap request type on a given CPU.
 *
 * This function checks whether a trap request can be generated or not based on the current state of the system.
 *
 * \param[in] cpuIndex The index of the CPU to query.
 *                     Range: \ref IfxCpu_ResourceCpu
 * \param[in] request  The type of trap request to check.
 *                     Range: \ref IfxScuCcu_Traprequest
 *
 * \retval TRUE  The trap request can be generated.
 * \retval FALSE The trap request is disabled and cannot be generated.
 */
IFX_INLINE boolean IfxScuCcu_getTrapDisableFlag(IfxCpu_ResourceCpu cpuIndex, IfxScuCcu_Traprequest request);

/**
 * \brief Get the status of a specific trap request.
 *
 * This function checks whether a particular trap request is currently active.
 *
 * \param[in] request Trap request type to check.
 *                    Range: \ref IfxScuCcu_Traprequest
 *
 * \retval TRUE  The specified trap request is active.
 * \retval FALSE The specified trap request is not active.
 */
IFX_INLINE boolean IfxScuCcu_getTrapStatusFlag(IfxScuCcu_Traprequest request);

/**
 * \brief Sets the trap disable flag for a specific CPU and trap request type.
 *
 * This function configures the trap disable flag based on the provided CPU index and trap request type.
 *
 * \param[in] cpuIndex The CPU index for which the trap disable flag is to be set.
 *                     Range: \ref IfxCpu_ResourceCpu
 * \param[in] request  The type of trap request for which the disable flag is set.
 * 					   Range: \ref IfxScuCcu_Traprequest
 * \retval None
 */
IFX_INLINE void IfxScuCcu_setTrapDisableFlag(IfxCpu_ResourceCpu cpuIndex, IfxScuCcu_Traprequest request);

/**
 * \brief Sets the trap status flag for a specific trap request type.
 * 
 * This function updates the status of a trap based on the provided trap request type.
 * The trap request type is defined by the \ref IfxScuCcu_Traprequest enumeration.
 *
 * \param[in] request The trap request type to be used for setting the trap status flag.
 *                    Range: \ref IfxScuCcu_Traprequest
 *
 * \retval None
 */
IFX_INLINE void IfxScuCcu_setTrapStatusFlag(IfxScuCcu_Traprequest request);

/**
 * \brief Throttles the system PLL clock based on the provided configuration.
 *
 * This function configures and ramps up the system PLL (SYSPLL) clock using a series of K2 divider values
 * and wait periods specified in the pllThrottleConfig parameter. The function iterates through multiple
 * steps, adjusting the K2 divider and waiting for the specified time before applying the next step.
 *
 * \param[in] pllThrottleConfig Pointer to the PLL throttle configuration structure.
 *                              The structure contains the number of PLL divider steps and an array of
 *                              PLL step configurations to be applied during clock throttling.
 *
 * \retval TRUE  If the PLL clock throttling was successfully applied.
 * \retval FALSE If the PLL clock throttling failed.
 */
IFX_INLINE boolean IfxScuCcu_throttleSysPllClockInline(const IfxScuCcu_PllThrottleConfig *pllThrottleConfig);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Calculates the RGain parameters based on the provided modulation amplitude.
 *
 * This function computes the necessary RGain values for the specified modulation amplitude and stores the results in the provided RGain_P structure.
 *
 * \param[in] modamp     The modulation amplitude value.
 * 					     Range: \ref IfxScuCcu_ModulationAmplitude
 * \param[inout] RGain_P Pointer to the structure that holds the computed RGain parameters.
 *                       The structure contains the nominal and hexadecimal values of the RGain.
 *
 * \retval None
 */
IFX_EXTERN void IfxScuCcu_calRGainParameters(IfxScuCcu_ModulationAmplitude modamp, IfxScuCcu_RGain_Values *RGain_P);

/**
 * \brief Initializes the modulation parameters based on the provided configuration.
 *
 * This function sets up the modulation parameters for the SCU CCU module based on the provided configuration.
 * This function will check if modulation is enabled, Calculate RGain parameters based on modulation amplitude,
 * configure the modulation parameters (MODCFG) and enable modulation (MODEN).
 *
 * \param[in] Mod_Cfg Modulation configuration structure containing parameters such as enable state and amplitude.
 *
 * \retval None
 */
IFX_EXTERN void IfxScuCcu_modulation_init(const IfxScuCcu_Mod_Config *Mod_Cfg);

/**
 * \brief Throttles the system PLL clock according to the provided configuration.
 *
 * This function adjusts the system PLL clock speed based on the specified throttle configuration.
 * It uses the provided configuration to determine the number of steps and the specific step
 * configurations to apply during the clock throttling process.
 *
 * \param[in] pllThrottleConfig Pointer to the throttle configuration structure.
 *                              This structure contains the number of PLL divider steps
 *                              and an array of step configurations to be applied during throttling.
 *
 * \retval None
 */
IFX_EXTERN void IfxScuCcu_throttleSysPllClock(IfxScuCcu_PllThrottleConfig *pllThrottleConfig);

/**
 * \brief Configures the external clock output 0 based on the provided clock selection, frequency, and mode.
 *
 * This function enables and configures the external clock output 0 (EXTCLK0) by selecting the clock source,
 * setting the output frequency (if applicable), and specifying the operational mode of the clock output.
 *
 * \param[in] Clk_Sel The clock source selection for EXTCLK0.
 *                    Range: \ref IfxScuCcu_ClkSel0
 * \param[in] freqHz  The output frequency in Hz, used only when Clk_Sel is set to \ref IfxScuCcu_ClkSel0_fOUT.
 * \param[in] mode    The operational mode of the clock output.
 *                    Range: \ref IfxScuCcu_Clk0Mode
 *
 * \retval None
 */
IFX_EXTERN void IfxScuCcu_enableExtClockOut0(IfxScuCcu_ClkSel0 Clk_Sel, const uint32 freqHz, IfxScuCcu_Clk0Mode mode);

/**
 * \brief Configures the external clock output 1 based on the provided clock selection, frequency and clock line negation.
 *
 * This function enables and configures the external clock output 1 (EXTCLK1) by selecting the clock source,
 * setting the output frequency (if applicable), and specifying the clock line negation.
 *
 * \param[in] Clk_Sel The clock source selection for EXTCLK1.
 *                    Range: \ref IfxScuCcu_ClkSel1
 * \param[in] freqHz  The output frequency in Hz, used only when Clk_Sel is set to \ref IfxScuCcu_ClkSel1_fOUT.
 * \param[in] sel     The clock line negation selection.
 *                    Range: \ref IfxScuCcu_Clk1Negation
 *
 * \retval None
 */
IFX_EXTERN void IfxScuCcu_enableExtClockOut1(IfxScuCcu_ClkSel1 Clk_Sel, const uint32 freqHz, IfxScuCcu_Clk1Negation sel);

/******************************************************************************/
/*-------------------Global Exported Variables/Constants----------------------*/
/******************************************************************************/
/** \brief maps to the IfxScuCcu_ModulationAmplitude enum
 */
IFX_EXTERN IFX_CONST float32 IfxScuCcu_MA_percent[IfxScuCcu_ModulationAmplitude_count];

/** \brief Configuration structure for SCU CCU driver.
 * The values of this structure are defined as # defined macros in the implementation of Scu
 */
IFX_EXTERN IFX_CONST IfxScuCcu_Config     IfxScuCcu_defaultClockConfig;

/** \brief default modulation config
 */
IFX_EXTERN IFX_CONST IfxScuCcu_Mod_Config IfxScuCcu_defaultModConfig;

IFX_EXTERN uint32                         IfxScuCcu_xtalFrequency;

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuCcu_clearTrapStatusFlag(IfxScuCcu_Traprequest request)
{
    uint32 trapclear = 1;
    SCU_TRAPCLR.U |= (trapclear << request);
}


IFX_INLINE boolean IfxScuCcu_configureCcuInitialStep(const IfxScuCcu_InitialStepConfig *pllInitStepCfg)
{
    uint8                                initError = 0;
    uint16                               endinitSfty_pw;

    uint32                               timeoutCycleCount;
    const IfxScuCcu_pllsParameterConfig *pllsParamCfg;
    pllsParamCfg   = &pllInitStepCfg->pllsParameters;
    /*get the watch-dog passwords for usage with this function*/
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPasswordInline();

    /* Reset Safety ENDINIT, SCU_CCUCON registers are protected*/
    IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);

    timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;

    while (SCU_CCUCON0.B.LCK != 0U)
    {
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
    }

    {
        Ifx_SCU_CCUCON0 scuCcucon0;
        scuCcucon0.U        = SCU_CCUCON0.U;
        scuCcucon0.B.CLKSEL = 0; /*Select the EVR as fsource0/1/2 for the clock distribution */
        scuCcucon0.B.UP     = 1; /*Update the ccucon0 register */
        SCU_CCUCON0.U       = scuCcucon0.U;
    }

    timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;

    while (SCU_CCUCON0.B.LCK != 0U)
    {
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
    }

    /*Disable SMU Alarms */
    {
        SMU_KEYS.U    = (uint32)0xBCU;        /* Enable access to SMU registers */
        SMU_AG8CF0.U &= ~IFXSCUCCU_SMUALARM_MASK;
        SMU_AG8CF1.U &= ~IFXSCUCCU_SMUALARM_MASK;
        SMU_AG8CF2.U &= ~IFXSCUCCU_SMUALARM_MASK;
        SMU_KEYS.U    = (uint32)0U;
    }

    /* Power down the both the PLLs before configuring registers*/
    /* Both the PLLs are powered down to be sure for asynchronous PLL registers update cause no glitches */
    SCU_SYSPLLCON0.B.PLLPWD = 0;
    SCU_PERPLLCON0.B.PLLPWD = 0;

    timeoutCycleCount       = IFXSCUCCU_SYSPLLSTAT_PWDSTAT_TIMEOUT_COUNT;

    while ((SCU_SYSPLLSTAT.B.PWDSTAT == 0) || (SCU_PERPLLSTAT.B.PWDSTAT == 0))
    {
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
    }

    /* Now configure the oscillator, required oscillator mode is external crystal */

    if ((pllsParamCfg->pllInputClockSelection == IfxScuCcu_PllInputClockSelection_fOsc0) || (pllsParamCfg->pllInputClockSelection == IfxScuCcu_PllInputClockSelection_fSysclk))

    {
        Ifx_SCU_OSCCON scuOsccon;
        scuOsccon.U      = SCU_OSCCON.U;
#if (IFX_CFG_SCU_EXT_CLOCK == 1)
        scuOsccon.B.MODE = 2U;   /* external clock selected */
#else
        scuOsccon.B.MODE = 0U;
#endif

        scuOsccon.B.OSCVAL = (uint32)(pllsParamCfg->xtalFrequency / 1000000U) - 15; /*XTAL range 16MHz to 40MHz*/
        /*Note: Oscillator Watchdog Reset (OSCRES) is not required when the PLLs are powered down*/
        SCU_OSCCON.U       = scuOsccon.U;
    }

    /* Configure the initial steps for the system PLL*/
    {
        Ifx_SCU_SYSPLLCON0 sysPllCon0;
        sysPllCon0.U       = SCU_SYSPLLCON0.U;
        sysPllCon0.B.PDIV  = pllsParamCfg->sysPllConfig.pDivider;
        sysPllCon0.B.NDIV  = pllsParamCfg->sysPllConfig.nDivider;
        sysPllCon0.B.INSEL = pllsParamCfg->pllInputClockSelection;
        SCU_SYSPLLCON0.U   = sysPllCon0.U;
    }

    /* Configure the initial steps for the peripheral PLL*/
    {
        Ifx_SCU_PERPLLCON0 scuPerPllCon0;
        scuPerPllCon0.U       = SCU_PERPLLCON0.U;
        scuPerPllCon0.B.DIVBY = pllsParamCfg->perPllConfig.k3DividerBypass;
        scuPerPllCon0.B.PDIV  = pllsParamCfg->perPllConfig.pDivider;
        scuPerPllCon0.B.NDIV  = pllsParamCfg->perPllConfig.nDivider;
        SCU_PERPLLCON0.U      = scuPerPllCon0.U;
    }

    /* Power up the both the PLLs before configuring registers*/
    SCU_SYSPLLCON0.B.PLLPWD = 1;
    SCU_PERPLLCON0.B.PLLPWD = 1;

    timeoutCycleCount       = IFXSCUCCU_SYSPLLSTAT_PWDSTAT_TIMEOUT_COUNT;

    while ((SCU_SYSPLLSTAT.B.PWDSTAT == 1) || (SCU_PERPLLSTAT.B.PWDSTAT == 1))
    {
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
    }

    timeoutCycleCount = IFXSCUCCU_PLL_KRDY_TIMEOUT_COUNT;

    while ((SCU_SYSPLLSTAT.B.K2RDY == 0U) ||
           (SCU_PERPLLSTAT.B.K2RDY == 0U) ||
           (SCU_PERPLLSTAT.B.K3RDY == 0U))
    {
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
    }

    SCU_SYSPLLCON1.B.K2DIV = pllsParamCfg->sysPllConfig.k2Divider;
    {
        Ifx_SCU_PERPLLCON1 scuPerPllCon1;
        scuPerPllCon1.U       = SCU_PERPLLCON1.U;
        scuPerPllCon1.B.K2DIV = pllsParamCfg->perPllConfig.k2Divider;
        scuPerPllCon1.B.K3DIV = pllsParamCfg->perPllConfig.k3Divider;
        SCU_PERPLLCON1.U      = scuPerPllCon1.U;
    }

    timeoutCycleCount = IFXSCUCCU_PLL_KRDY_TIMEOUT_COUNT;

    while ((SCU_SYSPLLSTAT.B.K2RDY == 0U) ||
           (SCU_PERPLLSTAT.B.K2RDY == 0U) ||
           (SCU_PERPLLSTAT.B.K3RDY == 0U))
    {
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
    }

    /*Check if the OSC frequencies are in the limit*/
    timeoutCycleCount = IFXSCUCCU_OSCCON_PLLLV_OR_HV_TIMEOUT_COUNT;

    while ((SCU_OSCCON.B.PLLLV == 0) && (SCU_OSCCON.B.PLLHV == 0))
    {
        IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
    }

    /* Now start PLL locking for latest set values*/
    {
        SCU_SYSPLLCON0.B.RESLD = 1;             /* Restart Sys PLL lock detection */
        SCU_PERPLLCON0.B.RESLD = 1;             /* Restart Per PLL lock detection */

        timeoutCycleCount      = IFXSCUCCU_PLL_LOCK_TIMEOUT_COUNT;

        while ((SCU_SYSPLLSTAT.B.LOCK == 0) || (SCU_PERPLLSTAT.B.LOCK == 0))
        {
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }
    }
    /*Enable SMU Alarms */
    {
        SMU_KEYS.U = (uint32)0xBCU;           /* Enable access to SMU registers */
        SMU_CMD.U  = (uint32)0x00000005;
        SMU_AG8.U  = IFXSCUCCU_SMUALARM_MASK; /* Clear SMU Alarms*/
        SMU_KEYS.U = (uint32)0U;
    }
    {
        Ifx_SCU_CCUCON0 scu_ccucon0;
        scu_ccucon0.U        = SCU_CCUCON0.U;
        scu_ccucon0.B.CLKSEL = 1; /*Select the PLLs for fsource0/1/2 */
        scu_ccucon0.B.UP     = 1; /*Update the ccucon0 register */

        timeoutCycleCount    = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;

        while (SCU_CCUCON0.B.LCK != 0U)
        {
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        SCU_CCUCON0.U     = scu_ccucon0.U;

        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;

        while (SCU_CCUCON0.B.LCK != 0U)
        {
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }
    }

    IfxScuWdt_setSafetyEndinitInline(endinitSfty_pw);
    return (boolean)initError;
}


IFX_INLINE boolean IfxScuCcu_distributeClockInline(const IfxScuCcu_ClockDistributionConfig *clockDistributionConfig)
{
    uint16 endinitSfty_pw;
    uint32 timeoutCycleCount;
    uint32 initError = 0;

    /*get the watch-dog passwords for usage with this function*/
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPasswordInline();

    /* Reset Safety ENDINIT, SCU_CCUCON registers are protected*/
    IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);

    /*Configure the clock distribution */
    {                                                    /*Write CCUCON0 configuration */
        Ifx_SCU_CCUCON0 ccucon0;
        ccucon0.U         = SCU_CCUCON0.U & ~clockDistributionConfig->ccucon0.mask;
        /*update with configured value */
        ccucon0.U        |= (clockDistributionConfig->ccucon0.mask & clockDistributionConfig->ccucon0.value);
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;

        while (SCU_CCUCON0.B.LCK != 0U)
        {
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        SCU_CCUCON0.U     = ccucon0.U;      /*Set update bit explicitly to make above configurations effective */
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;

        while (SCU_CCUCON0.B.LCK != 0U)
        {
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }
    }
    {
        /*Write CCUCON1 configuration */
        Ifx_SCU_CCUCON1 ccucon1;
        ccucon1.U = SCU_CCUCON1.U;

        if (ccucon1.B.CLKSELMCAN
#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)
            || ccucon1.B.CLKSELMSC
#endif
            || ccucon1.B.CLKSELQSPI)
        {
            /* Non Zero ClockSel exists - set to Zero */
            /* CAUTION: this would briefly reset and set all clocks in CCUCON1! */
            ccucon1.U  = SCU_CCUCON1.U & ~clockDistributionConfig->ccucon1.mask;
            /*update with configured value */
            ccucon1.U |= (clockDistributionConfig->ccucon1.mask & clockDistributionConfig->ccucon1.value);

            /* set Clock selects to 0 */
            ccucon1.B.CLKSELMCAN = (uint32)0;
#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)
            ccucon1.B.CLKSELMSC  = (uint32)0;
#endif
            ccucon1.B.CLKSELQSPI = (uint32)0;

            timeoutCycleCount    = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;

            while (SCU_CCUCON1.B.LCK != 0U)
            {
                IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

            SCU_CCUCON1.U     = ccucon1.U;

            timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;

            while (SCU_CCUCON1.B.LCK != 0U)
            {
                IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }
        }

        ccucon1.U         = SCU_CCUCON1.U & ~clockDistributionConfig->ccucon1.mask;
        /*update with configured value */
        ccucon1.U        |= (clockDistributionConfig->ccucon1.mask & clockDistributionConfig->ccucon1.value);

        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;

        while (SCU_CCUCON1.B.LCK != 0U)
        {
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        SCU_CCUCON1.U     = ccucon1.U;

        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;

        while (SCU_CCUCON1.B.LCK != 0U)
        {
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }
    }

    {
        /*Write CCUCON2 configuration */
        Ifx_SCU_CCUCON2 ccucon2;
        ccucon2.U = SCU_CCUCON2.U;

        if (ccucon2.B.CLKSELASCLINS)
        {
            /* Non Zero ClockSel exists - set to Zero */
            /* CAUTION: this would briefly reset and set ASCLINS clock in CCUCON2! */
            ccucon2.U               = SCU_CCUCON2.U & ~clockDistributionConfig->ccucon2.mask;
            /*update with configured value */
            ccucon2.U              |= (clockDistributionConfig->ccucon2.mask & clockDistributionConfig->ccucon2.value);

            ccucon2.B.CLKSELASCLINS = (uint32)0;

            timeoutCycleCount       = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;

            while (SCU_CCUCON2.B.LCK != 0U)
            {
                IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

            SCU_CCUCON2.U     = ccucon2.U;

            timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;

            while (SCU_CCUCON2.B.LCK != 0U)
            {
                IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }
        }

        ccucon2.U         = SCU_CCUCON2.U & ~clockDistributionConfig->ccucon2.mask;
        /*update with configured value */
        ccucon2.U        |= (clockDistributionConfig->ccucon2.mask & clockDistributionConfig->ccucon2.value);

        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;

        while (SCU_CCUCON2.B.LCK != 0U)
        {
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        SCU_CCUCON2.U     = ccucon2.U;

        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;

        while (SCU_CCUCON2.B.LCK != 0U)
        {
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }
    }
    {
        /*Write CCUCON5 configuration */
        Ifx_SCU_CCUCON5 ccucon5;
        ccucon5.U         = SCU_CCUCON5.U & ~clockDistributionConfig->ccucon5.mask;
        /*update with configured value */
        ccucon5.U        |= (clockDistributionConfig->ccucon5.mask & clockDistributionConfig->ccucon5.value);
        ccucon5.B.UP      = 1;
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;

        while (SCU_CCUCON5.B.LCK != 0U)
        {
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        SCU_CCUCON5.U     = ccucon5.U;
        timeoutCycleCount = IFXSCUCCU_CCUCON_LCK_BIT_TIMEOUT_COUNT;

        while (SCU_CCUCON5.B.LCK != 0U)
        {
            IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }
    }
    {
        /*Write CCUCON6 configuration */
        Ifx_SCU_CCUCON6 ccucon6;
        ccucon6.U     = SCU_CCUCON6.U & ~clockDistributionConfig->ccucon6.mask;
        /*update with configured value */
        ccucon6.U    |= (clockDistributionConfig->ccucon6.mask & clockDistributionConfig->ccucon6.value);
        SCU_CCUCON6.U = ccucon6.U;
    }
#ifndef DEVICE_TC33X 
    {
        /*Write CCUCON7 configuration */
        Ifx_SCU_CCUCON7 ccucon7;
        ccucon7.U     = SCU_CCUCON7.U & ~clockDistributionConfig->ccucon7.mask;
        /*update with configured value */
        ccucon7.U    |= (clockDistributionConfig->ccucon7.mask & clockDistributionConfig->ccucon7.value);
        SCU_CCUCON7.U = ccucon7.U;
    }
#endif
#if defined(DEVICE_TC35X) || defined(DEVICE_TC37X) || defined(DEVICE_TC37XED) || defined(DEVICE_TC38EVOX) || defined(DEVICE_TC38X) || defined(DEVICE_TC39XB)
    {
        /*Write CCUCON8 configuration */
        Ifx_SCU_CCUCON8 ccucon8;
        ccucon8.U     = SCU_CCUCON8.U & ~clockDistributionConfig->ccucon8.mask;
        /*update with configured value */
        ccucon8.U    |= (clockDistributionConfig->ccucon8.mask & clockDistributionConfig->ccucon8.value);
        SCU_CCUCON8.U = ccucon8.U;
    }
#endif	
#if defined(DEVICE_TC38EVOX) || defined(DEVICE_TC38X) || defined(DEVICE_TC39XB)
    {
        /*Write CCUCON9 configuration */
        Ifx_SCU_CCUCON9 ccucon9;
        ccucon9.U     = SCU_CCUCON9.U & ~clockDistributionConfig->ccucon9.mask;
        /*update with configured value */
        ccucon9.U    |= (clockDistributionConfig->ccucon9.mask & clockDistributionConfig->ccucon9.value);
        SCU_CCUCON9.U = ccucon9.U;
    }
#endif
#ifdef DEVICE_TC39XB
    {
        /*Write CCUCON10 configuration */
        Ifx_SCU_CCUCON10 ccucon10;
        ccucon10.U     = SCU_CCUCON10.U & ~clockDistributionConfig->ccucon10.mask;
        /*update with configured value */
        ccucon10.U    |= (clockDistributionConfig->ccucon10.mask & clockDistributionConfig->ccucon10.value);
        SCU_CCUCON10.U = ccucon10.U;
    }
    {
        /*Write CCUCON11 configuration */
        Ifx_SCU_CCUCON11 ccucon11;
        ccucon11.U     = SCU_CCUCON11.U & ~clockDistributionConfig->ccucon11.mask;
        /*update with configured value */
        ccucon11.U    |= (clockDistributionConfig->ccucon11.mask & clockDistributionConfig->ccucon11.value);
        SCU_CCUCON11.U = ccucon11.U;
    }
#endif
    IfxScuWdt_setSafetyEndinitInline(endinitSfty_pw);
    return (boolean)initError;
}

#if defined(DEVICE_TC33XED) || defined(DEVICE_TC39XB) || defined(DEVICE_TC35X)
IFX_INLINE float32 IfxScuCcu_getAdasFrequency(void)
{
    uint32 adasDiv = SCU_CCUCON5.B.ADASDIV;

    return (adasDiv == (uint32)0) ? 0 : IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_0) / adasDiv;
}
#endif


IFX_INLINE float32 IfxScuCcu_getAdcFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_1);
}


IFX_INLINE float32 IfxScuCcu_getAsclinFFrequency(void)
{
    float32 freq          = 0;

    uint8   asclindiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};

    if (SCU_CCUCON2.B.ASCLINFDIV)
    {
        freq = IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_2) / asclindiv[SCU_CCUCON2.B.ASCLINFDIV];
    }

    return freq;
}

#ifdef DEVICE_TC39XB
IFX_INLINE float32 IfxScuCcu_getEbuFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_1);
}
#endif

IFX_INLINE float32 IfxScuCcu_getEvrFrequency(void)
{
    return IFXSCU_EVR_OSC_FREQUENCY;
}

#ifndef DEVICE_TC33X
IFX_INLINE float32 IfxScuCcu_getGethFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_0) / SCU_CCUCON5.B.GETHDIV;
}
#endif

#ifndef DEVICE_TC35X
IFX_INLINE float32 IfxScuCcu_getGtmFrequency(void)
{
    /* fGTM = fSOURCEGTM / GTMDIV ;
     * fSOURCEGTM = fSPB *2
     */
    uint8   gtmDiv  = SCU_CCUCON0.B.GTMDIV;
    float32 gtmFreq = 0;

    if (gtmDiv == 0u)
    {
        gtmFreq = 0.0f;
    }
    else if (gtmDiv == 1U)
    {
        gtmFreq = IfxScuCcu_getSpbFrequency() * 2;
    }
    else

    {
        gtmFreq = IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_0) / gtmDiv;
    }

    return gtmFreq;
}
#endif

#ifndef DEVICE_TC33X
IFX_INLINE float32 IfxScuCcu_getI2cFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_2) / SCU_CCUCON1.B.I2CDIV;
}
#endif

IFX_INLINE float32 IfxScuCcu_getMcanhFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_0) / SCU_CCUCON5.B.MCANHDIV;
}


IFX_INLINE float32 IfxScuCcu_getOsc0Frequency(void)
{
    return (float32)IFX_CFG_SCU_XTAL_FREQUENCY;
}


IFX_INLINE float32 IfxScuCcu_getOscFrequency(void)
{
    float32 freq;

    if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc1)
    {
        freq = IFXSCU_EVR_OSC_FREQUENCY;
    }
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fOsc0)
    {
        freq = (float32)IFX_CFG_SCU_XTAL_FREQUENCY;
    }
    else if (SCU_SYSPLLCON0.B.INSEL == IfxScuCcu_PllInputClockSelection_fSysclk)
    {
        freq = IFX_CFG_SCU_SYSCLK_FREQUENCY;
    }
    else
    {
        /* Reserved values, this */
        freq = 0.0f;
    }

    return freq;
}


IFX_INLINE IfxScuCcu_PllInputClockSelection IfxScuCcu_getSourceSelection(void)
{
    return (IfxScuCcu_PllInputClockSelection)SCU_CCUCON0.B.CLKSEL;
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency(IfxScuCcu_Fsource_0) / SCU_CCUCON0.B.STMDIV;
}


IFX_INLINE boolean IfxScuCcu_getTrapDisableFlag(IfxCpu_ResourceCpu cpuIndex, IfxScuCcu_Traprequest request)
{
    boolean trapdisable = 0;

 #if IFXCPU_NUM_MODULES > 5

    if (cpuIndex < IfxCpu_ResourceCpu_4)
    {
        trapdisable = ((SCU_TRAPDIS0.U >> ((cpuIndex << 3) + request)) & 0x1);
    }
    else
    {
        cpuIndex    = (IfxCpu_ResourceCpu)(cpuIndex - IfxCpu_ResourceCpu_4);

        trapdisable = ((SCU_TRAPDIS1.U >> ((cpuIndex << 3) + request)) & 0x1);
    }
#else
    trapdisable = ((SCU_TRAPDIS0.U >> ((cpuIndex << 3) + request)) & 0x1);
#endif

    return trapdisable;
}


IFX_INLINE boolean IfxScuCcu_getTrapStatusFlag(IfxScuCcu_Traprequest request)
{
    boolean trapstatus = 0;

    trapstatus = (((SCU_TRAPSTAT.U) >> request) & (0x1));

    return trapstatus;
}


IFX_INLINE void IfxScuCcu_setTrapDisableFlag(IfxCpu_ResourceCpu cpuIndex, IfxScuCcu_Traprequest request)
{
    uint32 trapdis = 1;
#if IFXCPU_NUM_MODULES > 5
    if (cpuIndex < IfxCpu_ResourceCpu_4)
    {
        trapdis         = (trapdis << (cpuIndex << 3));
        SCU_TRAPDIS0.U |= (trapdis << request);
    }
    else
    {
        cpuIndex        = (IfxCpu_ResourceCpu)(cpuIndex - IfxCpu_ResourceCpu_4);
        trapdis         = (trapdis << (cpuIndex << 3));
        SCU_TRAPDIS1.U |= (trapdis << request);
    }
#else
    trapdis         = (trapdis << (cpuIndex << 3));
    SCU_TRAPDIS0.U |= (trapdis << request);
#endif
}


IFX_INLINE void IfxScuCcu_setTrapStatusFlag(IfxScuCcu_Traprequest request)
{
    uint32 trapset = 1;
    SCU_TRAPSET.U |= (trapset << request);
}


IFX_INLINE boolean IfxScuCcu_throttleSysPllClockInline(const IfxScuCcu_PllThrottleConfig *pllThrottleConfig)
{
    uint8  initError = 0;
    uint8  pllStepsCount;
    uint16 endinitSfty_pw;
    uint32 timeoutCycleCount;

    /*get the watch-dog passwords for usage with this function*/
    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPasswordInline();

    /*Start Pll ramp up sequence */
    for (pllStepsCount = 0; pllStepsCount < pllThrottleConfig->numOfSteps; pllStepsCount++)
    {                       /*iterate through number of pll steps */
        {
            IfxScuWdt_clearSafetyEndinitInline(endinitSfty_pw);

            /*Configure K2 divider */
            timeoutCycleCount = IFXSCUCCU_PLL_KRDY_TIMEOUT_COUNT;

            while (SCU_SYSPLLSTAT.B.K2RDY == 0U)
            {
                IFXSCUCCU_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

            /*Now set the K2 divider value for the step corresponding to step count */
            SCU_SYSPLLCON1.B.K2DIV = pllThrottleConfig->pllSteps[pllStepsCount].k2Step;
            IfxScuWdt_setSafetyEndinitInline(endinitSfty_pw);
        }

        /*Wait for waitCounter corresponding to the pll step */
        IfxScuCcu_wait(pllThrottleConfig->pllSteps[pllStepsCount].waitTime);
    }

    return (boolean)initError;
}


IFX_INLINE void IfxScuCcu_wait(float32 timeSec)
{
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
    uint32 stmCountBegin = STM0_TIM0.U;

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
    {
        /* There is no need to check overflow of the STM timer.
         * When counter after overflow subtracted with counter before overflow,
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}


IFX_INLINE void IfxScuCcu_waitWithWdtService(float32 timeSec)
{
    uint32 stmCount          = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
    uint32 stmCountBegin     = STM0_TIM0.U;
    uint16 cpuWdtPassword    = IfxScuWdt_getCpuWatchdogPassword();
    uint16 safetyWdtPassword = IfxScuWdt_getSafetyWatchdogPassword();

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
    {
        /* There is no need to check overflow of the STM timer.
         * When counter after overflow subtracted with counter before overflow,
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
        IfxScuWdt_serviceCpuWatchdog(cpuWdtPassword);
        IfxScuWdt_serviceSafetyWatchdog(safetyWdtPassword);
    }
}


IFX_INLINE void IfxScuCcu_switchToLowPowerMode(IfxScuCcu_LowPowerDivRatio lpDiv)
{
    uint16 endinitSfty_pw;

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    /* clear safety ENDINIT prior to write to SCU_CCUCON0 */
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

    /* wait for unlock status - safety watchdog ensures timeout */
    while (SCU_CCUCON0.B.LCK != 0U)
    {} /*Wait till ccucon0 lock is set, No "timeout" required, ENDINIT watch-dog is active! */

    Ifx_SCU_CCUCON0 scu_ccucon0;
    scu_ccucon0.U       = SCU_CCUCON0.U;  /* read ccucon0*/
    scu_ccucon0.B.LPDIV = lpDiv;                /* write Div ratio to LPDIV */
    scu_ccucon0.B.UP    = 1;                    /*Update the ccucon0 register */
    SCU_CCUCON0.U       = scu_ccucon0.U;        /* write back */

    IfxScuWdt_setSafetyEndinit(endinitSfty_pw); /* set Safety ENDINIT */
}


IFX_INLINE void IfxScuCcu_switchToNormalMode(const uint32 ccucon0)
{
    uint16 endinitSfty_pw;

    endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    /* clear safety ENDINIT prior to write to SCU_CCUCON0 */
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

    /* wait for unlock status - safety watchdog ensures timeout */
    while (SCU_CCUCON0.B.LCK != 0U)
    {} /*Wait till ccucon0 lock is set, No "timeout" required, ENDINIT watch-dog is active! */

    /* Intermediate step : SPBDIV = 12 and SRIDIV = 3
     *  NOTE: This intermediate step in division ratio is done to avoid a sudden jump in clock frequency
     *  while jumping back from Low Power to Normal mode. The division ratios used in this step is hard
     *  coded into this function after proving on HW.
     */
    Ifx_SCU_CCUCON0 scu_ccucon0;
    scu_ccucon0.U        = SCU_CCUCON0.U;          /* read ccucon0*/
    scu_ccucon0.B.SRIDIV = 3;                      /* SRIDIV = 1:3*/
    scu_ccucon0.B.SPBDIV = 12;                     /* SPBDIV = 1:12 */
    scu_ccucon0.B.LPDIV  = 0;                      /* Exit Low Power Mode */
    scu_ccucon0.B.UP     = 1;
    SCU_CCUCON0.U        = scu_ccucon0.U;          /* write back */
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw);    /* set Safety ENDINIT */

    /* wait  */
    IfxScuCcu_wait(IFXSCUCCU_LPTONORMAL_WAITTIME); /* wait */

    /* Now back to original settings for normal mode */
    /* clear safety ENDINIT prior to write to SCU_CCUCON0 */
    IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

    /* wait for unlock status - safety watchdog ensures timeout */
    while (SCU_CCUCON0.B.LCK != 0U)
    {} /*Wait till ccucon0 lock is set, No "timeout" required, ENDINIT watch-dog is active! */

    scu_ccucon0.U    = SCU_CCUCON0.U;     /* read ccucon0*/
    scu_ccucon0.U    = ccucon0;      /* original setting */
    scu_ccucon0.B.UP = 1;                       /* update */
    SCU_CCUCON0.U    = scu_ccucon0.U;           /* write back */
    IfxScuWdt_setSafetyEndinit(endinitSfty_pw); /* set Safety ENDINIT */
}


#endif /* IFXSCUCCU_H */
