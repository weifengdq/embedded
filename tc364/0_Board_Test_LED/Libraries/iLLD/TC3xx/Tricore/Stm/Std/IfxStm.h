/**
 * \file IfxStm.h
 * \brief STM  basic functionality
 * \ingroup IfxLld_Stm
 *
 * \version iLLD_1_20_0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Stm_Usage How to use the Stm driver?
 * \ingroup IfxLld_Stm
 *
 * The Stm Standard driver provides APIs to initialize, configure and control the Stm.
 *
 * In the following sections it will be described, how to integrate the driver into the application framework.
 *
 * \section IfxLld_Stm_Preparation Preparation
 * \subsection IfxLld_Stm_Include Include Files
 *
 * Include following header file into your C code:
 * \code
 * #include <Stm/Std/IfxStm.h>
 * \endcode
 *
 * \subsection IfxLld_Stm_Variables Variables
 *
 * Declare STM variables :
 * \code
 * Ifx_STM *stmSfr;
 * IfxStm_CompareConfig stmConfig;
 * \endcode
 *
 * \subsection IfxLld_Stm_Interrupt Interrupt Handler Installation
 *
 * See also \ref IfxLld_Cpu_Irq_Usage
 *
 * Define priorities for the Interrrupt handlers. This is normally done in the Ifx_IntPrioDef.h file:
 * \code
 * // priorities are normally defined in Ifx_IntPrioDef.h
 * #define IFX_INTPRIO_STM0_SR0  10
 * \endcode
 *
 * Add the interrupt service routines to your C code. They have to call the Stm interrupt handlers:
 * please take care in choosing number of ticks, the below example code will raise an interrupt
 * evry time the specified number of ticks have been elapsed.
 * \code
 * IFX_INTERRUPT(stm0Sr0ISR, 0, IFX_INTPRIO_STM0_SR0)
 * {
 *     IfxStm_clearCompareFlag(stmSfr, stmConfig.comparator);
 *     IfxStm_increaseCompare(stmSfr, stmConfig.comparator, stmConfig.ticks);
 * }
 * \endcode
 *
 * Finally install the interrupt handlers in your initialisation function:
 * \code
 *     // install interrupt handlers
 *     IfxCpu_Irq_installInterruptHandler(&stm0Sr0ISR, IFX_INTPRIO_STM0_SR0);
 *     IfxCpu_enableInterrupts();
 * \endcode
 *
 * \subsection IfxLld_Stm_Init Module Initialisation
 *
 * The STM module can be configured to generate an interrupt at every compare match of the selected comaparator with the desired compare value, the interrupt can further be routed to other comparator.
 *
 * The module initialisation can be done as followed.
 *
 * \code
 *     stmSfr = &MODULE_STM0;
 *
 *     IfxStm_initCompareConfig(&stmConfig);
 *
 *     // configure to generate interrupt every 10 us
 *     sint32 ticks = IfxStm_getTicksFromMicroseconds(10);
 *
 *     stmConfig.ticks = ticks;
 *
 *     stmConfig.triggerPriority = IFX_INTPRIO_STM0_SR0;
 *     stmConfig.typeOfService = IfxSrc_Tos_cpu0;
 *
 *     IfxStm_initCompare(stmSfr, &stmConfig);
 *
 * \endcode
 *
 * Now the Stm shall generate interrupts regularly based on the configured time !
 *
 * \defgroup IfxLld_Stm_Std_Enumerations Enumerations
 * \ingroup IfxLld_Stm_Std
 * \defgroup IfxLld_Stm_Std_Structures Data Structures
 * \ingroup IfxLld_Stm_Std
 * \defgroup IfxLld_Stm_Std_Module Module Functions
 * \ingroup IfxLld_Stm_Std
 * \defgroup IfxLld_Stm_Std_Timer Timer Functions
 * \ingroup IfxLld_Stm_Std
 * \defgroup IfxLld_Stm_Std_Comparator Comparator Functions
 * \ingroup IfxLld_Stm_Std
 */

#ifndef IFXSTM_H
#define IFXSTM_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxStm_cfg.h"
#include "Scu/Std/IfxScuCcu.h"
#include "Src/Std/IfxSrc.h"
#include "IfxCbs_reg.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

#ifndef IFXSTM_DEFAULT_TIMER
#define IFXSTM_DEFAULT_TIMER (&MODULE_STM0)
#endif

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Stm_Std_Enumerations
 * \{ */
/** \brief Comparator Id defined in   MODULE_STMx.ISCR.B.CMP0IRR(x = 0, 1, 2)
 */
typedef enum
{
    IfxStm_Comparator_0 = 0,      /**< \brief Comparator Id 0  */
    IfxStm_Comparator_1           /**< \brief Comparator Id 1  */
} IfxStm_Comparator;

/** \brief Comparator Interrupt request source defined in MODULE_SRC.STM.STM[index].SRx (x =0, 1)
 */
typedef enum
{
    IfxStm_ComparatorInterrupt_ir0 = 0,  /**< \brief Select STMIR0 */
    IfxStm_ComparatorInterrupt_ir1 = 1   /**< \brief Select STMIR1 */
} IfxStm_ComparatorInterrupt;

/** \brief Comparator start bit position  defined in MODULE_STMx.CMCON.B.MSTART0(x = 0,1,2)
 */
typedef enum
{
    IfxStm_ComparatorOffset_0 = 0,      /**< \brief Comparator start bit position 0 with 64 bit timer  */
    IfxStm_ComparatorOffset_1,          /**< \brief Comparator start bit position 1 with 64 bit timer  */
    IfxStm_ComparatorOffset_2,          /**< \brief Comparator start bit position 2 with 64 bit timer  */
    IfxStm_ComparatorOffset_3,          /**< \brief Comparator start bit position 3 with 64 bit timer  */
    IfxStm_ComparatorOffset_4,          /**< \brief Comparator start bit position 4 with 64 bit timer  */
    IfxStm_ComparatorOffset_5,          /**< \brief Comparator start bit position 5 with 64 bit timer  */
    IfxStm_ComparatorOffset_6,          /**< \brief Comparator start bit position 6 with 64 bit timer  */
    IfxStm_ComparatorOffset_7,          /**< \brief Comparator start bit position 7 with 64 bit timer  */
    IfxStm_ComparatorOffset_8,          /**< \brief Comparator start bit position 8 with 64 bit timer  */
    IfxStm_ComparatorOffset_9,          /**< \brief Comparator start bit position 9 with 64 bit timer  */
    IfxStm_ComparatorOffset_10,         /**< \brief Comparator start bit position 10 with 64 bit timer  */
    IfxStm_ComparatorOffset_11,         /**< \brief Comparator start bit position 11 with 64 bit timer  */
    IfxStm_ComparatorOffset_12,         /**< \brief Comparator start bit position 12 with 64 bit timer  */
    IfxStm_ComparatorOffset_13,         /**< \brief Comparator start bit position 13 with 64 bit timer  */
    IfxStm_ComparatorOffset_14,         /**< \brief Comparator start bit position 14 with 64 bit timer  */
    IfxStm_ComparatorOffset_15,         /**< \brief Comparator start bit position 15 with 64 bit timer  */
    IfxStm_ComparatorOffset_16,         /**< \brief Comparator start bit position 16 with 64 bit timer  */
    IfxStm_ComparatorOffset_17,         /**< \brief Comparator start bit position 17 with 64 bit timer  */
    IfxStm_ComparatorOffset_18,         /**< \brief Comparator start bit position 18 with 64 bit timer  */
    IfxStm_ComparatorOffset_19,         /**< \brief Comparator start bit position 19 with 64 bit timer  */
    IfxStm_ComparatorOffset_20,         /**< \brief Comparator start bit position 20 with 64 bit timer  */
    IfxStm_ComparatorOffset_21,         /**< \brief Comparator start bit position 21 with 64 bit timer  */
    IfxStm_ComparatorOffset_22,         /**< \brief Comparator start bit position 22 with 64 bit timer  */
    IfxStm_ComparatorOffset_23,         /**< \brief Comparator start bit position 23 with 64 bit timer  */
    IfxStm_ComparatorOffset_24,         /**< \brief Comparator start bit position 24 with 64 bit timer  */
    IfxStm_ComparatorOffset_25,         /**< \brief Comparator start bit position 25 with 64 bit timer  */
    IfxStm_ComparatorOffset_26,         /**< \brief Comparator start bit position 26 with 64 bit timer  */
    IfxStm_ComparatorOffset_27,         /**< \brief Comparator start bit position 27 with 64 bit timer  */
    IfxStm_ComparatorOffset_28,         /**< \brief Comparator start bit position 28 with 64 bit timer  */
    IfxStm_ComparatorOffset_29,         /**< \brief Comparator start bit position 29 with 64 bit timer  */
    IfxStm_ComparatorOffset_30,         /**< \brief Comparator start bit position 30 with 64 bit timer  */
    IfxStm_ComparatorOffset_31          /**< \brief Comparator start bit position 31 with 64 bit timer  */
} IfxStm_ComparatorOffset;

/** \brief Size of compare value to compare with timer defined in  MODULE_STMx.CMCON.B.MSIZE0(x = 0,1,2)
 */
typedef enum
{
    IfxStm_ComparatorSize_1Bit   = 0,   /**< \brief Size of compare value to compare with timer: 1 bit */
    IfxStm_ComparatorSize_2Bits  = 1,   /**< \brief Size of compare value to compare with timer: 2 bits */
    IfxStm_ComparatorSize_3Bits  = 2,   /**< \brief Size of compare value to compare with timer: 3 bits */
    IfxStm_ComparatorSize_4Bits  = 3,   /**< \brief Size of compare value to compare with timer: 4 bits */
    IfxStm_ComparatorSize_5Bits  = 4,   /**< \brief Size of compare value to compare with timer: 5 bits */
    IfxStm_ComparatorSize_6Bits  = 5,   /**< \brief Size of compare value to compare with timer: 6 bits */
    IfxStm_ComparatorSize_7Bits  = 6,   /**< \brief Size of compare value to compare with timer: 7 bits */
    IfxStm_ComparatorSize_8Bits  = 7,   /**< \brief Size of compare value to compare with timer: 8 bits */
    IfxStm_ComparatorSize_9Bits  = 8,   /**< \brief Size of compare value to compare with timer: 9 bits */
    IfxStm_ComparatorSize_10Bits = 9,   /**< \brief Size of compare value to compare with timer: 10 bits */
    IfxStm_ComparatorSize_11Bits = 10,  /**< \brief Size of compare value to compare with timer: 11 bits */
    IfxStm_ComparatorSize_12Bits = 11,  /**< \brief Size of compare value to compare with timer: 12 bits */
    IfxStm_ComparatorSize_13Bits = 12,  /**< \brief Size of compare value to compare with timer: 13 bits */
    IfxStm_ComparatorSize_14Bits = 13,  /**< \brief Size of compare value to compare with timer: 14 bits */
    IfxStm_ComparatorSize_15Bits = 14,  /**< \brief Size of compare value to compare with timer: 15 bits */
    IfxStm_ComparatorSize_16Bits = 15,  /**< \brief Size of compare value to compare with timer: 16 bits */
    IfxStm_ComparatorSize_17Bits = 16,  /**< \brief Size of compare value to compare with timer: 17 bits */
    IfxStm_ComparatorSize_18Bits = 17,  /**< \brief Size of compare value to compare with timer: 18 bits */
    IfxStm_ComparatorSize_19Bits = 18,  /**< \brief Size of compare value to compare with timer: 19 bits */
    IfxStm_ComparatorSize_20Bits = 19,  /**< \brief Size of compare value to compare with timer: 20 bits */
    IfxStm_ComparatorSize_21Bits = 20,  /**< \brief Size of compare value to compare with timer: 21 bits */
    IfxStm_ComparatorSize_22Bits = 21,  /**< \brief Size of compare value to compare with timer: 22 bits */
    IfxStm_ComparatorSize_23Bits = 22,  /**< \brief Size of compare value to compare with timer: 23 bits */
    IfxStm_ComparatorSize_24Bits = 23,  /**< \brief Size of compare value to compare with timer: 24 bits */
    IfxStm_ComparatorSize_25Bits = 24,  /**< \brief Size of compare value to compare with timer: 25 bits */
    IfxStm_ComparatorSize_26Bits = 25,  /**< \brief Size of compare value to compare with timer: 26 bits */
    IfxStm_ComparatorSize_27Bits = 26,  /**< \brief Size of compare value to compare with timer: 27 bits */
    IfxStm_ComparatorSize_28Bits = 27,  /**< \brief Size of compare value to compare with timer: 28 bits */
    IfxStm_ComparatorSize_29Bits = 28,  /**< \brief Size of compare value to compare with timer: 29 bits */
    IfxStm_ComparatorSize_30Bits = 29,  /**< \brief Size of compare value to compare with timer: 30 bits */
    IfxStm_ComparatorSize_31Bits = 30,  /**< \brief Size of compare value to compare with timer: 31 bits */
    IfxStm_ComparatorSize_32Bits = 31   /**< \brief Size of compare value to compare with timer: 32 bits */
} IfxStm_ComparatorSize;

/** \brief Enable/disable the sensitivity of the module to sleep signal\n
 * Definition in Ifx_STM.CLC.B.EDIS
 */
typedef enum
{
    IfxStm_SleepMode_enable  = 0, /**< \brief enables sleep mode */
    IfxStm_SleepMode_disable = 1  /**< \brief disables sleep mode */
} IfxStm_SleepMode;

/** \brief OCDS Suspend Control (OCDS.SUS)
 */
typedef enum
{
    IfxStm_SuspendMode_none = 0,  /**< \brief No suspend */
    IfxStm_SuspendMode_hard = 1,  /**< \brief Hard Suspend */
    IfxStm_SuspendMode_soft = 2   /**< \brief Soft Suspend */
} IfxStm_SuspendMode;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Stm_Std_Structures
 * \{ */
/** \brief Comparator Configuration Structure
 */
typedef struct
{
    IfxStm_Comparator          comparator;                /**< \brief Comparator Id defined in   MODULE_STMx.ISCR.B.CMP0IRR(x = 0, 1, 2). */
    IfxStm_ComparatorInterrupt comparatorInterrupt;       /**< \brief Comparator Interrupt request source defined in MODULE_SRC.STM.STM[index].SRx (x =0, 1). */
    IfxStm_ComparatorOffset    compareOffset;             /**< \brief Comparator start bit position  defined in MODULE_STMx.CMCON.B.MSTART0(x = 0,1,2). */
    IfxStm_ComparatorSize      compareSize;               /**< \brief Size of compare value to compare with timer defined in  MODULE_STMx.CMCON.B.MSIZE0(x = 0,1,2). */
    uint32                     ticks;                     /**< \brief count for next comparison from current timer count. */
    Ifx_Priority               triggerPriority;           /**< \brief Interrupt priority. Range = 0 .. 255. 0 = interrupt is disabled. */
    IfxSrc_Tos                 typeOfService;             /**< \brief Type of service. */
} IfxStm_CompareConfig;

/** \} */

/** \addtogroup IfxLld_Stm_Std_Module
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Returns the current system timer value by combining two 32-bit components from the Ifx_STM structure.
 *
 * \param[in] stm Pointer to the STM module registers.
 *
 * \retval The 64-bit system timer value where the lower 32 bits are from TIM0.U and the upper 32 bits are from CAP.U.
 *         Range: 0 to 0xFFFFFFFFFFFFFFFF
 */
IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm);

/** \brief Retrieves the frequency of the STM (System Timer Module) in Hz.
 *
 * \param[in] stm Pointer to the STM module registers.
 *
 * \retval float32 The frequency of the STM in Hz.
 */
IFX_INLINE float32 IfxStm_getFrequency(Ifx_STM *stm);

/** \brief Returns the module's suspend state.
 *
 * \param[in] stm Pointer to the STM module registers.
 *
 * \retval Suspend status.
 *         Range: `TRUE` (module is suspended) or `FALSE` (module is not suspended).
 */
IFX_INLINE boolean IfxStm_isModuleSuspended(Ifx_STM *stm);

/** \brief Configures the STM module to hard or soft suspend mode.
 * Note: The api works only when the OCDS is enabled and in Supervisor Mode. When OCDS is disabled the OCS suspend control is ineffective.
 *
 * \param[inout] stm  Pointer to the STM module registers.
 * \param[in] mode The suspend mode to set.
 *                 Range: \ref IfxStm_SuspendMode
 *
 * \retval None
 */
IFX_INLINE void IfxStm_setSuspendMode(Ifx_STM *stm, IfxStm_SuspendMode mode);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Disables the specified STM module.
 *
 * \param[inout] stm Pointer to the STM module registers.
 *
 * \retval None
 */
IFX_EXTERN void IfxStm_disableModule(Ifx_STM *stm);

/** \brief Enables the suspension of On-Chip Debug (OCD) for the specified STM instance.
 * Note: The API will write into the OCS register only if OCDS is enabled.
 *
 * \param[inout] stm Pointer to the STM module registers.
 *
 * \retval None
 */
IFX_EXTERN void IfxStm_enableOcdsSuspend(Ifx_STM *stm);

/** \brief Retrieves the address of a specific STM module based on the given index.
 *
 * \param[in] stm Pointer to the STM module registers.
 *
 * \retval Ifx_STM* Pointer to the STM module's address if the index is valid.
 */
IFX_EXTERN Ifx_STM *IfxStm_getAddress(IfxStm_Index stm);

/** \brief Retrieves the index of a specific STM module.
 *
 * \param[in] stm Pointer to the STM module registers.
 *
 * \retval system timer module index.
 */
IFX_EXTERN IfxStm_Index IfxStm_getIndex(Ifx_STM *stm);

/** \} */

/** \addtogroup IfxLld_Stm_Std_Timer
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Retrieves the the lower system timer value.
 *
 * \param[in] stm Pointer to the STM module registers.
 *
 * \retval uint32 The lower 32-bit value of the STM module's TIM0 register.
           Range: 0 to 0xFFFFFFFF
 */
IFX_INLINE uint32 IfxStm_getLower(Ifx_STM *stm);

/** \brief Retrieves the TIM3 couter value.
 *
 * \param[in] stm Pointer to the STM module registers.
 *
 * \retval uint32 TIM3 counter value.
           Range: 0 to 0xFFFFFFFF
 */
IFX_INLINE uint32 IfxStm_getOffset12Timer(Ifx_STM *stm);

/** \brief Retrieves the TIM4 couter value.
 *
 * \param[in] stm Pointer to the STM module registers.
 *
 * \retval uint32 TIM4 counter value.
           Range: 0 to 0xFFFFFFFF
 */
IFX_INLINE uint32 IfxStm_getOffset16Timer(Ifx_STM *stm);

/** \brief Retrieves the TIM5 couter value.
 *
 * \param[in] stm Pointer to the STM module registers.
 *
 * \retval uint32 TIM5 counter value.
           Range: 0 to 0xFFFFFFFF
 */
IFX_INLINE uint32 IfxStm_getOffset20Timer(Ifx_STM *stm);

/** \brief Retrieves the TIM6 couter value.
 *
 * \param[in] stm Pointer to the STM module registers.
 *
 * \retval uint32 TIM6 counter value.
           Range: 0 to 0xFFFFFFFF
 */
IFX_INLINE uint32 IfxStm_getOffset32Timer(Ifx_STM *stm);

/** \brief Retrieves the TIM1 couter value.
 *
 * \param[in] stm Pointer to the STM module registers.
 *
 * \retval uint32 TIM1 counter value.
           Range: 0 to 0xFFFFFFFF
 */
IFX_INLINE uint32 IfxStm_getOffset4Timer(Ifx_STM *stm);

/** \brief Retrieves the TIM2 couter value.
 *
 * \param[in] stm Pointer to the STM module registers.
 *
 * \retval uint32 TIM2 counter value.
           Range: 0 to 0xFFFFFFFF
 */
IFX_INLINE uint32 IfxStm_getOffset8Timer(Ifx_STM *stm);

/** \brief Retrieves the offset timer value from the STM module.
 *
 * \param[in] stm Pointer to the STM module registers.
 * \param[in] offset Offset value to select the specific timer.
              Range: 0 to 31
 *
 * \retval The lower system timer value shifted by offset.
           Range: 0 to 0xFFFFFFFF
 */
IFX_INLINE uint32 IfxStm_getOffsetTimer(Ifx_STM *stm, uint8 offset);

/** \brief Waits for a specified number of system ticks using the System Timer Module (STM).
 *
 * \param[in] stm Pointer to the STM module registers.
 * \param[in] ticks Number of ticks to wait. Should be a positive integer value.
              Range: 0 to 0xFFFFFFFF
 *
 * \retval None
 */
IFX_INLINE void IfxStm_waitTicks(Ifx_STM *stm, uint32 ticks);

/** \} */

/** \addtogroup IfxLld_Stm_Std_Comparator
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Retrieves the current comparison value from the specified comparator of the STM unit.
 *
 * \param[in] stm Pointer to the STM module registers.
 * \param[in] comparator Comparator selection.
          Range: \ref IfxStm_Comparator.
 *
 * \retval The compare value.
           Range: 0 to 0xFFFFFFFF
 */
IFX_INLINE uint32 IfxStm_getCompare(Ifx_STM *stm, IfxStm_Comparator comparator);

/** \brief Retrieves the number of ticks for the selected micro seconds based on the STM frequency.
 *
 * \param[in] stm Pointer to the STM module registers.
 * \param[in] Number of micro seconds that need to be converted to ticks
              Range: 0 to 0xFFFFFFFF
 *
 * \retval The equivalent number of STM ticks.
 */
IFX_INLINE sint32 IfxStm_getTicksFromMicroseconds(Ifx_STM *stm, uint32 microSeconds);

/** \brief Retrieves the number of ticks for the selected milli seconds based on the STM frequency.
 *
 * \param[in] stm Pointer to the STM module registers.
 * \param[in] milliSeconds Time in milliseconds to be converted to ticks.
              Range: 0 to 0xFFFFFFFF
 *
 * \retval The number of ticks corresponding to the given milliseconds.
 */
IFX_INLINE sint32 IfxStm_getTicksFromMilliseconds(Ifx_STM *stm, uint32 milliSeconds);

/** \brief Increases the compare value of a specified STM comparator by a given number of ticks.
 *
 * \param[inout] stm Pointer to the STM module registers.
 * \param[in] comparator Comparator selection.
          Range: \ref IfxStm_Comparator.
 * \param[in] ticks The number of ticks to add to the current compare value.
 *
 * \retval None
 */
IFX_INLINE void IfxStm_increaseCompare(Ifx_STM *stm, IfxStm_Comparator comparator, uint32 ticks);

/** \brief Updates the compare value of a specific comparator in the STM with a new number of ticks.
 *
 * \param[inout] stm Pointer to the STM module registers.
 * \param[in] comparator Comparator selection.
          Range: \ref IfxStm_Comparator.
 * \param[in] ticks The number of ticks to add to the current compare value.
          Range: 0 to 0xFFFFFFFF
 *
 * \retval None
 */
IFX_INLINE void IfxStm_updateCompare(Ifx_STM *stm, IfxStm_Comparator comparator, uint32 ticks);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Clears the compare flag for the specified comparator in the STM module.
 *
 * \param[inout] stm Pointer to the STM module registers.
 * \param[in] comparator Comparator selection.
              Range: \ref IfxStm_Comparator.
 *
 * \retval None
 */
IFX_EXTERN void IfxStm_clearCompareFlag(Ifx_STM *stm, IfxStm_Comparator comparator);

/** \brief Disables the comparator interrupt for the specified comparator in the STM module.
 *
 * \param[inout] stm Pointer to the STM module registers.
 * \param[in] comparator Comparator selection.
          Range: \ref IfxStm_Comparator.
 *
 * \retval None
 */
IFX_EXTERN void IfxStm_disableComparatorInterrupt(Ifx_STM *stm, IfxStm_Comparator comparator);

/** \brief Enables the comparator interrupt for the specified comparator in the STM module.
 *
 * \param[inout] stm Pointer to the STM module registers.
 * \param[in] comparator Comparator selection.
              Range: \ref IfxStm_Comparator.
 *
 * \retval None
 */
IFX_EXTERN void IfxStm_enableComparatorInterrupt(Ifx_STM *stm, IfxStm_Comparator comparator);

/** \brief Retrieves the source pointer for the specified comparator of the STM module.
 *
 * \param[in] stm Pointer to the STM module registers.
 * \param[in] comparator Comparator selection.
              Range: \ref IfxStm_Comparator.
 *
 * \retval A volatile pointer to the source register (SR) of the specified comparator.
 */
IFX_EXTERN volatile Ifx_SRC_SRCR *IfxStm_getSrcPointer(Ifx_STM *stm, IfxStm_Comparator comparator);

/** \brief Initializes the comparator for the specified STM instance with the given configuration.
 *
 * \param[inout] stm Pointer to the STM module registers.
 * \param[in] config Pointer to the comparator configuration structure.
 *
 * \retval TRUE if the comparator was successfully initialized, FALSE otherwise.
 */
IFX_EXTERN boolean IfxStm_initCompare(Ifx_STM *stm, const IfxStm_CompareConfig *config);

/** \brief Initializes the compare configuration structure to default values.
 *
 * \param[inout] config Pointer to the configuration structure.
 *
 * \retval None
 */
IFX_EXTERN void IfxStm_initCompareConfig(IfxStm_CompareConfig *config);

/** \brief Checks if the compare flag for a specified comparator is set in the STM module.
 *
 * \param[in] stm Pointer to the STM module registers.
 * \param[in] comparator Comparator selection.
              Range: \ref IfxStm_Comparator.
 *
 * \retval TRUE if the interrupt flag is set, FALSE otherwise.
 */
IFX_EXTERN boolean IfxStm_isCompareFlagSet(Ifx_STM *stm, IfxStm_Comparator comparator);

/** \brief Configures the compare control settings for the STM module.
 *
 * \param[inout] stm Pointer to the STM module registers.
 * \param[in] comparator Comparator selection.
              Range: \ref IfxStm_Comparator.
 * \param[in] offset Offset value for the comparator
              Range: \ref IfxStm_ComparatorOffset.
 * \param[in] size Size of the comparator.
              Range: \ref IfxStm_ComparatorSize.
 * \param[in] interrupt Interrupt configuration for the comparator.
              Range: \ref IfxStm_ComparatorInterrupt.
 *
 * \retval None
 */
IFX_EXTERN void IfxStm_setCompareControl(Ifx_STM *stm, IfxStm_Comparator comparator, IfxStm_ComparatorOffset offset, IfxStm_ComparatorSize size, IfxStm_ComparatorInterrupt interrupt);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Sets the sleep mode for the System Timer Module (STM).
 *
 * \param[inout] stm Pointer to the STM module registers.
 * \param[in] mode Sleep mode selection.
              Range: \ref IfxStm_SleepMode.
 *
 * \retval None
 */
IFX_INLINE void IfxStm_setSleepMode(Ifx_STM *stm, IfxStm_SleepMode mode);

/** \brief Retrieves the STM counter value.
 *
 * \retval sint64 The current tick time as a signed 64-bit integer.
 */
IFX_INLINE sint64 IfxStm_now(void);

/** \brief Calculates the deadline time based on the current time and the specified timeout.
 *
 * \param[in] timeout The timeout value to be added to the current time (in milliseconds).
 *
 * \retval sint64 TIME_INFINITE If the timeout is set to TIME_INFINITE, indicating no deadline.
 */
IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout);

/** \brief Checks if the specified deadline has occurred.
 *
 * \param[in] deadLine Deadline value to check.
 *
 * \retval TRUE if the deadline has occurred, FALSE otherwise.
 */
IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine);

/** \brief Waits for a specified timeout period.
 *
 * \param[in] timeout The duration in milliseconds to wait before resuming execution.
 *
 * \retval None
 */
IFX_INLINE void IfxStm_wait(sint64 timeout);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Resets the STM module by setting the Kernel reset bits and waiting for the reset to complete.
 *
 * \param[inout] stm Pointer to the STM module registers.
 *
 * \retval None
 */
IFX_EXTERN void IfxStm_resetModule(Ifx_STM *stm);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
    result |= ((uint64)stm->CAP.U) << 32;

    return result;
}


IFX_INLINE uint32 IfxStm_getCompare(Ifx_STM *stm, IfxStm_Comparator comparator)
{
    return stm->CMP[comparator].B.CMPVAL;
}


IFX_INLINE float32 IfxStm_getFrequency(Ifx_STM *stm)
{
    IFX_UNUSED_PARAMETER(stm);
    float32 result;

    result = IfxScuCcu_getStmFrequency();

    return result;
}


IFX_INLINE uint32 IfxStm_getLower(Ifx_STM *stm)
{
    return stm->TIM0.U;
}


IFX_INLINE uint32 IfxStm_getOffset12Timer(Ifx_STM *stm)
{
    return stm->TIM3.U;
}


IFX_INLINE uint32 IfxStm_getOffset16Timer(Ifx_STM *stm)
{
    return stm->TIM4.U;
}


IFX_INLINE uint32 IfxStm_getOffset20Timer(Ifx_STM *stm)
{
    return stm->TIM5.U;
}


IFX_INLINE uint32 IfxStm_getOffset32Timer(Ifx_STM *stm)
{
    return stm->TIM6.U;
}


IFX_INLINE uint32 IfxStm_getOffset4Timer(Ifx_STM *stm)
{
    return stm->TIM1.U;
}


IFX_INLINE uint32 IfxStm_getOffset8Timer(Ifx_STM *stm)
{
    return stm->TIM2.U;
}


IFX_INLINE uint32 IfxStm_getOffsetTimer(Ifx_STM *stm, uint8 offset)
{
    uint64 now;

    now = IfxStm_get(stm);

    return (uint32)(now >> offset);
}


IFX_INLINE sint32 IfxStm_getTicksFromMicroseconds(Ifx_STM *stm, uint32 microSeconds)
{
    sint32 freq = (sint32)IfxStm_getFrequency(stm);
    return (freq / (1000000)) * microSeconds;
}


IFX_INLINE sint32 IfxStm_getTicksFromMilliseconds(Ifx_STM *stm, uint32 milliSeconds)
{
    sint32 freq = (sint32)IfxStm_getFrequency(stm);
    return (freq / (1000)) * milliSeconds;
}


IFX_INLINE void IfxStm_increaseCompare(Ifx_STM *stm, IfxStm_Comparator comparator, uint32 ticks)
{
    stm->CMP[comparator].B.CMPVAL = stm->CMP[comparator].B.CMPVAL + ticks;
}


IFX_INLINE boolean IfxStm_isModuleSuspended(Ifx_STM *stm)
{
    Ifx_STM_OCS ocs;

    // read the status
    ocs.U = stm->OCS.U;

    // return the status
    return ocs.B.SUSSTA;
}


IFX_INLINE void IfxStm_setSleepMode(Ifx_STM *stm, IfxStm_SleepMode mode)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(passwd);
    stm->CLC.B.EDIS = mode;
    IfxScuWdt_setCpuEndinit(passwd);
}


IFX_INLINE void IfxStm_setSuspendMode(Ifx_STM *stm, IfxStm_SuspendMode mode)
{
    Ifx_STM_OCS ocs;

    /* Only if OCDS is enabled write into the OCS register */
    if (MODULE_CBS.OSTATE.B.OEN == 1U)
    {
        // remove protection and configure the suspend mode.
        ocs.B.SUS_P      = 1;
        ocs.B.SUS        = mode;
        stm->OCS.U       = ocs.U;
        stm->OCS.B.SUS_P = 0;
    }
}


IFX_INLINE void IfxStm_updateCompare(Ifx_STM *stm, IfxStm_Comparator comparator, uint32 ticks)
{
    stm->CMP[comparator].B.CMPVAL = ticks;
}


IFX_INLINE void IfxStm_waitTicks(Ifx_STM *stm, uint32 ticks)
{
    uint32 beginTime;

    beginTime = IfxStm_getLower(stm);

    /*below code will work because of unsigned 32 bit calculation even at timer wrapping condition
     * As an example if beginTime = 0xFFFFFFFE and current time = 2 (after overflow), unsigned calculation
     * 2 - 0xFFFFFFFE will be 4*/
    while ((IfxStm_getLower(stm) - beginTime) < ticks)
    {}
}


IFX_INLINE sint64 IfxStm_now(void)
{
    sint64  stmNow;
    boolean interruptState;

    interruptState = IfxCpu_disableInterrupts();
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
    IfxCpu_restoreInterrupts(interruptState);

    return stmNow;
}


IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
    }

    return deadLine;
}


IFX_INLINE boolean IfxStm_isDeadLine(sint64 deadLine)
{
    boolean result;

    if (deadLine == TIME_INFINITE)
    {
        result = FALSE;
    }
    else
    {
        result = IfxStm_now() >= deadLine;
    }

    return result;
}


IFX_INLINE void IfxStm_wait(sint64 timeout)
{
    sint64 deadLine = IfxStm_getDeadLine(timeout);

    while (IfxStm_isDeadLine(deadLine) == FALSE)
    {}
}


#endif /* IFXSTM_H */
