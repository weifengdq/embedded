/**
 * \file IfxAsclin.c
 * \brief ASCLIN  basic functionality
 *
 * \version iLLD_1_20_0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxAsclin.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxAsclin_disableModule(Ifx_ASCLIN *asclin)
{
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
    
    /* clears the endinit protection*/
    IfxScuWdt_clearCpuEndinit(psw);  
    /* disables the module*/
    IfxAsclin_setDisableModuleRequest(asclin); 
    /* sets the endinit protection back on*/
    IfxScuWdt_setCpuEndinit(psw);              
}


void IfxAsclin_enableAscErrorFlags(Ifx_ASCLIN *asclin, boolean parEnable, boolean rfoEnable)
{
    /* enables parity error*/
    IfxAsclin_enableParityErrorFlag(asclin, parEnable);  
    /* enables Rx fifo Overflow error*/
    IfxAsclin_enableRxFifoOverflowFlag(asclin, rfoEnable);  
}


void IfxAsclin_enableModule(Ifx_ASCLIN *asclin)
{
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
    
    /* clears the endinit protection*/
    IfxScuWdt_clearCpuEndinit(psw);  
    /* enables the module*/
    IfxAsclin_setEnableModuleRequest(asclin); 
    /* sets the endinit protection back on*/
    IfxScuWdt_setCpuEndinit(psw);             
}


Ifx_ASCLIN *IfxAsclin_getAddress(IfxAsclin_Index asclin)
{
    Ifx_ASCLIN *module;

    if (asclin < IFXASCLIN_NUM_MODULES)
    {
        module = (Ifx_ASCLIN *)IfxAsclin_cfg_indexMap[asclin].module;
    }
    else
    {
        module = NULL_PTR;
    }

    return module;
}


float32 IfxAsclin_getFaFrequency(Ifx_ASCLIN *asclin)
{
    float32               frequency;
    IfxAsclin_ClockSource clockSource = (IfxAsclin_ClockSource)IfxAsclin_getClockSource(asclin);    /* gets the current clock source*/

    switch (clockSource)
    {
    case IfxAsclin_ClockSource_noClock: /* gets the respective frequency*/
        frequency = 0.0f;
        break;
    case IfxAsclin_ClockSource_ascFastClock:
        frequency = IfxScuCcu_getAsclinFFrequency();
        break;
    case IfxAsclin_ClockSource_ascSlowClock:
        frequency = IfxScuCcu_getAsclinSFrequency();
        break;
    default:
        frequency = 0.0f;
        break;
    }

    return frequency;
}


IfxAsclin_Index IfxAsclin_getIndex(Ifx_ASCLIN *asclin)
{
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
    {
        if (IfxAsclin_cfg_indexMap[index].module == asclin)
        {
            result = (IfxAsclin_Index)IfxAsclin_cfg_indexMap[index].index;
            break;
        }
    }

    return result;
}


float32 IfxAsclin_getOvsFrequency(Ifx_ASCLIN *asclin)
{
    return (IfxAsclin_getPdFrequency(asclin) * asclin->BRG.B.NUMERATOR) / asclin->BRG.B.DENOMINATOR;
}


float32 IfxAsclin_getPdFrequency(Ifx_ASCLIN *asclin)
{
    return IfxAsclin_getFaFrequency(asclin) / (asclin->BITCON.B.PRESCALER + 1);
}


float32 IfxAsclin_getShiftFrequency(Ifx_ASCLIN *asclin)
{
    return IfxAsclin_getOvsFrequency(asclin) / (asclin->BITCON.B.OVERSAMPLING + 1);
}


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerEr(Ifx_ASCLIN *asclin)
{
#if defined(DEVICE_TC38X) || defined(DEVICE_TC38EVOX)
uint32              index                 = IfxAsclin_getIndex(asclin);

return srcAscLinErrAddress[index];
#else
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].ERR);
#endif
}


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerRx(Ifx_ASCLIN *asclin)
{
#if defined(DEVICE_TC38X) || defined(DEVICE_TC38EVOX)
    uint32              index                = IfxAsclin_getIndex(asclin);

    return srcAscLinRxAddress[index];
#else
	return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].RX);
#endif
}


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerTx(Ifx_ASCLIN *asclin)
{
#if defined(DEVICE_TC38X) || defined(DEVICE_TC38EVOX)
    uint32              index                = IfxAsclin_getIndex(asclin);

    return srcAscLinTxAddress[index];
#else
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].TX);
#endif
}


uint32 IfxAsclin_read16(Ifx_ASCLIN *asclin, uint16 *data, uint32 count)
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = (uint16)rxData->U;
        count--;
    }

    return count;
}


uint32 IfxAsclin_read32(Ifx_ASCLIN *asclin, uint32 *data, uint32 count)
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = rxData->U;
        count--;
    }

    return count;
}


uint32 IfxAsclin_read8(Ifx_ASCLIN *asclin, uint8 *data, uint32 count)
{
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
    {
        *data++ = (uint8)rxData->U;
        count--;
    }

    return count;
}


void IfxAsclin_resetModule(Ifx_ASCLIN *asclin)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(passwd);

    asclin->KRST0.B.RST = 1;            /* Only if both Kernel reset bits are set a reset is executed */
    asclin->KRST1.B.RST = 1;
    IfxScuWdt_setCpuEndinit(passwd);

    /* Wait until reset is executed */
    while (0 == asclin->KRST0.B.RSTSTAT)    
    {}

    IfxScuWdt_clearCpuEndinit(passwd);
     /* Clear Kernel reset status bit */
    asclin->KRSTCLR.B.CLR = 1;         

    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxAsclin_setBaudrateBitFields(Ifx_ASCLIN *asclin, uint16 prescaler, uint16 numerator, uint16 denominator, IfxAsclin_OversamplingFactor oversampling)
{
    IfxAsclin_ClockSource clockSource = (IfxAsclin_ClockSource)IfxAsclin_getClockSource(asclin); /* gets the current clock source */
    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);                             /* turns off the clock for settings */
    IfxAsclin_setPrescaler(asclin, prescaler);                                                   /* sets the prescaler*/
    IfxAsclin_setNumerator(asclin, numerator);                                                   /* sets the numerator*/
    IfxAsclin_setDenominator(asclin, denominator);                                               /* sets the denominator*/
    IfxAsclin_setOversampling(asclin, oversampling);                                             /* sets the oversampling*/
    IfxAsclin_setClockSource(asclin, clockSource);                                               /* sets the clock source back on*/
}


boolean IfxAsclin_setBitTiming(Ifx_ASCLIN *asclin, float32 baudrate, IfxAsclin_OversamplingFactor oversampling, IfxAsclin_SamplePointPosition samplepoint, IfxAsclin_SamplesPerBit medianFilter)
{
    IfxAsclin_ClockSource source = (IfxAsclin_ClockSource)IfxAsclin_getClockSource(asclin);
    float32               fOvs;
    uint32                d      = 0, n, dBest = 1, nBest = 1;
    float32               f;

    /* Get the prescaler value */
    uint32                prescaler      = asclin->BITCON.B.PRESCALER + 1;
    /* Get the PD frequency */
    float32               fpd            = IfxAsclin_getPdFrequency(asclin);
    /* min. value of (l_oversampling + 1) is 4 */
    uint32                l_oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
    samplepoint = (IfxAsclin_SamplePointPosition)__maxu(samplepoint, 1);
    /* Calculate the required  fOvs */
    fOvs        = baudrate * l_oversampling;
    float32               relError   = fOvs;
    float32               limit;                                         /* save the error limit */
    boolean               terminated = FALSE;
    float32               newRelError;                                   
    uint32                adder_facL, adder_facH, adder_facL_min, count; 

    /* Increment the limit with the increase in baud rate */
    if (baudrate <= 6000)
    {
        limit = 0.01f * fOvs;
    }
    else if (baudrate < 100000)
    {
        limit = 0.001f * fOvs;
    }
    else if (baudrate < 1000000)
    {
        limit = 0.0001f * fOvs;
    }
    else if (baudrate < 8330000)
    {
        limit = 0.00001f * fOvs;
    }
    else
    {
        limit = 0.000001f * fOvs;
    }

    /* Calculate the possible denominator "d" */
    d = (uint32)(fpd / fOvs);
    /* Initialize "numerator" n with 1 */
    n = 1;

    if (d == 0)
    {
        while (d < 1)
        {
            /* decrement l_oversampling until "d" becomes >= 1; (l_oversampling + 1) should not be less than 4 */
            if (l_oversampling >= 5)
            {
                l_oversampling--;
                fOvs = baudrate * l_oversampling;
                d    = (uint32)(fpd / fOvs);
            }
            else
            {
                /* fall back to default values as desired baud rate cannot be achieved with the prescaler > 0*/
                prescaler      = 1;
                l_oversampling = (uint32)(IfxAsclin_OversamplingFactor_16 + 1);
                fpd            = (float32)IfxAsclin_getFaFrequency(asclin) / prescaler;
                fOvs           = baudrate * l_oversampling;
                d              = (uint32)(fpd / fOvs);
            }
        }
    }

    /* if d is possibly greater than 4095 or 0xFFF (12-bit resolution) */
    if (d >> 12)
    {
        /* check if the current baud rate fits in for the 12-bit  "d", for max. l_oversampling value. */
        if (((uint32)(fpd / (baudrate * 16))) >> 12)
        {
            /* Increase the value of the prescaler to generate the required baudrate */
            while (d >> 12)
            {
                prescaler++;

                if (prescaler >> 12)
                {
                    prescaler = 0xFFF;
                    break;
                }

                fpd = (float32)IfxAsclin_getFaFrequency(asclin) / prescaler;
                d   = (uint32)(fpd / fOvs);
            }
        }
        else
        {
            /* Increase the value of the oversampling to generate the required baudrate */
            while (d >> 12)
            {
                l_oversampling++;

                if (l_oversampling > 16)
                {
                    l_oversampling = (uint32)(IfxAsclin_OversamplingFactor_16 + 1);
                    break;
                }

                fOvs = baudrate * l_oversampling;
                d    = (uint32)(fpd / fOvs);
            }
        }
    }

    dBest          = d;
    nBest          = n;
    adder_facL_min = 0;
    f              = (fpd * n) / d;
    relError       = __absf(fOvs - f);

    if (relError <= limit)
    {
        terminated = TRUE;
    }

    for (n = 2; ((!terminated) && (n <= 0xFFF)); n++)
    {
        if (n == 2)
        {
            adder_facL = 1;
            adder_facH = 1;
        }
        else
        {
            adder_facL = (adder_facL_min * n) / nBest;
            adder_facH = adder_facL + 1;
        }

        for (count = adder_facL; ((count <= adder_facH) && (nBest <= dBest)); count++)
        {
            f           = (fpd * n) / (n * d + count);
            newRelError = __absf(fOvs - f);

            if (relError > newRelError)
            {
                relError = newRelError;
                nBest    = n;
                dBest    = (n * d + count);

                if (dBest > 4095)
                {
                    dBest = 4095;
                }

                adder_facL_min = count;
            }

            if (relError <= limit)
            {
                terminated = TRUE;
                break;
            }
        }
    }

    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
    asclin->BRG.B.DENOMINATOR = dBest;
    asclin->BRG.B.NUMERATOR   = nBest;

    /* Set the clock divider value */
    asclin->BITCON.B.PRESCALER = prescaler - 1;

    /* Set the SHIFT frequency */
    asclin->BITCON.B.OVERSAMPLING = l_oversampling - 1;

    /* Set the sampling point */
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;

    /* Set the median filter */
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;

    IfxAsclin_setClockSource(asclin, source);

    return TRUE;
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
    /* selects the given clock source*/
    asclin->CSR.B.CLKSEL = clockSource; 

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
        {}
    }
    else
    {
        while (IfxAsclin_getClockStatus(asclin) != 1U)
        {}
    }
}


uint32 IfxAsclin_write16(Ifx_ASCLIN *asclin, uint16 *data, uint32 count)
{
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {
        txData->U = *data++;
        count--;
    }

    return count;
}


uint32 IfxAsclin_write32(Ifx_ASCLIN *asclin, uint32 *data, uint32 count)
{
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {
        txData->U = *data++;
        count--;
    }

    return count;
}


uint32 IfxAsclin_write8(Ifx_ASCLIN *asclin, uint8 *data, uint32 count)
{
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
    {
        txData->U = *data++;
        count--;
    }

    return count;
}
