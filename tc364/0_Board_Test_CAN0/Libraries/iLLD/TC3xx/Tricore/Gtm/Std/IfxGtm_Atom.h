/**
 * \file IfxGtm_Atom.h
 * \brief GTM  basic functionality
 * \ingroup IfxLld_Gtm
 *
 * \version iLLD_1_20_0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 *
 * \defgroup IfxLld_Gtm_Std_Atom Atom Basic Functionality
 * \ingroup IfxLld_Gtm_Std
 * \defgroup IfxLld_Gtm_Std_Atom_Enumerations ATOM Enumerations
 * \ingroup IfxLld_Gtm_Std_Atom
 * \defgroup IfxLld_Gtm_Std_Atom_Channel_Functions ATOM Channel Functions
 * \ingroup IfxLld_Gtm_Std_Atom
 * \defgroup IfxLld_Gtm_Std_Atom_AGC_Functions ATOM AGC Functions
 * \ingroup IfxLld_Gtm_Std_Atom
 * \defgroup IfxLld_Gtm_Std_Atom_Module_Functions ATOM Module Functions
 * \ingroup IfxLld_Gtm_Std_Atom
 */

#ifndef IFXGTM_ATOM_H
#define IFXGTM_ATOM_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxGtm_cfg.h"
#include "IfxGtm.h"
#include "IfxGtm_Tbu.h"
#include "Src/Std/IfxSrc.h"
#include "IfxGtm_Cmu.h"
#include "stddef.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Macro to calculate shift for each channel
 * Each channel occupies two bits hence left shift by 1 and then add offset
 */
#define IFXGTM_ATOM_AGC_CHANNEL_SHIFT(channel, offset) ((((uint32)((uint32)channel & 0x7u)) << 1u) + offset)

/** \brief Macro to mask one channel bitfield in AGC registers
 */
#define IFXGTM_ATOM_AGC_CHANNEL_MASK (3u)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Gtm_Std_Atom_Enumerations
 * \{ */
/** \brief Reset source for channel counter CN0
 */
typedef enum
{
    IfxGtm_Atom_Ch_OutputTrigger_forward  = 0, /**< \brief Forward the trigger from the previous channel */
    IfxGtm_Atom_Ch_OutputTrigger_generate = 1  /**< \brief Generate the trigger from the current channel */
} IfxGtm_Atom_Ch_OutputTrigger;

/** \brief Reset event for channel counter CN0
 */
typedef enum
{
    IfxGtm_Atom_Ch_ResetEvent_onCm0     = 0,
    IfxGtm_Atom_Ch_ResetEvent_onTrigger = 1
} IfxGtm_Atom_Ch_ResetEvent;

/** \brief Enum for ATOM mode
 */
typedef enum
{
    IfxGtm_Atom_Mode_outputImmediate,
    IfxGtm_Atom_Mode_outputCompare,
    IfxGtm_Atom_Mode_outputPwm,
    IfxGtm_Atom_Mode_outputSerial
} IfxGtm_Atom_Mode;

/** \brief Enable/disable of Aru Input to ATOM channel
 */
typedef enum
{
    IfxGtm_Atom_AruInput_disabled = 0,  /**< \brief ARU input disabled */
    IfxGtm_Atom_AruInput_enabled  = 1   /**< \brief ARU input enabled */
} IfxGtm_Atom_AruInput;

/** \brief Match Compare control modes
 */
typedef enum
{
    IfxGtm_Atom_SomcControl_compareBoth     = 0,  /**< \brief compare CCU0 and CCU1 in parallel */
    IfxGtm_Atom_SomcControl_compareBoth1    = 1,  /**< \brief compare CCU0 and CCU1 in parallel */
    IfxGtm_Atom_SomcControl_ccu0Ts0         = 2,  /**< \brief compare CCU0 against TS0 */
    IfxGtm_Atom_SomcControl_ccu1Ts12        = 3,  /**< \brief compare only CCU1 against TS1 or TS2 */
    IfxGtm_Atom_SomcControl_ccu0ccu1Ts0     = 4,  /**< \brief compare CCU0 then CCU1, use TS0 */
    IfxGtm_Atom_SomcControl_ccu0ccu1Ts12    = 5,  /**< \brief compare CCU0 then CCU1. Use TS1 or TS2 */
    IfxGtm_Atom_SomcControl_ccu0Ts0ccu1Ts12 = 6,  /**< \brief compare CCU0 with TS0 then CCU1 with TS1 or TS2 */
    IfxGtm_Atom_SomcControl_cancelCompare   = 7   /**< \brief Cancel pending compare events */
} IfxGtm_Atom_SomcControl;

/** \brief SOMC signal level Control
 */
typedef enum
{
    IfxGtm_Atom_SomcSignalLevelControl_noChange = 0,  /**< \brief no signal level change at output */
    IfxGtm_Atom_SomcSignalLevelControl_sl0Out1  = 1,  /**< \brief SL= 0 -> Out=1; SL=1->Out=0 */
    IfxGtm_Atom_SomcSignalLevelControl_sl0Out0  = 2,  /**< \brief SL=0->Out=0; SL=1->Out=1 */
    IfxGtm_Atom_SomcSignalLevelControl_toggle   = 3   /**< \brief toggle the output signal level */
} IfxGtm_Atom_SomcSignalLevelControl;

/** \brief SOMI ACB0 Control
 */
typedef enum
{
	IfxGtm_Atom_SomiAcb0Control_inverseSl = 0,  /**< \brief Set output to inverse of SL bit */
	IfxGtm_Atom_SomiAcb0Control_Sl  = 1,        /**< \brief Set output to SL bit */
} IfxGtm_Atom_SomiAcb0Control;

/** \brief SOMP ARU Data Select
 */
typedef enum
{
	IfxGtm_Atom_SompAruDataSelect_bothWord = 0,  /**< \brief Load both ARU words into shadow registers */
	IfxGtm_Atom_SompAruDataSelect_lowWord  = 1,  /**< \brief Load ARU low word (Bits 23…0) into shadow register SR0 */
	IfxGtm_Atom_SompAruDataSelect_highWord = 2,  /**< \brief Load ARU high word (Bits 47…24) into shadow register SR1 */
} IfxGtm_Atom_SompAruDataSelect;

/** \brief SOMS Shift Direction for CM1
 */
typedef enum
{
	IfxGtm_Atom_SomsShiftDirection_right = 0,  /**< \brief Right shift of data is started from bit 0 of CM1 */
	IfxGtm_Atom_SomsShiftDirection_left  = 1,  /**< \brief Left shift of data is started from bit 23 of CM1 */
} IfxGtm_Atom_SomsShiftDirection;

/** \brief SOMB signal level Control
 */
typedef enum
{
	IfxGtm_Atom_SombSignalLevelControl_noChange = 0,  /**< \brief no signal level change at output */
	IfxGtm_Atom_SombSignalLevelControl_sl0Out1  = 1,  /**< \brief SL= 0 -> Out=1; SL=1->Out=0 */
	IfxGtm_Atom_SombSignalLevelControll_sl0Out0 = 2,  /**< \brief SL= 0 -> Out=0; SL=1->Out=1 */
	IfxGtm_Atom_SombSignalLevelControl_toggle   = 3   /**< \brief toggle the output signal level */
} IfxGtm_Atom_SombSignalLevelControl;

/** \brief SOMB Compare Strategy
 */
typedef enum
{
    IfxGtm_Atom_SombCompareStrategy_ccu0Ts0         = 2,  /**< \brief compare CCU0 against TS0 */
    IfxGtm_Atom_SombCompareStrategy_ccu1Ts12        = 3,  /**< \brief compare only CCU1 against TS1 or TS2 */
    IfxGtm_Atom_SombCompareStrategy_ccu0ccu1Ts0     = 4,  /**< \brief compare CCU0 then CCU1, use TS0 */
    IfxGtm_Atom_SombCompareStrategy_ccu0ccu1Ts12    = 5,  /**< \brief compare CCU0 then CCU1. Use TS1 or TS2 */
    IfxGtm_Atom_SombCompareStrategy_ccu0Ts0ccu1Ts12 = 6,  /**< \brief compare CCU0 with TS0 then CCU1 with TS1 or TS2 */
    IfxGtm_Atom_SombCompareStrategy_cancelCompare   = 7   /**< \brief Cancel pending compare events */
} IfxGtm_Atom_SombCompareStrategy;

/** \brief Trigger output pulse length
 */
typedef enum
{
	IfxGtm_Atom_Ch_TriggerOutputPulseLength_sr0    = 0, /**< \brief Pulse Length is as long as CN0=SR0 */
	IfxGtm_Atom_Ch_TriggerOutputPulseLength_sysClk = 1  /**< \brief Pulse Length is only one SYS_CLK period if CN0=SR0 */
} IfxGtm_Atom_Ch_TriggerOutputPulseLength;

/** \brief Up-down counter mode for ATOM channels
 */
typedef enum
{
	IfxGtm_Atom_Ch_CounterMode_up            = 0, /**< \brief Up-down counter mode disabled: CN0 counts always up */
	IfxGtm_Atom_Ch_CounterMode_downUp 		 = 1, /**< \brief Up-down counter mode enabled: CN0 counts up and down, CM0,CM1 are updated if CN0 reaches 0 (i.e. changes from down to up) */
	IfxGtm_Atom_Ch_CounterMode_upDown 		 = 2, /**< \brief Up-down counter mode enabled: CN0 counts up and down, CM0,CM1 are updated if CN0 reaches CM0 (i.e. changes from up to down) */
	IfxGtm_Atom_Ch_CounterMode_bothUpAndDown = 3  /**< \brief Up-down counter mode enabled: CN0 counts up and down, CM0,CM1 are updated if CN0 reaches 0 or CM0 (i.e. changes direction) */
} IfxGtm_Atom_Ch_CounterMode;

/** \brief Trigger source for trigger signals
 */
typedef enum
{
	IfxGtm_Atom_Ch_TriggerSignal_internal = 0, /**< \brief Internal trigger signal TRIG_[x-1] of the preceding channel x-1 */
	IfxGtm_Atom_Ch_TriggerSignal_external = 1  /**< \brief External trigger signal TIM_EXT_CAPTURE(x) of the assigned TIM channel[x]  */
} IfxGtm_Atom_Ch_TriggerSignal;

/** \brief Time base value TBU_TS1 or TBU_TS2
 */
typedef enum
{
	IfxGtm_Atom_Ch_TimeBaseValue_tbuTs1 = 0, /**< \brief TBU_TS1 selected for comparison */
	IfxGtm_Atom_Ch_TimeBaseValue_tbuTs2 = 1  /**< \brief TBU_TS2 selected for comparison */
} IfxGtm_Atom_Ch_TimeBaseValue;

/** \brief CCUx compare strategy
 */
typedef enum
{
	IfxGtm_Atom_Ch_CompareStrategy_greaterEqual = 0, /**< \brief Greater-equal compare against TBU time base values (TBU_TSx greater than or equal to CMx) */
	IfxGtm_Atom_Ch_CompareStrategy_lessEqual    = 1  /**< \brief Less-equal compare against TBU time base values (TBU_TSx less than or equal to CMx) */
} IfxGtm_Atom_Ch_CompareStrategy;

/** \brief Serve last ARU communication strategy
 */
typedef enum
{
	IfxGtm_Atom_Ch_SlaStrategy_notProvidedToAru = 0, /**< \brief Capture SRx time stamps after CCU0 match event not provided to ARU */
	IfxGtm_Atom_Ch_SlaStrategy_providedToAru    = 1  /**< \brief Capture SRx time stamps after CCU0 match event provided to ARU */
} IfxGtm_Atom_Ch_SlaStrategy;

/** \} */

/** \addtogroup IfxLld_Gtm_Std_Atom_Channel_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Returns the base address of the selected Atom channel.
 *
 * \param[in] atom     Pointer to the ATOM object.
 * \param[in] channel  The channel index to be accessed. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval Ifx_GTM_ATOM_CH* Pointer to the base address of the specified Atom channel.
 */
IFX_INLINE Ifx_GTM_ATOM_CH *IfxGtm_Atom_Ch_getChannelPointer(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Configures the shadow values for compare 0 and compare 1 in the specified channel.
 *
 * \param[inout] atom       Pointer to the ATOM object
 * \param[in]    channel    Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    shadowZero Compare zero shadow value. Range: 0 to 0x00FFFFFF
 * \param[in]    shadowOne  Compare one shadow value. Range: 0 to 0x00FFFFFF
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Atom_Ch_setCompareShadow(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, uint32 shadowZero, uint32 shadowOne);

/**
 * \brief Sets the channel's extend clock source configuration.
 *        Enables or disables the use of TRIG[x-1]/TIM_EXT_CAPTURE[x] as the clock source.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]    channel Channel index to configure. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    enabled If TRUE, enables the extend clock source, allowing configuration of TRIG[x-1]/TIM_EXT_CAPTURE[x] as the clock.
 *                       If FALSE, disables the extend clock source.
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Atom_Ch_setExtendClockSource(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled);

/**
 * \brief Sets the trigger output pulse length for a specific channel in the ATOM module.
 *
 * \param[inout] atom        Pointer to the ATOM object.
 * \param[in]    channel     Channel index to configure. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    pulseLength Trigger output pulse length to set. Range: \ref IfxGtm_Atom_Ch_TriggerOutputPulseLength
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Atom_Ch_setTriggerPulseLength(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_Ch_TriggerOutputPulseLength pulseLength);

/**
 * \brief Configures the up-down counter mode for a specified ATOM channel.
 *
 * \param[inout] atom        Pointer to the ATOM object.
 * \param[in] 	 channel     Channel index to configure. Range: \ref IfxGtm_Atom_Ch
 * \param[in] 	 counterMode Up-down counter mode for the specified channel.
 *                           Range: \ref IfxGtm_Atom_Ch_CounterMode
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Atom_Ch_setCounterMode(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_Ch_CounterMode counterMode);

/**
 * \brief Enable or disable the trigger of a one-shot pulse by the OSM_TRIG signal.
 *
 * This function configures whether the OSM_TRIG signal can trigger the start of a single pulse generation.
 * The trigger functionality is only active if the OSM bit is set to 1.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in] 	 channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in] 	 enabled Boolean flag to enable (TRUE) or disable (FALSE) the OSM_TRIG trigger
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Atom_Ch_setOsmTrigger(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled);

/** \brief Sets the channel external trigger signal.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in] 	 channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    trigger Channel trigger source for trigger signals. Range: \ref IfxGtm_Atom_Ch_TriggerSignal
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Atom_Ch_setExtTriggerSignal(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_Ch_TriggerSignal trigger);

/** \brief Sets the channel external trigger output.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in] 	 channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    trigger Channel trigger output signal. Range: \ref IfxGtm_Atom_Ch_TriggerSignal
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Atom_Ch_setExtTriggerOutput(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_Ch_TriggerSignal trigger);

/**
 * \brief Sets the channel Freeze mode.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in] 	 channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    enabled If TRUE,enable Freeze mode; if FALSE, disable Freeze mode.
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Atom_Ch_setFreeze(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled);

/**
 * \brief Sets the time base value for the specified channel to either TBU_TS1 or TBU_TS2.
 *
 * \param[inout] atom     Pointer to the ATOM object.
 * \param[in] 	 channel  Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    timeBase Time base value to set. Range: \ref IfxGtm_Atom_Ch_TimeBaseValue
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Atom_Ch_setTimeBaseValue(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_Ch_TimeBaseValue timeBase);

/**
 * \brief Configures the CCUx compare strategy for the specified ATOM channel.
 *
 * \param[inout] atom            Pointer to the ATOM object.
 * \param[in] 	 channel         Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    compareStrategy The comparison strategy to apply. Range: \ref IfxGtm_Atom_Ch_CompareStrategy
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Atom_Ch_setCompareStrategy(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_Ch_CompareStrategy compareStrategy);

/**
 * \brief Sets the Extended update mode for a specific channel in the ATOM object.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in] 	 channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in] 	 enabled Boolean flag to enable or disable the Extended update mode. Set to TRUE to enable the mode, FALSE to disable it.
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Atom_Ch_setExtendedUpdateMode(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled);

/**
 * \brief Sets or clears the CPU Write request bit for late compare register update
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in] 	 channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    enabled If TRUE, enables late compare register update request by CPU; 
 *               	     if FALSE, disables the late update request by CPU.
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Atom_Ch_setLateCompareRegisterUpdate(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled);

/**
 * \brief Configures the Serve last ARU communication strategy for the specified channel.
 *
 * \param[inout] atom        Pointer to the ATOM object.
 * \param[in] 	 channel     Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in] 	 slaStrategy Selects the Serve last ARU communication strategy. Range: \ref IfxGtm_Atom_Ch_SlaStrategy
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Atom_Ch_setSlaStrategy(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_Ch_SlaStrategy slaStrategy);

/**
 * \brief Sets the ARU blocking mode for the specified channel in the ATOM object.
 * 
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in] 	 channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in] 	 enabled Boolean flag to enable or disable ARU blocking mode. 
 *                   	 - TRUE: ARU blocking mode is enabled.
 *                  	 - FALSE: ARU blocking mode is disabled.
 * 
 * \retval None
 */
IFX_INLINE void IfxGtm_Atom_Ch_setAruBlockingMode(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled);

/**
 * \brief Sets or clears the SOMB for the specified ATOM channel.
 * 
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in] 	 channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    enabled Boolean flag to enable or disable SOMB mode. If TRUE, SOMB mode is enabled for the specified channel. If FALSE, the channel operates according to its MODE bit field configuration.
 * 
 * \retval None
 */
IFX_INLINE void IfxGtm_Atom_Ch_setSombMode(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled);

/**
 *  \brief Sets External force update (EXT_FUPD).
 *
 * \param[inout] atom    Pointer to the ATOM object
 * \param[in]    channel Channel index
 * \param[in]    enabled Boolean to enable external force update. If TRUE, Use TIM_EXT_CAPTURE signal to force update, else use FUPD(x) signal from AGC to force update.
 *
 * \retval None
 *
 * \note This bit (EXT_FUPD) is only applicable in SOMP and SOMS mode.
 */
IFX_INLINE void IfxGtm_Atom_Ch_setExtForceUpdate(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Clears an IR notification for CCU1 events.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in] 	 channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_clearOneNotification(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Clears IR notification for CCU0 events.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in] 	 channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_clearZeroNotification(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Configures the PWM mode for a specific channel in the ATOM module.
 *
 * This function sets up the PWM mode configuration for the specified channel, including
 * the clock source, active state, reset event, and trigger output mode.
 *
 * \param[inout] atom    	 Pointer to the ATOM object.
 * \param[in] 	 channel 	 Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    clock   	 Clock source for the PWM mode. Range: \ref IfxGtm_Cmu_Clk
 * \param[in]    activeState Active state of the PWM signal. Range: \ref Ifx_ActiveState
 * \param[in]    resetEvent  Channel reset event. Range: \ref IfxGtm_Atom_Ch_ResetEvent
 * \param[in]    trigger     Trigger output mode for the channel. Range: \ref IfxGtm_Atom_Ch_OutputTrigger
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_configurePwmMode(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Cmu_Clk clock, Ifx_ActiveState activeState, IfxGtm_Atom_Ch_ResetEvent resetEvent, IfxGtm_Atom_Ch_OutputTrigger trigger);

/**
 * \brief Returns the ATOM channel input clock frequency in Hz
 *
 * \param[in] gtm 	  Pointer to the GTM module instance
 * \param[in] atom 	  Pointer to the ATOM object.
 * \param[in] channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval float32 ATOM channel input clock frequency in Hz
 */
IFX_EXTERN float32 IfxGtm_Atom_Ch_getClockFrequency(Ifx_GTM *gtm, Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Retrieves the clock source configuration for the specified ATOM channel.
 *
 * \param[in] atom    Pointer to the ATOM object.
 * \param[in] channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval IfxGtm_Cmu_Clk The clock source configured for the specified channel. Range: \ref IfxGtm_Cmu_Clk
 */
IFX_EXTERN IfxGtm_Cmu_Clk IfxGtm_Atom_Ch_getClockSource(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Retrieves the compare one value for the specified channel in the ATOM object.
 *
 * \param[in] atom    Pointer to the ATOM object.
 * \param[in] channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval uint32 The compare one value of the specified channel. Range: 0 to 0x00FFFFFF
 */
IFX_EXTERN uint32 IfxGtm_Atom_Ch_getCompareOne(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Returns the compare one pointer for the specified channel in the ATOM object.
 *
 * \param[in] atom    Pointer to the ATOM object.
 * \param[in] channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval uint32* Pointer to the compare one register of the specified channel.
 */
IFX_EXTERN volatile uint32 *IfxGtm_Atom_Ch_getCompareOnePointer(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Returns the compare zero value for the specified channel in the ATOM object.
 *
 * \param[in] atom    Pointer to the ATOM object.
 * \param[in] channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval uint32 The compare zero value of the specified channel. Range: 0 to 0x00FFFFFF
 */
IFX_EXTERN uint32 IfxGtm_Atom_Ch_getCompareZero(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Returns the compare zero pointer for the specified channel in the ATOM module.
 *
 * \param[in] atom    Pointer to the ATOM object.
 * \param[in] channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval uint32* Pointer to the compare zero register of the specified channel.
 */
IFX_EXTERN volatile uint32 *IfxGtm_Atom_Ch_getCompareZeroPointer(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Gets the ATOM output level for a specific channel
 *
 * \param[in] atom    Pointer to the ATOM object.
 * \param[in] channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval TRUE If Output level is high
 *         FALSE If Output level is low
 */
IFX_EXTERN boolean IfxGtm_Atom_Ch_getOutputLevel(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Returns a pointer to the ATOM channel SRC.
 *
 * \param[in] gtm     Pointer to the GTM module instance.
 * \param[in] atom    Specifies the ATOM object within the GTM module.
 * \param[in] channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval Ifx_SRC_SRCR* Pointer to the SRC register of the specified ATOM channel.
 */
IFX_EXTERN volatile Ifx_SRC_SRCR *IfxGtm_Atom_Ch_getSrcPointer(Ifx_GTM *gtm, IfxGtm_Atom atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Returns the Timer pointer.
 *
 * \param[in] atom    Pointer to the ATOM object.
 * \param[in] channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval uint32* Timer pointer. 
 */
IFX_EXTERN volatile uint32 *IfxGtm_Atom_Ch_getTimerPointer(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Returns the status of channel One notification.
 *
 * \param[in] atom    Pointer to the ATOM object.
 * \param[in] channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval TRUE If the channel has triggered a One notification.
 *         FALSE If the channel has not triggered a One notification.
 */
IFX_EXTERN boolean IfxGtm_Atom_Ch_isOneNotification(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Returns the status of channel Zero notification.
 *
 * \param[in] atom    Pointer to the ATOM object.
 * \param[in] channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval TRUE If the channel is generating a Zero notification.
 *         FALSE If the channel is not generating a Zero notification.
 */
IFX_EXTERN boolean IfxGtm_Atom_Ch_isZeroNotification(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Raises the interrupt for Compare 1 for the specified channel.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval None 
 */
IFX_EXTERN void IfxGtm_Atom_Ch_raiseInterruptOne(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Raises the interrupt for Compare 0 for the specified channel.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval None 
 */
IFX_EXTERN void IfxGtm_Atom_Ch_raiseInterruptZero(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/** 
 * \brief Sets the channel clock source.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    clock   Channel clock source. Range: \ref IfxGtm_Cmu_Clk
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setClockSource(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Cmu_Clk clock);

/**
 * \brief Configures the compare values for a specific channel in the ATOM timer.
 *        This function sets the compare 0 and compare 1 values for the specified
 *        channel, which are used to generate timer events when the timer reaches
 *        these values.
 *
 * \param[inout] atom        Pointer to the ATOM object.
 * \param[in]    channel     Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    compareZero Compare 0 value to set. Range: 0 to 0x00FFFFFF
 * \param[in]    compareOne  Compare 1 value to set. Range: 0 to 0x00FFFFFF
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setCompare(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, uint32 compareZero, uint32 compareOne);

/**
 * \brief Configures the compare 1 value for a specified channel in the ATOM module.
 *
 * \param[inout] atom       Pointer to the ATOM object.
 * \param[in]    channel    Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    compareOne Compare 1 value to be set. Range: 0 to 0x00FFFFFF
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setCompareOne(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, uint32 compareOne);

/**
 * \brief Sets the compare 1 shadow value for the specified channel in the ATOM object.
 *
 * \param[inout] atom      Pointer to the ATOM object.
 * \param[in]    channel   Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    shadowOne Compare 1 shadow value to be set. Range: 0 to 0x00FFFFFF
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setCompareOneShadow(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, uint32 shadowOne);

/** \brief Sets the compare 0 value for a specified channel in the ATOM module.
 *
 * \param[inout] atom        Pointer to the ATOM object.
 * \param[in]    channel     Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    compareZero Compare zero value. Range: 0 to 0x00FFFFFF
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setCompareZero(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, uint32 compareZero);

/**
 * \brief Configures the compare 0 shadow value for a specified channel in the ATOM module.
 *
 * \param[inout] atom       Pointer to the ATOM object.
 * \param[in]    channel    Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    shadowZero Compare zero shadow value to set. Range: 0 to 0x00FFFFFF
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setCompareZeroShadow(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, uint32 shadowZero);

/**
 * \brief Sets the counter value for a specified channel in the ATOM module.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    value   New counter value to be set. Range: 0 to 0x00FFFFFF
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setCounterValue(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, uint32 value);

/**
 * \brief Sets the operating mode for a specific channel of the ATOM.
 *
 * \param[inout] atom    Pointer to the ATOM object..
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    mode    Atom operating mode to set. Range: \ref IfxGtm_Atom_Mode
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setMode(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_Mode mode);

/**
 * \brief Configures the notification settings for a specific channel in the ATOM object.
 *
 * \param[inout] atom                   Pointer to the ATOM object.d.
 * \param[in]    channel                Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    mode                   Interrupt mode to be set for the channel. Range: \ref IfxGtm_IrqMode
 * \param[in]    interruptOnCompareZero If TRUE, an interrupt is generated on compare 0, else no interrupt is generated.
 * \param[in]    interruptOnCompareOne  If TRUE, an interrupt is generated on compare 1, else no interrupt is generated.
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setNotification(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_IrqMode mode, boolean interruptOnCompareZero, boolean interruptOnCompareOne);

/**
 * \brief Configures the one shot mode for a specific channel of the ATOM instance.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    enabled Boolean flag to enable or disable the one shot mode. 
 *                       - TRUE: Enable one shot mode.
 *                       - FALSE: Disable one shot mode.
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setOneShotMode(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled);

/**
 * \brief Sets the channel channel reset source of CCU0.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    event   Reset event for the channel counter. Range: \ref IfxGtm_Atom_Ch_ResetEvent
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setResetSource(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_Ch_ResetEvent event);

/**
 * \brief Sets the signal level of a specific channel in the ATOM object.
 *
 * \param[inout] atom        Pointer to the ATOM object.
 * \param[in]    channel     Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    activeState The signal level active state. Range: \ref Ifx_ActiveState
 *
 * \retval None
 *
 * \note The signal is active between 0 and the leading edge (CM1) and inactive between the leading edge and the trailing edge (CM0).
 * If the channel is reset, the output is set to not active.
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setSignalLevel(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, Ifx_ActiveState activeState);

/**
 * \brief Sets the channel trigger output mode for the specified ATOM channel.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    trigger Trigger output mode for the channel. Range: \ref IfxGtm_Atom_Ch_OutputTrigger
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setTriggerOutput(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_Ch_OutputTrigger trigger);

/**
 * \brief Retrieves the current counter value from a specific ATOM channel.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval uint32 The current counter value of the specified ATOM channel. Range: 0 to 0x00FFFFFF
 */
IFX_EXTERN uint32 IfxGtm_Atom_Ch_getCounterValue(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/** \} */

/** \addtogroup IfxLld_Gtm_Std_Atom_AGC_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Sets the channels for update (UPEN)
 *
 * \param[inout] agc   Pointer to the AGC object.
 * \param[in]    value Value for the channel enable. Range: 0 to 0xFFFF0000
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Atom_Agc_setChannelsUpdate(Ifx_GTM_ATOM_AGC *agc, uint32 value);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Builds the register value for the feature enable/disable.
 *
 * \param[in] enableMask     Mask for the channel feature enable (bit 0: Channel 0, bit 1: channel 1, ...). Range 0 to 0xFF
 * \param[in] disableMask    Mask for the channel feature disable (bit 0: Channel 0, bit 1: channel 1, ...).Range 0 to 0xFF
 * \param[in] bitfieldOffset Offset of the channel 0 bitfield in the register. Range: 0 to 30 (multiples of 2)
 *
 * \retval uint32 The constructed 32-bit register value based on the provided masks and offset
 */
IFX_EXTERN uint32 IfxGtm_Atom_Agc_buildFeature(uint16 enableMask, uint16 disableMask, uint8 bitfieldOffset);

/**
 * \brief Builds the register value for the feature enable/disable for a single channel.
 *
 * \param[in] channel        Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in] enabled        Boolean flag to enable (TRUE) or disable (FALSE) the feature.
 * \param[in] bitfieldOffset The offset of the channel 0 bitfield in the register. Range: 0 to 30 (multiples of 2)
 *
 * \retval uint32 The constructed register value representing the feature state for the specified channel.
 */
IFX_EXTERN uint32 IfxGtm_Atom_Agc_buildFeatureForChannel(IfxGtm_Atom_Ch channel, boolean enabled, uint8 bitfieldOffset);

/**
 * \brief Enable or disable a specific channel.
 *
 * \param[inout] agc 	   Pointer to the AGC object.
 * \param[in]    channel   Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    enabled   Boolean flag to enable (TRUE) or disable (FALSE) the feature.
 * \param[in]    immediate Boolean flag to specify whether the action is taken immediately (TRUE) or deferred until the next AGC trigger (FALSE).
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Agc_enableChannel(Ifx_GTM_ATOM_AGC *agc, IfxGtm_Atom_Ch channel, boolean enabled, boolean immediate);

/**
 * \brief Enable or disable one channel output (OUTEN).
 *
 * \param[inout] agc       Pointer to the AGC object.
 * \param[in]    channel   Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    enabled   Boolean flag to enable (TRUE) or disable (FALSE) the feature.
 * \param[in]    immediate Boolean flag to specify whether the action should be performed immediately (TRUE) or deferred until the next TGC trigger (FALSE).
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Agc_enableChannelOutput(Ifx_GTM_ATOM_AGC *agc, IfxGtm_Atom_Ch channel, boolean enabled, boolean immediate);

/**
 * \brief Enable or disable a specific channel for trigger (INT_TRIGx).
 *
 * \param[inout] agc     Pointer to the AGC object.
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    enabled Boolean flag to enable (TRUE) or disable (FALSE) the trigger for the channel
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Agc_enableChannelTrigger(Ifx_GTM_ATOM_AGC *agc, IfxGtm_Atom_Ch channel, boolean enabled);

/**
 * \brief Enables or disables the specified channel for update (UPEN).
 *
 * \param[inout] agc     Pointer to the AGC object.
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    enabled Boolean flag to enable (TRUE) or disable (FALSE) the feature.
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Agc_enableChannelUpdate(Ifx_GTM_ATOM_AGC *agc, IfxGtm_Atom_Ch channel, boolean enabled);

/**
 * \brief Enable or disable one or more channels based on the provided masks.
 *
 * \param[inout] agc		 Pointer to the AGC object.
 * \param[in] 	 enableMask  Mask for the channel feature enable (bit 0: Channel 0, bit 1: channel 1, ...). Range 0 to 0xFF
 * \param[in] 	 disableMask Mask for the channel feature disable (bit 0: Channel 0, bit 1: channel 1, ...). Range 0 to 0xFF
 * \param[in] 	 immediate   If TRUE, the channel changes are applied immediately. 
 *                      	 If FALSE, the changes are applied on the next TGC trigger (CTRL_TRIG).
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Agc_enableChannels(Ifx_GTM_ATOM_AGC *agc, uint16 enableMask, uint16 disableMask, boolean immediate);

/**
 * \brief Enable or disable one or more channel outputs (OUTEN).
 *
 * \param[inout] agc 	     Pointer to the AGC object.
 * \param[in]    enableMask  Bitmask where each bit corresponds to a channel (bit 0 = Channel 0, bit 1 = Channel 1, etc.). Range 0 to 0xFF
 * \param[in]    disableMask Bitmask where each bit corresponds to a channel (bit 0 = Channel 0, bit 1 = Channel 1, etc.). Range 0 to 0xFF
 * \param[in]    immediate   Boolean flag to determine the timing of the action:
 *                     		 - TRUE: The enable/disable action is applied immediately.
 *                     		 - FALSE: The action is deferred until the next TGC trigger (CTRL_TRIG).
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Agc_enableChannelsOutput(Ifx_GTM_ATOM_AGC *agc, uint16 enableMask, uint16 disableMask, boolean immediate);

/**
 * \brief Enables or disables the AGC channels trigger functionality.
 *
 * \param[inout] agc 	     Pointer to the AGC object.
 * \param[in]    enableMask  Mask for enabling channel features (bit 0: Channel 0, bit 1: Channel 1, ...). Range 0 to 0xFF
 * \param[in]    disableMask Mask for disabling channel features (bit 0: Channel 0, bit 1: Channel 1, ...). Range 0 to 0xFF
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Agc_enableChannelsTrigger(Ifx_GTM_ATOM_AGC *agc, uint16 enableMask, uint16 disableMask);

/** 
 * \brief Enables or disables one or more channels for update (UPEN).
 *
 * \param[inout] agc 	     Pointer to the AGC object.
 * \param[in]    enableMask  Mask for the channel feature enable (bit 0: Channel 0, bit 1: channel 1, ...). Range 0 to 0xFF
 * \param[in]    disableMask Mask for the channel feature disable (bit 0: Channel 0, bit 1: channel 1, ...). Range 0 to 0xFF
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Agc_enableChannelsUpdate(Ifx_GTM_ATOM_AGC *agc, uint16 enableMask, uint16 disableMask);

/**
 * \brief Enable or disable the time base trigger.
 *
 * \param[inout] agc     Pointer to the AGC object.
 * \param[in]    enabled Boolean flag to enable (TRUE) or disable (FALSE) the time trigger.
 * 
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Agc_enableTimeTrigger(Ifx_GTM_ATOM_AGC *agc, boolean enabled);

/**
 * \brief Resets one or more channels based on the provided reset mask.
 *
 * \param[inout] agc       Pointer to the AGC object.
 * \param[in]    resetMask Bitmask specifying which channels to reset. Each bit represents a channel.(bit 0: Channel 0, bit 1: channel 1, ...). Range 0 to 0xFF
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Agc_resetChannels(Ifx_GTM_ATOM_AGC *agc, uint32 resetMask);

/**
 * \brief Enables or disables the force update feature (FUPD) for a specific channel.
 *
 * \param[inout] agc 		  Pointer to the AGC object.
 * \param[in]    channel 	  Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    enabled      Boolean flag to enable (TRUE) or disable (FALSE) the force update feature for the channel.
 * \param[in]    resetEnabled Boolean flag to enable (TRUE) or disable (FALSE) the reset feature for the channel.
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Agc_setChannelForceUpdate(Ifx_GTM_ATOM_AGC *agc, IfxGtm_Atom_Ch channel, boolean enabled, boolean resetEnabled);

/**
 * \brief Enable or disable one or more channels for the force update feature (FUPD).
 *
 * \param[inout] agc 			  Pointer to the AGC object.
 * \param[in]    enableMask  	  Mask for enabling the force update feature for specific channels (bit 0: Channel 0, bit 1: Channel 1, ...). Setting a bit to 1 enables the feature for the corresponding channel. Range 0 to 0xFF
 * \param[in]    disableMask      Mask for disabling the force update feature for specific channels (bit 0: Channel 0, bit 1: Channel 1, ...). Setting a bit to 1 disables the feature for the corresponding channel. Range 0 to 0xFF
 * \param[in]    resetEnableMask  Mask for the enabled channels counter reset on force update (bit 0: Channel 0, bit 1: Channel 1, ...). Setting a bit to 1 enables the counter reset for the corresponding channel. Range 0 to 0xFF
 * \param[in]    resetDisableMask Mask for the disabled channels with no counter reset on force update (bit 0: Channel 0, bit 1: Channel 1, ...). Setting a bit to 1 disables the counter reset for the corresponding channel. Range 0 to 0xFF
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Agc_setChannelsForceUpdate(Ifx_GTM_ATOM_AGC *agc, uint16 enableMask, uint16 disableMask, uint16 resetEnableMask, uint16 resetDisableMask);

/**
 * \brief Sets the trigger time base and time base value.
 *
 * \param[inout] agc Pointer to the AGC object.
 * \param[in] base  Time base used for comparison. Range: \ref IfxGtm_Tbu_Ts
 * \param[in] value Compare value that raises the trigger. Range: 0 to 0x00FFFFFF
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Agc_setTimeTrigger(Ifx_GTM_ATOM_AGC *agc, IfxGtm_Tbu_Ts base, uint32 value);

/**
 * \brief Raise the trigger for the channel enable/disable settings,  output enable settings, and force update event (CTRL_TRIG)
 *
 * \param[inout] agc Pointer to the AGC object.
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Agc_trigger(Ifx_GTM_ATOM_AGC *agc);

/** \} */

/** \addtogroup IfxLld_Gtm_Std_Atom_Module_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Configures the TOUT selection
 *
 * \param[in] toutNum TOUT number to configure.
 * \param[in] toutSel TOUT selection value.
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Atom_setTout(uint32 toutNum, uint32 toutSel);

/** \} */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Enables or disables the ARU input for the specified ATOM channel.
 *
 * \param[inout] atom     Pointer to the ATOM object.
 * \param[in]    channel  Index of the ATOM channel to configure. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    enabled  Boolean flag to enable (true) or disable (false) the ARU input.
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setAruInput(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled);

/**
 * \brief Sets the SOMC control bits for the specified ATOM channel.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    control The SOMC control mode to set. Range: \ref IfxGtm_Atom_SomcControl
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setSomcControl(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_SomcControl control);

/**
 * \brief Sets the SL control for SOMC mode.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]	 channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]	 ctrl	 Signal level control configuration. Range: \ref IfxGtm_Atom_SomcSignalLevelControl
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setSomcSignalLevelControl(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_SomcSignalLevelControl ctrl);

/**
 * \brief Set the SOMI ACB0 control bit.
 *
 * \param[inout] atom       Pointer to the ATOM object.
 * \param[in]    channel    Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    outputCtrl Output control. Range: \ref IfxGtm_Atom_SomiAcb0Control
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setSomiAcb0Control(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_SomiAcb0Control outputCtrl);

/**
 * \brief Set the ARU data select for SOMP mode.
 *
 * \param[inout] atom       Pointer to the ATOM object.
 * \param[in]    channel    Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    dataSelect ARU data select. Range: \ref IfxGtm_Atom_SompAruDataSelect
 *
 * \retval None
 *
 * \note This bit field is only relevant in SOMP mode to select the ARU data source.
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setSompAruDataSelect(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_SompAruDataSelect dataSelect);

/**
 * \brief Enable or disable the PCM mode in SOMP mode.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    enabled Boolean to enable PCM mode. Range: TRUE (enables PCM mode) or FASLE (disabled)
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setSompPcm(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled);

/**
 * \brief Set the Sr0_Trig for SOMP mode.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    enabled Boolean to enable Sr0_Trig. Range: If TRUE, SR0 is compared with CN0 and if both are equal, a trigger pulse is
 *                       generated at output ATOM[i]_CH[x]_OUT_T. If False,SR0 is used as a shadow register for register CM0.
 *
 * \retval None
 *
 * \note This bit is only relevant in SOMP mode.
 * This bit should only be set if RST_CCU0 of this channel is 0.
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setSompSr0Trig(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled);

/**
 * \brief Set the Shift direction for CM1 register for SOMS mode.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    dir     Shift direction. Range: \ref IfxGtm_Atom_SomsShiftDirection
 *
 * \retval None
 *
 * \note The data that has to be shifted out has to be aligned inside the CM1 register according to the defined shift direction.
 * This bit is only applicable if ARU_EN = 0.
 * If the direction (ACB0) is changed the output ATOM_OUT[x] switches immediately to the other 'first' bit of CM1 (bit 0 if ACB0 = 0, bit 23 if ACB0 = 1).
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setSomsShiftDirection(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_SomsShiftDirection dir);

/**
 * \brief Enable or disable Double Shift Output (DSO) for SOMS mode.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    enabled Boolean to enable double shift output. Range: If TRUE, CM1 is split into two 12 bit shift register. If False, CM1 is used as a 24 bit shift register.
 *
 * \retval None
 *
 * \note  If DSO=1, only shift right is possible.
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setSomsDoubleShiftOutput(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled);

/** 
 * \brief Sets the Signal Level control for SOMB mode.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    ctrl    Signal level control. Range: \ref IfxGtm_Atom_SombSignalLevelControl
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setSombSignalLevelControl(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_SombSignalLevelControl ctrl);

/**
 * \brief Sets the SOMB compare strategy.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]    channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]    compare SOMB compare strategy. Range: \ref IfxGtm_Atom_SombCompareStrategy
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setSombCompareStrategy(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_SombCompareStrategy compare);

/**
 * \brief Sets the ARU read address 0 for the specified ATOM channel.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in]	 channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in]	 addres  The 32-bit address to set for ARU read address 0. Range: 0 to 0x1FF.
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setAruReadAddress0(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, uint32 address);

/**
 * \brief Sets the ARU read address 1 for the specified ATOM channel.
 *
 * \param[inout] atom    Pointer to the ATOM object.
 * \param[in] 	 channel Channel index. Range: \ref IfxGtm_Atom_Ch
 * \param[in] 	 address The ARU read address 1 to set. Range: 0 to 0x1FF.
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Atom_Ch_setAruReadAddress1(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, uint32 address);

/**
 * \brief Returns the shadow zero value for the specified channel of the ATOM object.
 *
 * \param[in] atom    Pointer to the ATOM object.
 * \param[in] channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval uint32 Shadow zero value of the specified channel. Range: 0 to 0x00FFFFFF
 */
IFX_EXTERN uint32 IfxGtm_Atom_getShadowZero(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Returns a pointer to the shadow zero register for the specified channel.
 *
 * \param[in] atom    Pointer to the ATOM object.
 * \param[in] channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval uint32* Pointer to the shadow zero register of the specified channel.
 */
IFX_EXTERN volatile uint32 *IfxGtm_Atom_getShadowZeroPointer(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Retrieves the shadow one value from the ATOM object for the specified channel.
 *
 * \param[in] atom    Pointer to the ATOM object.
 * \param[in] channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval uint32 The shadow one value of the specified channel. Range: 0 to 0x00FFFFFF
 */
IFX_EXTERN uint32 IfxGtm_Atom_getShadowOne(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Returns the shadow One pointer for the specified ATOM channel.
 *
 * \param[in] atom    Pointer to the ATOM object.
 * \param[in] channel Channel index. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval uint32* Pointer to the shadow One register.
 */
IFX_EXTERN volatile uint32 *IfxGtm_Atom_getShadowOnePointer(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE Ifx_GTM_ATOM_CH *IfxGtm_Atom_Ch_getChannelPointer(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel)
{
    return (Ifx_GTM_ATOM_CH *)((uint32)&atom->CH0.RDADDR.U + 0x80 * channel);
}


IFX_INLINE void IfxGtm_Atom_Ch_setCompareShadow(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, uint32 shadowZero, uint32 shadowOne)
{
    Ifx_GTM_ATOM_CH *atomCh = IfxGtm_Atom_Ch_getChannelPointer(atom, channel);

    atomCh->SR0.U = shadowZero; 
    atomCh->SR1.U = shadowOne;
}


IFX_INLINE void IfxGtm_Atom_Ch_setExtendClockSource(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled)
{
	Ifx_GTM_ATOM_CH *atomCh = IfxGtm_Atom_Ch_getChannelPointer(atom, channel);

	atomCh->CTRL.B.ECLK_SRC = (uint8)enabled;
}


IFX_INLINE void IfxGtm_Atom_Ch_setTriggerPulseLength(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_Ch_TriggerOutputPulseLength pulseLength)
{
	Ifx_GTM_ATOM_CH *atomCh = IfxGtm_Atom_Ch_getChannelPointer(atom, channel);

	atomCh->CTRL.B.TRIG_PULSE = (uint8)pulseLength;
}


IFX_INLINE void IfxGtm_Atom_Ch_setCounterMode(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_Ch_CounterMode counterMode)
{
	Ifx_GTM_ATOM_CH *atomCh = IfxGtm_Atom_Ch_getChannelPointer(atom, channel);

	atomCh->CTRL.B.UDMODE = (uint8)counterMode;
}


IFX_INLINE void IfxGtm_Atom_Ch_setOsmTrigger(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled)
{
	Ifx_GTM_ATOM_CH *atomCh = IfxGtm_Atom_Ch_getChannelPointer(atom, channel);

	atomCh->CTRL.B.OSM_TRIG = (uint8)enabled;
}


IFX_INLINE void IfxGtm_Atom_Ch_setExtTriggerSignal(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_Ch_TriggerSignal trigger)
{
    Ifx_GTM_ATOM_CH *atomCh = IfxGtm_Atom_Ch_getChannelPointer(atom, channel);

    atomCh->CTRL.B.EXT_TRIG = (uint8)trigger;
}


IFX_INLINE void IfxGtm_Atom_Ch_setExtTriggerOutput(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_Ch_TriggerSignal trigger)
{
    Ifx_GTM_ATOM_CH *atomCh = IfxGtm_Atom_Ch_getChannelPointer(atom, channel);

    atomCh->CTRL.B.EXTTRIGOUT = (uint8)trigger;
}


IFX_INLINE void IfxGtm_Atom_Ch_setFreeze(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled)
{
    Ifx_GTM_ATOM_CH *atomCh = IfxGtm_Atom_Ch_getChannelPointer(atom, channel);

    atomCh->CTRL.B.FREEZE = (uint8)enabled;
}


IFX_INLINE void IfxGtm_Atom_Ch_setTimeBaseValue(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_Ch_TimeBaseValue timeBase)
{
	Ifx_GTM_ATOM_CH *atomCh = IfxGtm_Atom_Ch_getChannelPointer(atom, channel);

    atomCh->CTRL.B.TB12_SEL = (uint8)timeBase;
}


IFX_INLINE void IfxGtm_Atom_Ch_setCompareStrategy(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_Ch_CompareStrategy compareStrategy)
{
	Ifx_GTM_ATOM_CH *atomCh = IfxGtm_Atom_Ch_getChannelPointer(atom, channel);

    atomCh->CTRL.B.CMP_CTRL = (uint8)compareStrategy;
}


IFX_INLINE void IfxGtm_Atom_Ch_setExtendedUpdateMode(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled)
{
	Ifx_GTM_ATOM_CH *atomCh = IfxGtm_Atom_Ch_getChannelPointer(atom, channel);

    atomCh->CTRL.B.EUPM = (uint8)enabled;
}


IFX_INLINE void IfxGtm_Atom_Ch_setLateCompareRegisterUpdate(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled)
{
	Ifx_GTM_ATOM_CH *atomCh = IfxGtm_Atom_Ch_getChannelPointer(atom, channel);

    atomCh->CTRL.B.WR_REQ = (uint8)enabled;
}


IFX_INLINE void IfxGtm_Atom_Ch_setSlaStrategy(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, IfxGtm_Atom_Ch_SlaStrategy slaStrategy)
{
	Ifx_GTM_ATOM_CH *atomCh = IfxGtm_Atom_Ch_getChannelPointer(atom, channel);

    atomCh->CTRL.B.SLA = (uint8)slaStrategy;
}


IFX_INLINE void IfxGtm_Atom_Ch_setAruBlockingMode(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled)
{
	Ifx_GTM_ATOM_CH *atomCh = IfxGtm_Atom_Ch_getChannelPointer(atom, channel);

    atomCh->CTRL.B.ABM = (uint8)enabled;
}


IFX_INLINE void IfxGtm_Atom_Ch_setSombMode(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled)
{
	Ifx_GTM_ATOM_CH *atomCh = IfxGtm_Atom_Ch_getChannelPointer(atom, channel);

    atomCh->CTRL.B.SOMB = (uint8)enabled;
}


IFX_INLINE void IfxGtm_Atom_Ch_setExtForceUpdate(Ifx_GTM_ATOM *atom, IfxGtm_Atom_Ch channel, boolean enabled)
{
	Ifx_GTM_ATOM_CH *atomCh = IfxGtm_Atom_Ch_getChannelPointer(atom, channel);

    atomCh->CTRL.B.EXT_FUPD = (uint8)enabled;
}


IFX_INLINE void IfxGtm_Atom_Agc_setChannelsUpdate(Ifx_GTM_ATOM_AGC *agc, uint32 value)
{
    agc->GLB_CTRL.U = value;
}


IFX_INLINE void IfxGtm_Atom_setTout(uint32 toutNum, uint32 toutSel)
{
    uint32 outselReg = (toutNum >> 3);
    uint32 shift     = (toutNum & 0x7U) * 4;
    uint32 outsel    = toutSel << shift;
    uint32 mask      = 0xFU << shift;

    __ldmst_c(&(MODULE_GTM.TOUTSEL[outselReg].U), mask, outsel);
}


#endif /* IFXGTM_ATOM_H */
