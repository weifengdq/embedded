/**
 * \file IfxGpt12_IncrEnc.c
 * \brief GPT12 INCRENC details
 *
 * \version iLLD_1_20_0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxGpt12_IncrEnc.h"

/******************************************************************************/
/*-----------------------Private Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Update internal data when incremental mode is using T2.\n
 * This function shall be periodically called
 * \param driver driver handle
 * \return None
 */
IFX_STATIC void IfxGpt12_IncrEnc_updateFromT2(IfxGpt12_IncrEnc *driver);

/** \brief Update internal data when incremental mode is using T3.\n
 * This function shall be periodically called
 * \param driver driver handle
 * \return None
 */
IFX_STATIC void IfxGpt12_IncrEnc_updateFromT3(IfxGpt12_IncrEnc *driver);

/** \brief Updates the speed
 * \param driver driver handle
 * \param newPosition new position
 * \return None
 */
IFX_STATIC void IfxGpt12_IncrEnc_updateSpeed(IfxGpt12_IncrEnc *driver, sint32 newPosition);

/** \brief Updates the speed
 * \param driver driver handle
 * \param newPosition new position
 * \return None
 */
IFX_STATIC void IfxGpt12_IncrEnc_updateSpeedFromT3(IfxGpt12_IncrEnc *driver, sint32 newPosition);

/** \brief Update internal data when incremental mode is using T4.\n
 * This function shall be periodically called
 * \param driver driver handle
 * \return None
 */
IFX_STATIC void IfxGpt12_IncrEnc_updateFromT4(IfxGpt12_IncrEnc *driver);

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

float32 IfxGpt12_IncrEnc_getAbsolutePosition(IfxGpt12_IncrEnc *driver)
{
    return ((float32)driver->turn + (float32)driver->rawPosition / (float32)driver->resolution) * 2.0f * IFX_PI;
}


IfxGpt12_IncrEnc_Direction IfxGpt12_IncrEnc_getDirection(IfxGpt12_IncrEnc *driver)
{
    return driver->direction;
}


sint32 IfxGpt12_IncrEnc_getOffset(IfxGpt12_IncrEnc *driver)
{
    return driver->offset;
}


float32 IfxGpt12_IncrEnc_getPosition(IfxGpt12_IncrEnc *driver)
{
    return (float32)driver->rawPosition * driver->positionConst;
}


sint32 IfxGpt12_IncrEnc_getRawPosition(IfxGpt12_IncrEnc *driver)
{
    return driver->rawPosition;
}


float32 IfxGpt12_IncrEnc_getRefreshPeriod(IfxGpt12_IncrEnc *driver)
{
    return driver->updatePeriod;
}


sint32 IfxGpt12_IncrEnc_getResolution(IfxGpt12_IncrEnc *driver)
{
    return driver->resolution;
}


float32 IfxGpt12_IncrEnc_getSpeed(IfxGpt12_IncrEnc *driver)
{
    return driver->speed;
}


sint32 IfxGpt12_IncrEnc_getTurn(IfxGpt12_IncrEnc *driver)
{
    return driver->turn;
}


boolean IfxGpt12_IncrEnc_init(IfxGpt12_IncrEnc *driver, const IfxGpt12_IncrEnc_Config *config)
{
    boolean         status = TRUE;
    /* Get the GPT12 module base address */
    Ifx_GPT12      *gpt12  = config->module;
    Ifx_GPT12_T3CON t3Con;
    Ifx_GPT12_T4CON t4Con;
    Ifx_GPT12_T5CON t5Con;
    Ifx_GPT12_T2CON t2Con;

    driver->module             = gpt12;

    /* Initialize the offset and resolution */
    driver->offset             = config->offset;
    driver->resolution         = config->resolution * config->resolutionFactor;
    /* Initialize the position constant */
    driver->positionConst      = 1.0f / (float32)driver->resolution * 2.0f * IFX_PI;
    /* Initialize the speed mode threshold */
    driver->speedModeThreshold = config->speedModeThreshold;
    /* Initialize the refresh period */
    IfxGpt12_IncrEnc_setRefreshPeriod(driver, config->updatePeriod);

    /* Initialize synchronization and speed limits */
    driver->notSynchronised = 1;
    driver->minSpeed        = config->minSpeed;
    driver->maxSpeed        = config->maxSpeed;

    /* Initialize position, speed, direction, and turn count */
    driver->rawPosition     = 0;
    driver->speed           = 0;
    driver->direction       = IfxGpt12_IncrEnc_Direction_unknown;
    driver->turn            = 0;

    /* Reading register */
    t3Con.U = gpt12->T3CON.U;
    t4Con.U = gpt12->T4CON.U;
    t5Con.U = gpt12->T5CON.U;
    t2Con.U = gpt12->T2CON.U;

    if (config->pinA->timer == 3)
    {
        /* T3 Configuration */
        switch (config->resolutionFactor)
        {
        case IfxGpt12_IncrEnc_ResolutionFactor_twoFold:
            t3Con.B.T3I = IfxGpt12_IncrementalInterfaceInputMode_bothEdgesTxIN;
            break;
        case IfxGpt12_IncrEnc_ResolutionFactor_fourFold:
            t3Con.B.T3I = IfxGpt12_IncrementalInterfaceInputMode_bothEdgesTxINOrTxEUD;
            break;
        default:
            status = FALSE;
            break;
        }

        t3Con.B.T3M   = IfxGpt12_Mode_incrementalInterfaceRotationDetection;
        t3Con.B.T3UDE = IfxGpt12_TimerDirectionSource_external;                                        /* Direction control external */
        t3Con.B.T3UD  = config->reversed ? IfxGpt12_TimerDirection_down : IfxGpt12_TimerDirection_up;  /* Direction */
        t3Con.B.T3OE  = 0u;
        t3Con.B.T3R   = IfxGpt12_TimerRun_start;

        if (config->pinZ != NULL_PTR)
        {                       /* Only configure T4 if zero signal is available. Zero has to be on T4IN  */
            /* T4 Configuration */
            t4Con.B.T4M     = IfxGpt12_Mode_capture;
            t4Con.B.T4I     = IfxGpt12_CaptureInputMode_risingEdgeTxIN;
            t4Con.B.CLRT2EN = 0u;
            t4Con.B.CLRT3EN = 1u;
            t4Con.B.T4IRDIS = (config->zeroIsrPriority != 0u) ? 0u : 1u;
            t4Con.B.T4RC    = IfxGpt12_TimerRemoteControl_off;
            t4Con.B.T4R     = IfxGpt12_TimerRun_stop;

            if (config->zeroIsrPriority)
            {
                /* setup interrupt */
                volatile Ifx_SRC_SRCR *src = IfxGpt12_T4_getSrc(gpt12);
                IfxSrc_init(src, config->zeroIsrProvider, config->zeroIsrPriority);
                IfxSrc_enable(src);
            }
        }

        /* T5 Configuration */
        t5Con.B.T5M    = IfxGpt12_Mode_timer;
        t5Con.B.T5I    = IfxGpt12_CounterInputMode_bothEdgesTxIN;
        t5Con.B.CT3    = IfxGpt12_CaptureTrigger_t3inOrT3EUD;
        t5Con.B.CI     = IfxGpt12_CaptureTriggerMode_risingEdge;
        t5Con.B.T5CLR  = 1u;
        t5Con.B.T5SC   = 1u;
        t5Con.B.T5RC   = IfxGpt12_TimerRemoteControl_off;
        t5Con.B.T5UDE  = IfxGpt12_TimerDirectionSource_internal;
        t5Con.B.T5UD   = IfxGpt12_TimerDirection_up;
        t5Con.B.T5R    = IfxGpt12_TimerRun_start;
        gpt12->T5CON.U = t5Con.U;

        driver->update = (IfxGpt12_IncrEnc_Update) & IfxGpt12_IncrEnc_updateFromT3;
    }
    else if (config->pinA->timer == 2)
    {
        switch (config->resolutionFactor)
        {
        case IfxGpt12_IncrEnc_ResolutionFactor_twoFold:
            t2Con.B.T2I = IfxGpt12_IncrementalInterfaceInputMode_bothEdgesTxIN;
            break;
        case IfxGpt12_IncrEnc_ResolutionFactor_fourFold:
            t2Con.B.T2I = IfxGpt12_IncrementalInterfaceInputMode_bothEdgesTxINOrTxEUD;
            break;
        default:
            status = FALSE;
            break;
        }

        /* T2 Configuration */
        t2Con.B.T2M     = IfxGpt12_Mode_incrementalInterfaceEdgeDetection;
        t2Con.B.T2UDE   = IfxGpt12_TimerDirectionSource_external;
        t2Con.B.T2UD    = config->reversed ? IfxGpt12_TimerDirection_down : IfxGpt12_TimerDirection_up;
        t2Con.B.T2R     = IfxGpt12_TimerRun_start;
        t2Con.B.T2IRDIS = 1u;

        if (config->pinZ != NULL_PTR)
        {                       /* Only configure T4 if zero signal is available. Zero has to be on T4EUD  */
            /* T4 Configuration */
            t4Con.B.T4M     = IfxGpt12_Mode_capture;
            t4Con.B.T4I     = IfxGpt12_CaptureInputMode_none;
            t4Con.B.CLRT2EN = 1u;
            t4Con.B.CLRT3EN = 0u;
            t4Con.B.T4IRDIS = 0u;
            t4Con.B.T4RC    = IfxGpt12_TimerRemoteControl_off;
            t4Con.B.T4R     = IfxGpt12_TimerRun_stop;
        }

        driver->update = (IfxGpt12_IncrEnc_Update) & IfxGpt12_IncrEnc_updateFromT2;
    }
    else if (config->pinA->timer == 4)
    {
        switch (config->resolutionFactor)
        {
        case IfxGpt12_IncrEnc_ResolutionFactor_twoFold:
            t4Con.B.T4I = IfxGpt12_IncrementalInterfaceInputMode_bothEdgesTxIN;
            break;
        case IfxGpt12_IncrEnc_ResolutionFactor_fourFold:
            t4Con.B.T4I = IfxGpt12_IncrementalInterfaceInputMode_bothEdgesTxINOrTxEUD;
            break;
        default:
            status = FALSE;
            break;
        }

        /* T4 Configuration */
        t4Con.B.T4M     = IfxGpt12_Mode_incrementalInterfaceEdgeDetection;
        t4Con.B.T4UDE   = IfxGpt12_TimerDirectionSource_external;
        t4Con.B.T4UD    = config->reversed ? IfxGpt12_TimerDirection_down : IfxGpt12_TimerDirection_up;
        t4Con.B.T4R     = IfxGpt12_TimerRun_start;
        t4Con.B.T4IRDIS = 1u;

        driver->update  = (IfxGpt12_IncrEnc_Update) & IfxGpt12_IncrEnc_updateFromT4;
    }

    /* speedConstTimeDiff = (2 * PI * T5Freq) / (resolution * 2)*/
    driver->speedConstTimeDiff =
        (IFX_PI * IfxGpt12_T5_getFrequency(gpt12)) / (config->resolution);

    /* Writing register back */
    gpt12->T3CON.U = t3Con.U;
    gpt12->T4CON.U = t4Con.U;
    gpt12->T2CON.U = t2Con.U;

    if (config->initPins == TRUE)
    {
        IfxGpt12_initTxInPinWithPadLevel(config->pinA, config->pinMode, config->pinDriver);
        IfxGpt12_initTxEudInPinWithPadLevel(config->pinB, config->pinMode, config->pinDriver);

        if (config->pinZ != NULL_PTR)
        {
            IfxGpt12_initTxInPinWithPadLevel(config->pinZ, config->pinMode, config->pinDriver);
        }
    }

    return status;
}


void IfxGpt12_IncrEnc_initConfig(IfxGpt12_IncrEnc_Config *config, Ifx_GPT12 *gpt12)
{
	/* Initializes the configuration structure to default */
    config->offset             = 0;
    config->reversed           = FALSE;
    config->resolution         = 0;
    config->resolutionFactor   = IfxGpt12_IncrEnc_ResolutionFactor_twoFold;
    config->updatePeriod       = 0.001f;
    config->speedModeThreshold = 0;
    config->minSpeed           = 1.0f / 60.0f * (2 * IFX_PI);                 // 1 rpm
    config->maxSpeed           = 20000.0f / 60.0f * (2 * IFX_PI);             // 20000 rpm
    config->pinA               = NULL_PTR;
    config->pinB               = NULL_PTR;
    config->pinZ               = NULL_PTR;
    config->pinMode            = IfxPort_InputMode_noPullDevice;
    config->module             = gpt12;
    config->zeroIsrPriority    = 0;
    config->zeroIsrProvider    = IfxSrc_Tos_cpu0;
    config->pinDriver          = IfxPort_PadDriver_cmosAutomotiveSpeed1;

    config->initPins           = TRUE;
}


void IfxGpt12_IncrEnc_onZeroIrq(IfxGpt12_IncrEnc *driver)
{
    if (driver->notSynchronised)
    {
        driver->notSynchronised = 0;
    }

    if (driver->direction == IfxGpt12_IncrEnc_Direction_forward)
    {
        driver->turn++;
    }
    else
    {
        driver->turn--;
    }
}


void IfxGpt12_IncrEnc_reset(IfxGpt12_IncrEnc *driver)
{
    driver->rawPosition     = 0;
    driver->turn            = 0;
    driver->speed           = 0;
    driver->notSynchronised = 1;
}


void IfxGpt12_IncrEnc_setOffset(IfxGpt12_IncrEnc *driver, sint32 offset)
{
    driver->offset          = offset;
    driver->notSynchronised = 0;
}


void IfxGpt12_IncrEnc_setRefreshPeriod(IfxGpt12_IncrEnc *driver, float32 updatePeriod)
{
    driver->updatePeriod           = updatePeriod;
    driver->speedConstPulseCount   = (2.0f * IFX_PI) / driver->resolution / updatePeriod;
    driver->speedModeThresholdTick = driver->speedModeThreshold * driver->resolution * updatePeriod / (2.0f * IFX_PI);
}


void IfxGpt12_IncrEnc_update(IfxGpt12_IncrEnc *driver)
{
    driver->update(driver);
}


IFX_STATIC void IfxGpt12_IncrEnc_updateFromT2(IfxGpt12_IncrEnc *driver)
{
    Ifx_GPT12 *gpt12 = driver->module;
    sint32     newPosition;
    /* Determine the direction based on the T2RDIR bit */
    driver->direction = gpt12->T2CON.B.T2RDIR ? IfxGpt12_IncrEnc_Direction_backward : IfxGpt12_IncrEnc_Direction_forward;

    newPosition       = gpt12->T2.U;

    newPosition       = (newPosition + driver->offset);

    if (newPosition >= driver->resolution)
    {
        newPosition %= driver->resolution;
    }
    else if (newPosition < 0)
    {
        newPosition = (newPosition + driver->resolution);
    }

    /* Update the speed based on the new position */
    IfxGpt12_IncrEnc_updateSpeed(driver, newPosition);
    driver->rawPosition = newPosition;
}


IFX_STATIC void IfxGpt12_IncrEnc_updateFromT3(IfxGpt12_IncrEnc *driver)
{
    Ifx_GPT12 *gpt12 = driver->module;
    sint32     newPosition;
    /* Determine the direction based on the T3RDIR bit */
    driver->direction = gpt12->T3CON.B.T3RDIR ? IfxGpt12_IncrEnc_Direction_backward : IfxGpt12_IncrEnc_Direction_forward;

    newPosition       = gpt12->T3.U;

    newPosition       = (newPosition + driver->offset);

    if (newPosition >= driver->resolution)
    {
        newPosition %= driver->resolution;
    }
    else if (newPosition < 0)
    {
        newPosition = (newPosition + driver->resolution);
    }

    /* Update the speed based on the new position */
    IfxGpt12_IncrEnc_updateSpeedFromT3(driver, newPosition);
    driver->rawPosition = newPosition;
}


IFX_STATIC void IfxGpt12_IncrEnc_updateSpeed(IfxGpt12_IncrEnc *driver, sint32 newPosition)
{
    float32 speed;
    sint32  diff;

    if (driver->direction == IfxGpt12_IncrEnc_Direction_forward)
    {
    	/* Calculate the position difference for forward direction */
        diff = newPosition - driver->rawPosition;
    }
    else
    {
    	/* Calculate the position difference for backward direction */
        diff = driver->rawPosition - newPosition;
    }

    /* If the difference is negative, adjust it to wrap around the resolution */
    if (diff < 0)
    {
        diff += driver->resolution;
    }

    /* Calculate the speed using the position difference and the speed constant */
    speed         = diff * driver->speedConstPulseCount;

    /* Adjust the speed based on the direction of rotation */
    speed         = driver->direction == IfxGpt12_IncrEnc_Direction_forward ? speed : -speed;

    /* Update the driver's speed with the calculated value */
    driver->speed = speed;
}


IFX_STATIC void IfxGpt12_IncrEnc_updateSpeedFromT3(IfxGpt12_IncrEnc *driver, sint32 newPosition)
{
    float32 speed;
    sint32  diff;

    if (driver->direction == IfxGpt12_IncrEnc_Direction_forward)
    {
    	/* Calculate the position difference for forward direction */
        diff = newPosition - driver->rawPosition;
    }
    else
    {
    	/* Calculate the position difference for backward direction */
        diff = driver->rawPosition - newPosition;
    }

    /* If the difference is negative, adjust it to wrap around the resolution */
    if (diff < 0)
    {
        diff += driver->resolution;
    }

    /* Check if the difference exceeds the speed mode threshold */
    if (diff > driver->speedModeThresholdTick)
    {                           /* Use pulse count mode ( Fast speed ) */
        speed = diff * driver->speedConstPulseCount;
    }
    else
    {                           /* Use time diff mode (slow speed), only if T3 is used as core */
        Ifx_GPT12             *gpt12 = driver->module;
        volatile Ifx_SRC_SRCR *srcT5 = IfxGpt12_T5_getSrc(gpt12);

        if (srcT5->B.SRR != 1)
        {                       // NO overflow of T5
            volatile Ifx_SRC_SRCR *srcCap = IfxGpt12_getCaptureSrc(gpt12);

            // Check if a new value is captured
            if (srcCap->B.SRR != 0)
            {
                // Delete Capture Request Bit
                srcCap->B.CLRR = 1;
                speed          = driver->speedConstTimeDiff / gpt12->CAPREL.B.CAPREL;
            }
            else
            {
                speed = driver->speed;
            }
        }
        else
        {                       // T5 overflow detected
            // Delete Overflow Request bit
            srcT5->B.CLRR = 1;
            speed         = 0.0f;
        }
    }

    speed         = driver->direction == IfxGpt12_IncrEnc_Direction_forward ? speed : -speed;

    driver->speed = speed;
}


IFX_STATIC void IfxGpt12_IncrEnc_updateFromT4(IfxGpt12_IncrEnc *driver)
{
    Ifx_GPT12 *gpt12 = driver->module;
    sint32     newPosition;
    /* Determine the direction based on the T4RDIR bit */
    driver->direction = gpt12->T4CON.B.T4RDIR ? IfxGpt12_IncrEnc_Direction_backward : IfxGpt12_IncrEnc_Direction_forward;

    newPosition       = gpt12->T4.U;

    newPosition       = (newPosition + driver->offset);

    if (newPosition >= driver->resolution)
    {
        newPosition %= driver->resolution;
    }
    else if (newPosition < 0)
    {
        newPosition = (newPosition + driver->resolution);
    }

    /* Update the speed based on the new position */
    IfxGpt12_IncrEnc_updateSpeed(driver, newPosition);
    driver->rawPosition = newPosition;
}
