/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the
 *company in which ordinary course of business you are acting and (ii) Infineon
 *Technologies AG or its licensees. If and as long as no such terms of use are
 *agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 *obtaining a copy of the software and accompanying documentation covered by
 *this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software,
 *and to permit third-parties to whom the Software is furnished to do so, all
 *subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 *the above license grant, this restriction and the following disclaimer, must
 *be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 *solely in the form of machine-executable object code generated by a source
 *language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR
 *ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *DEALINGS IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "IfxCan.h"
#include "IfxCan_Can.h"
#include "IfxCpu.h"
#include "IfxCpu_Irq.h"
#include "IfxPort.h"
#include "IfxScuWdt.h"
#include "Ifx_Cfg_Ssw.h"
#include "Ifx_Types.h"

IFX_ALIGN(4) IfxCpu_syncEvent cpuSyncEvent = 0;

#define CAN_PRIORITY 110
#define STD_FILTER_NUM 1
#define EXT_FILTER_NUM 1

// channel 0~7
typedef enum {
  CAN0 = 0,
  CAN1,
  CAN2,
  CAN3,
  CAN4,
  CAN5,
  CAN6,
  CAN7,
  CAN_NUM
} canChannel;

// clang-format off
static const IfxCan_Can_Pins can_pins[CAN_NUM] = {
    {&IfxCan_TXD00_P02_0_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD00A_P02_1_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD01_P33_9_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD01D_P33_10_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD02_P15_0_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD02A_P15_1_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD03_P20_10_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD03E_P20_9_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD10_P00_0_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD10A_P00_1_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD11_P00_4_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD11B_P00_5_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD12_P20_7_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD12A_P20_6_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD13_P33_4_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD13B_P33_5_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
};
// clang-format on

static IfxCan_Filter can_std_default_filter[CAN_NUM][STD_FILTER_NUM] = {{
    {.number = 0,
     .elementConfiguration = IfxCan_FilterElementConfiguration_storeInRxFifo0,
     .type = IfxCan_FilterType_classic,
     .id1 = 0,
     .id2 = 0,
     .rxBufferOffset = IfxCan_RxBufferId_0},
}};
static IfxCan_Filter can_ext_default_filter[CAN_NUM][EXT_FILTER_NUM] = {{
    {.number = 0,
     .elementConfiguration = IfxCan_FilterElementConfiguration_storeInRxFifo0,
     .type = IfxCan_FilterType_classic,
     .id1 = 0,
     .id2 = 0,
     .rxBufferOffset = IfxCan_RxBufferId_0},
}};

typedef struct {
  canChannel channel;
  IfxCan_Can_Config config;         /* CAN module configuration structure */
  IfxCan_Can module;                /* CAN module handle                  */
  IfxCan_Can_Node node;             /* CAN node handle data structure     */
  IfxCan_Can_NodeConfig nodeConfig; /* CAN node configuration structure   */
  IfxCan_Filter filter;             /* CAN filter configuration structure */
  IfxCan_Message txMsg;             /* Transmitted CAN message structure  */
  IfxCan_Message rxMsg;             /* Received CAN message structure     */
  uint8 txData[64];                 /* Transmitted CAN data array         */
  uint8 rxData[64];                 /* Received CAN data array            */
  boolean busOff;                   /* Bus off status                     */
  void (*can_rx_callback)(canChannel channel, IfxCan_Message *msg);
  void (*can_tx_callback)(canChannel channel, IfxCan_Message *msg);
  void (*can_error_callback)(canChannel channel, IfxCan_Message *msg);
} mcmcanType;

mcmcanType can[2];

/* 记录物理 CAN 模块是否已经初始化，避免重复调用 IfxCan_Can_initModule */
static boolean g_canModuleInitialized[2] = {FALSE, FALSE};

#define CAN_RX_ISR(x, tos, priority)                                           \
  IFX_INTERRUPT(isr_canrx_##x, tos, priority);                                 \
  void isr_canrx_##x(void) {                                                   \
    while (IfxCan_Can_getRxFifo0FillLevel(&can[x].node)) {                     \
      IfxCan_Node_clearInterruptFlag(can[x].node.node,                         \
                                     IfxCan_Interrupt_rxFifo0NewMessage);      \
      can[x].rxMsg.readFromRxFifo0 = TRUE;                                     \
      IfxCan_Can_readMessage(&can[x].node, &can[x].rxMsg,                      \
                             (uint32 *)&can[x].rxData);                        \
      if (can[x].can_rx_callback != NULL) {                                    \
        can[x].can_rx_callback(can[x].channel, &can[x].rxMsg);                 \
      }                                                                        \
    }                                                                          \
  }

#define CAN_TX_ISR(x, tos, priority)                                           \
  IFX_INTERRUPT(isr_cantx_##x, tos, priority);                                 \
  void isr_cantx_##x(void) {                                                   \
    IfxCan_Node_clearInterruptFlag(can[x].node.node,                           \
                                   IfxCan_Interrupt_transmissionCompleted);    \
    if (can[x].can_tx_callback != NULL) {                                      \
      can[x].can_tx_callback(can[x].channel, &can[x].txMsg);                   \
    }                                                                          \
  }

#define CAN_BUSOFF_ISR(x, tos, priority)                                       \
  IFX_INTERRUPT(isr_canbo_##x, tos, priority);                                 \
  void isr_canbo_##x(void) {                                                   \
    IfxCan_Node_clearInterruptFlag(can[x].node.node,                           \
                                   IfxCan_Interrupt_busOffStatus);             \
    can[x].busOff = TRUE;                                                      \
    if (can[x].can_error_callback != NULL) {                                   \
      can[x].can_error_callback(can[x].channel, NULL);                         \
    }                                                                          \
  }

CAN_RX_ISR(0, 0, CAN_PRIORITY + 0);
CAN_TX_ISR(0, 0, CAN_PRIORITY + CAN_NUM + 0);
CAN_BUSOFF_ISR(0, 0, CAN_PRIORITY + 2 * CAN_NUM + 0);
CAN_RX_ISR(1, 0, CAN_PRIORITY + 1);
CAN_TX_ISR(1, 0, CAN_PRIORITY + CAN_NUM + 1);
CAN_BUSOFF_ISR(1, 0, CAN_PRIORITY + 2 * CAN_NUM + 1);

static uint8 dlc2len[16] = {0, 1,  2,  3,  4,  5,  6,  7,
                            8, 12, 16, 20, 24, 32, 48, 64};

// can0 rx callback, 把收到的帧全部转发到can1
void can0_rx_callback(canChannel channel, IfxCan_Message *msg) {
  // copy data to can1 tx buffer
  (void)channel;
  uint8 len = dlc2len[msg->dataLengthCode];
  for (uint8 i = 0; i < len; i++) {
    can[1].txData[i] = can[0].rxData[i];
  }
  can[1].txMsg = *msg;
  if (!IfxCan_Can_isTxFifoQueueFull(&can[1].node)) {
    while (IfxCan_Can_sendMessage(&can[1].node, &can[1].txMsg,
                                  (uint32 *)can[1].txData) != IfxCan_Status_ok)
      ;
  }
  // 或者不copy，直接转发rxMsg ?
}

void init_can(mcmcanType *dev, canChannel channel, uint16 npre, uint8 ntseg1,
              uint8 ntseg2, uint16 dpre, uint8 dtseg1, uint8 dtseg2) {
  /* 根据 channel 选择物理模块: 0-3 -> MODULE_CAN0, 4-7 -> MODULE_CAN1 */
  uint8 group = (channel < CAN4) ? 0 : 1;
  Ifx_CAN *modulePtr = (group == 0) ? &MODULE_CAN0 : &MODULE_CAN1;

  /* 只对同一物理 CAN 模块初始化一次，防止后续节点重复 initModule 影响已配置节点 */
  if (!g_canModuleInitialized[group]) {
    IfxCan_Can_initModuleConfig(&dev->config, modulePtr);
    IfxCan_Can_initModule(&dev->module, &dev->config);
    g_canModuleInitialized[group] = TRUE;
  } else {
    /* 复用已初始化模块句柄（使用组内第一个节点的 module 结构体） */
    dev->module = can[(group == 0) ? CAN0 : CAN4].module;
  }

  IfxCan_Can_initNodeConfig(&dev->nodeConfig, &dev->module);

  // clang-format off
  dev->channel = channel;

  dev->nodeConfig.nodeId = (IfxCan_NodeId)(channel % 4);
  dev->nodeConfig.clockSource = IfxCan_ClockSource_both;
  dev->nodeConfig.frame.type = IfxCan_FrameType_transmitAndReceive;
  dev->nodeConfig.frame.mode = IfxCan_FrameMode_fdLongAndFast;

  /* Tx configuration */
  dev->nodeConfig.txConfig.txMode = IfxCan_TxMode_fifo;
  dev->nodeConfig.txConfig.dedicatedTxBuffersNumber = 0;
  dev->nodeConfig.txConfig.txFifoQueueSize = 32;
  dev->nodeConfig.txConfig.txBufferDataFieldSize = IfxCan_DataFieldSize_64;
  dev->nodeConfig.txConfig.txEventFifoSize = 0;

  /* Filter configuration */
  dev->nodeConfig.filterConfig.messageIdLength = IfxCan_MessageIdLength_both;
  dev->nodeConfig.filterConfig.standardListSize = 32;
  dev->nodeConfig.filterConfig.extendedListSize = 32;
  dev->nodeConfig.filterConfig.rejectRemoteFramesWithStandardId = TRUE;
  dev->nodeConfig.filterConfig.rejectRemoteFramesWithExtendedId = TRUE;
  dev->nodeConfig.filterConfig.standardFilterForNonMatchingFrames = IfxCan_NonMatchingFrame_reject;
  dev->nodeConfig.filterConfig.extendedFilterForNonMatchingFrames = IfxCan_NonMatchingFrame_reject;

  /* Rx configuration */
  dev->nodeConfig.rxConfig.rxMode = IfxCan_RxMode_fifo0;
  dev->nodeConfig.rxConfig.rxBufferDataFieldSize = IfxCan_DataFieldSize_64;
  dev->nodeConfig.rxConfig.rxFifo0DataFieldSize = IfxCan_DataFieldSize_64;
  dev->nodeConfig.rxConfig.rxFifo1DataFieldSize = IfxCan_DataFieldSize_64;
  dev->nodeConfig.rxConfig.rxFifo0OperatingMode = IfxCan_RxFifoMode_overwrite;
  dev->nodeConfig.rxConfig.rxFifo1OperatingMode = IfxCan_RxFifoMode_overwrite;
  dev->nodeConfig.rxConfig.rxFifo0WatermarkLevel = 0;
  dev->nodeConfig.rxConfig.rxFifo1WatermarkLevel = 0;
  dev->nodeConfig.rxConfig.rxFifo0Size = 16;
  dev->nodeConfig.rxConfig.rxFifo1Size = 0;

  /* Message RAM address offsets per channel within module */
  dev->nodeConfig.messageRAM.baseAddress = 0xF0200000u + (channel / 4) * 0x10000;
  dev->nodeConfig.messageRAM.standardFilterListStartAddress = (channel % 4) * 0x1000;
  dev->nodeConfig.messageRAM.extendedFilterListStartAddress = (channel % 4) * 0x1000 + 0x100;
  dev->nodeConfig.messageRAM.rxFifo0StartAddress = (channel % 4) * 0x1000 + 0x200;
  dev->nodeConfig.messageRAM.rxFifo1StartAddress = 0;
  dev->nodeConfig.messageRAM.rxBuffersStartAddress = 0;
  dev->nodeConfig.messageRAM.txEventFifoStartAddress = 0;
  dev->nodeConfig.messageRAM.txBuffersStartAddress = (channel % 4) * 0x1000 + 0x700;

  /* Interrupt configuration */
  dev->nodeConfig.interruptConfig.rxFifo0NewMessageEnabled = TRUE;
  dev->nodeConfig.interruptConfig.rxf0n.priority = CAN_PRIORITY + channel;
  dev->nodeConfig.interruptConfig.rxf0n.interruptLine = IfxCan_InterruptLine_0 + channel % 4;
  dev->nodeConfig.interruptConfig.rxf0n.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

  dev->nodeConfig.interruptConfig.transmissionCompletedEnabled = TRUE;
  dev->nodeConfig.interruptConfig.traco.priority = CAN_PRIORITY + CAN_NUM + channel;
  dev->nodeConfig.interruptConfig.traco.interruptLine = IfxCan_InterruptLine_4 + channel % 4;
  dev->nodeConfig.interruptConfig.traco.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

  dev->nodeConfig.interruptConfig.busOffStatusEnabled = TRUE;
  dev->nodeConfig.interruptConfig.boff.priority = CAN_PRIORITY + CAN_NUM * 2 + channel;
  dev->nodeConfig.interruptConfig.boff.interruptLine = IfxCan_InterruptLine_8 + channel % 4;
  dev->nodeConfig.interruptConfig.boff.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

  dev->nodeConfig.pins = &can_pins[channel];
  dev->nodeConfig.busLoopbackEnabled = FALSE;
  dev->nodeConfig.calculateBitTimingValues = FALSE;
  // clang-format on

  /* Initialize CAN node */
  IfxCan_Can_initNode(&dev->node, &dev->nodeConfig);

  // bit timing, tdc
  IfxCan_Node_enableConfigurationChange(dev->node.node);
  IfxCan_Node_setBitTimingValues(dev->node.node, ntseg2 - 1, ntseg2 - 1,
                                 ntseg1 - 1, npre - 1);
  IfxCan_Node_setFastBitTimingValues(dev->node.node, dtseg2 - 1, dtseg2 - 1,
                                     dtseg1 - 1, dpre - 1);
  IfxCan_Node_setTransceiverDelayCompensationOffset(dev->node.node, dtseg1 + 1);
  IfxCan_Node_disableConfigurationChange(dev->node.node);

  /* Initialize CAN filter */
  IfxCan_Can_setStandardFilter(&dev->node, &can_std_default_filter[0][0]);
  IfxCan_Can_setExtendedFilter(&dev->node, &can_ext_default_filter[0][0]);

  /* Initialize CAN message */
  IfxCan_Can_initMessage(&dev->txMsg);
  IfxCan_Can_initMessage(&dev->rxMsg);

  // callback
  switch (channel) {
  case CAN0:
    dev->can_rx_callback = can0_rx_callback;
    dev->can_tx_callback = NULL;
    dev->can_error_callback = NULL;
    break;
  default:
    dev->can_rx_callback = NULL;
    dev->can_tx_callback = NULL;
    dev->can_error_callback = NULL;
    break;
  }
}

void init_can_simple(mcmcanType *dev, canChannel channel, uint32 baudRate,
                     float samplePoint, uint32 fastBaudRate,
                     float fastSamplePoint) {
  uint8 group = (channel < CAN4) ? 0 : 1;
  Ifx_CAN *modulePtr = (group == 0) ? &MODULE_CAN0 : &MODULE_CAN1;

  if (!g_canModuleInitialized[group]) {
    IfxCan_Can_initModuleConfig(&dev->config, modulePtr);
    IfxCan_Can_initModule(&dev->module, &dev->config);
    g_canModuleInitialized[group] = TRUE;
  } else {
    dev->module = can[(group == 0) ? CAN0 : CAN4].module;
  }

  IfxCan_Can_initNodeConfig(&dev->nodeConfig, &dev->module);

  // clang-format off
  dev->channel = channel;

  dev->nodeConfig.nodeId = (IfxCan_NodeId)(channel % 4);
  dev->nodeConfig.clockSource = IfxCan_ClockSource_both;
  dev->nodeConfig.frame.type = IfxCan_FrameType_transmitAndReceive;
  dev->nodeConfig.frame.mode = IfxCan_FrameMode_fdLongAndFast;
  /* Nominal baud rate */
  dev->nodeConfig.baudRate.baudrate = baudRate;
  dev->nodeConfig.baudRate.samplePoint = (uint16)(samplePoint * 10000);
  dev->nodeConfig.baudRate.syncJumpWidth = 10000 - dev->nodeConfig.baudRate.samplePoint;
  /* Fast baud rate (CAN FD data phase) */
  dev->nodeConfig.fastBaudRate.baudrate = fastBaudRate;
  dev->nodeConfig.fastBaudRate.samplePoint = (uint16)(fastSamplePoint * 10000);
  dev->nodeConfig.fastBaudRate.syncJumpWidth = 10000 - dev->nodeConfig.fastBaudRate.samplePoint;

  /* Tx configuration */
  dev->nodeConfig.txConfig.txMode = IfxCan_TxMode_fifo;
  dev->nodeConfig.txConfig.dedicatedTxBuffersNumber = 0;
  dev->nodeConfig.txConfig.txFifoQueueSize = 32;
  dev->nodeConfig.txConfig.txBufferDataFieldSize = IfxCan_DataFieldSize_64;
  dev->nodeConfig.txConfig.txEventFifoSize = 0;

  /* Filter configuration */
  dev->nodeConfig.filterConfig.messageIdLength = IfxCan_MessageIdLength_both;
  dev->nodeConfig.filterConfig.standardListSize = 32;
  dev->nodeConfig.filterConfig.extendedListSize = 32;
  dev->nodeConfig.filterConfig.rejectRemoteFramesWithStandardId = TRUE;
  dev->nodeConfig.filterConfig.rejectRemoteFramesWithExtendedId = TRUE;
  dev->nodeConfig.filterConfig.standardFilterForNonMatchingFrames = IfxCan_NonMatchingFrame_reject;
  dev->nodeConfig.filterConfig.extendedFilterForNonMatchingFrames = IfxCan_NonMatchingFrame_reject;

  /* Rx configuration */
  dev->nodeConfig.rxConfig.rxMode = IfxCan_RxMode_fifo0;
  dev->nodeConfig.rxConfig.rxBufferDataFieldSize = IfxCan_DataFieldSize_64;
  dev->nodeConfig.rxConfig.rxFifo0DataFieldSize = IfxCan_DataFieldSize_64;
  dev->nodeConfig.rxConfig.rxFifo1DataFieldSize = IfxCan_DataFieldSize_64;
  dev->nodeConfig.rxConfig.rxFifo0OperatingMode = IfxCan_RxFifoMode_overwrite;
  dev->nodeConfig.rxConfig.rxFifo1OperatingMode = IfxCan_RxFifoMode_overwrite;
  dev->nodeConfig.rxConfig.rxFifo0WatermarkLevel = 0;
  dev->nodeConfig.rxConfig.rxFifo1WatermarkLevel = 0;
  dev->nodeConfig.rxConfig.rxFifo0Size = 16;
  dev->nodeConfig.rxConfig.rxFifo1Size = 0;

  /* Message RAM address offsets per channel within module */
  dev->nodeConfig.messageRAM.baseAddress = 0xF0200000u + (channel / 4) * 0x10000;
  dev->nodeConfig.messageRAM.standardFilterListStartAddress = (channel % 4) * 0x1000;
  dev->nodeConfig.messageRAM.extendedFilterListStartAddress = (channel % 4) * 0x1000 + 0x100;
  dev->nodeConfig.messageRAM.rxFifo0StartAddress = (channel % 4) * 0x1000 + 0x200;
  dev->nodeConfig.messageRAM.rxFifo1StartAddress = 0;
  dev->nodeConfig.messageRAM.rxBuffersStartAddress = 0;
  dev->nodeConfig.messageRAM.txEventFifoStartAddress = 0;
  dev->nodeConfig.messageRAM.txBuffersStartAddress = (channel % 4) * 0x1000 + 0x700;

  /* Interrupt configuration */
  dev->nodeConfig.interruptConfig.rxFifo0NewMessageEnabled = TRUE;
  dev->nodeConfig.interruptConfig.rxf0n.priority = CAN_PRIORITY + channel;
  dev->nodeConfig.interruptConfig.rxf0n.interruptLine = IfxCan_InterruptLine_0 + channel % 4;
  dev->nodeConfig.interruptConfig.rxf0n.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

  dev->nodeConfig.interruptConfig.transmissionCompletedEnabled = TRUE;
  dev->nodeConfig.interruptConfig.traco.priority = CAN_PRIORITY + CAN_NUM + channel;
  dev->nodeConfig.interruptConfig.traco.interruptLine = IfxCan_InterruptLine_4 + channel % 4;
  dev->nodeConfig.interruptConfig.traco.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

  dev->nodeConfig.interruptConfig.busOffStatusEnabled = TRUE;
  dev->nodeConfig.interruptConfig.boff.priority = CAN_PRIORITY + CAN_NUM * 2 + channel;
  dev->nodeConfig.interruptConfig.boff.interruptLine = IfxCan_InterruptLine_8 + channel % 4;
  dev->nodeConfig.interruptConfig.boff.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

  dev->nodeConfig.pins = &can_pins[channel];
  dev->nodeConfig.busLoopbackEnabled = FALSE;
  dev->nodeConfig.calculateBitTimingValues = TRUE;
  // clang-format on

  /* Initialize CAN node */
  IfxCan_Can_initNode(&dev->node, &dev->nodeConfig);

  // TDC
  IfxCan_Node_enableConfigurationChange(dev->node.node);
  IfxCan_Node_setTransceiverDelayCompensationOffset(
    dev->node.node, dev->node.node->DBTP.B.DTSEG1 + 2);
  IfxCan_Node_disableConfigurationChange(dev->node.node);

  /* Initialize CAN filter */
  IfxCan_Can_setStandardFilter(&dev->node, &can_std_default_filter[0][0]);
  IfxCan_Can_setExtendedFilter(&dev->node, &can_ext_default_filter[0][0]);

  /* Initialize CAN message */
  IfxCan_Can_initMessage(&dev->txMsg);
  IfxCan_Can_initMessage(&dev->rxMsg);

  // callback
  switch (channel) {
  case CAN0:
    dev->can_rx_callback = can0_rx_callback;
    dev->can_tx_callback = NULL;
    dev->can_error_callback = NULL;
    break;
  default:
    dev->can_rx_callback = NULL;
    dev->can_tx_callback = NULL;
    dev->can_error_callback = NULL;
    break;
  }
}

void core0_main(void) {
  IfxCpu_enableInterrupts();

  /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
   * Enable the watchdogs and service them periodically if it is required
   */
  IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
  IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());

  /* Wait for CPU sync event */
  IfxCpu_emitEvent(&cpuSyncEvent);
  IfxCpu_waitEvent(&cpuSyncEvent, 1);

  init_can_simple(&can[0], CAN0, 500000, 0.8, 2000000,
                  0.8); // 500kbps 80%, 2Mbps 80%
  init_can_simple(&can[1], CAN1, 1000000, 0.8, 5000000,
                  0.75); // 1000kbps 80%, 5Mbps 75%

  // init_can(&can[0], CAN0, 8, 15, 4, 2, 15, 4); // 500kbps 80%, 2Mbps 80%
  // init_can(&can[1], CAN1, 4, 15, 4, 1, 11, 4); // 1000kbps 80%, 5Mbps 75%

  while (1) {
  }
}
