/**
 * \file IfxGtm_Dtm.h
 * \brief GTM  basic functionality
 * \ingroup IfxLld_Gtm
 *
 * \version iLLD_1_20_0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Gtm_Std_Dtm Dtm Basic Functionality
 * \ingroup IfxLld_Gtm_Std
 * \defgroup IfxLld_Gtm_Std_Dtm_Enumerations DTM Enumerations
 * \ingroup IfxLld_Gtm_Std_Dtm
 * \defgroup IfxLld_Gtm_Std_Dtm_Functions DTM Functions
 * \ingroup IfxLld_Gtm_Std_Dtm
 */

#ifndef IFXGTM_DTM_H
#define IFXGTM_DTM_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxGtm_cfg.h"
#include "IfxGtm_reg.h"
#include "IfxGtm_Cmu.h"
#include "Scu/Std/IfxScuCcu.h"
#include "IfxGtm_bf.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief DTM channel shift position
 */
#define IFXGTM_DTM_CH_SHIFT_POS (3)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Gtm_Std_Dtm_Enumerations
 * \{ */
/** \brief Clock source for DTM object\n
 * Definition in IfxGTM.DTM[i].CTRL.B.CLKSEL ( i = 0 to 35)
 */
typedef enum
{
    IfxGtm_Dtm_ClockSource_systemClock,  /**< \brief SYS_CLK as clock source */
    IfxGtm_Dtm_ClockSource_cmuClock0,    /**< \brief CMU_CLK0 as clock source */
    IfxGtm_Dtm_ClockSource_cmuClock1,    /**< \brief CMU_CLK1 (if DTM is connected to ATOM) or CMU_FXCLK0 (if DTM is connected to TOM) as clock source */
    IfxGtm_Dtm_ClockSource_cmuClock2     /**< \brief CMU_CLK2 (if DTM is connected to ATOM) or CMU_FXCLK1 (if DTM is connected to TOM) as clock source */
} IfxGtm_Dtm_ClockSource;

/** \brief Output x function of channel y \n
 * Definition in IfxGTM.DTM[i].CH.CTRL1.B.O1Fx ( i = 0 to 35 and x = 0 to 3)
 */
typedef enum
{
    IfxGtm_Dtm_Output1Function_signalEdgeTrigger,            /**< \brief Signal Edge Trigger */
    IfxGtm_Dtm_Output1Function_xorOfDtmInputandShiftSignal,  /**< \brief XOR Of Dtm Input and Shift Signal */
    IfxGtm_Dtm_Output1Function_andOfDtmInputandShiftSignal,  /**< \brief AND Of Dtm Input and Shift Signal */
    IfxGtm_Dtm_Output1Function_dtmInputSignal                /**< \brief DTM Input Signal DTM[i]_INx_T (i = 0 to 35 and x = 0 to 3) */
} IfxGtm_Dtm_Output1Function;

/** \brief Output 1 selection of channel x (x = 0 to 3)\n
 * Definition in IfxGTM.DTM[i].CH.CTRL1.B.O1SELx ( i = 0 to 35 and x = 0 to 3)
 */
typedef enum
{
    IfxGtm_Dtm_Output1Select_inverseDeadTime,  /**< \brief Inverse Dead Time */
    IfxGtm_Dtm_Output1Select_specialFunction   /**< \brief Special Function as selected by O1Fx (x = 0 to 3) */
} IfxGtm_Dtm_Output1Select;

/** \} */

/** \brief Dead Time Path on output x of channel y\n
 * Definition in IfxGTM.DTM[i].CH.CTRL2.B.DTxy ( i = 0 to 35; x = 0 , 1; and y = 0 to 4)
 */
typedef enum
{
    IfxGtm_Dtm_DeadTimePath_feedThrough,  /**< \brief Feed through from DTM input to output (DTM[i]_INx to DTM[i]_OUTx (i = 0 to 35 and x = 0 to 4) */
    IfxGtm_Dtm_DeadTimePath_enable        /**< \brief Dead Time Path enabled */
} IfxGtm_Dtm_DeadTimePath;

/** \brief Polarity on output
 */
typedef enum
{
    IfxGtm_Dtm_OutputPolarity_notInverted = 0,  /**< \brief Output signal not inverted */
    IfxGtm_Dtm_OutputPolarity_inverted          /**< \brief Output signal inverted */
} IfxGtm_Dtm_OutputPolarity;

/** \brief Input Selection
 */
typedef enum
{
	IfxGtm_Dtm_InputSelection_Dtm_IN0 = 0,  /**< \brief Use DTM[i]_IN0 as input */
	IfxGtm_Dtm_InputSelection_Dtm_IN0_T     /**< \brief Use DTM[i]_IN0_T as input */
} IfxGtm_Dtm_InputSelection;

/** \addtogroup IfxLld_Gtm_Std_Dtm_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Sets the clock source for the DTM object.
 *
 * \param[inout] dtm         Pointer to the DTM object to configure.
 * \param[in]    clockSource The clock source to be used by the DTM object. Range: \ref IfxGtm_Dtm_ClockSource
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Dtm_setClockSource(Ifx_GTM_CDTM_DTM *dtm, IfxGtm_Dtm_ClockSource clockSource);

/**
 * \brief Configures the Output 0 Dead Time Path for the specified DTM channel.
 *
 * \param[inout] dtm   		  Pointer to the DTM object to configure.
 * \param[in]    channel      Channel index to configure. Range: \ref IfxGtm_Dtm_Ch
 * \param[in]    deadTimePath Dead Time Path configuration for the channel output. Range: \ref IfxGtm_Dtm_DeadTimePath
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Dtm_setOutput0DeadTimePath(Ifx_GTM_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_DeadTimePath deadTimePath);

/**
 * \brief Configures the dead time path for Output 1 of the specified DTM channel.
 *
 * \param[inout] dtm   		  Pointer to the DTM object to configure.
 * \param[in]    channel      Channel index to configure. Range: \ref IfxGtm_Dtm_Ch
 * \param[in]    deadTimePath Dead Time Path for Dtm channel output. Range: \ref IfxGtm_Dtm_DeadTimePath
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Dtm_setOutput1DeadTimePath(Ifx_GTM_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_DeadTimePath deadTimePath);

/**
 * \brief Sets the Output Function for a DTM channel.
 *
 * \param[inout] dtm 			 Pointer to the DTM object.
 * \param[in] 	 channel 		 Channel index. Range: \ref IfxGtm_Dtm_Ch
 * \param[in] 	 output1Function Output 1 function to be configured. Range: \ref IfxGtm_Dtm_Output1Function
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Dtm_setOutput1Function(Ifx_GTM_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_Output1Function output1Function);

/**
 * \brief Sets the Output Selection for DTM channel.
 *
 * \param[inout] dtm 		   Pointer to the DTM object.
 * \param[in] 	 channel 	   Channel index. Range: \ref IfxGtm_Dtm_Ch
 * \param[in]    output1Select Output 1 selection. Range: \ref IfxGtm_Dtm_Output1Select
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Dtm_setOutput1Select(Ifx_GTM_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_Output1Select output1Select);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Returns the CDTM index corresponding to the given atom.
 *
 * \param[in] atom The atom for which the CDTM index is to be retrieved. Range: \ref IfxGtm_Atom
 *
 * \retval IfxGtm_Cdtm The CDTM index associated with the provided atom. Range: \ref IfxGtm_Cdtm
 */
IFX_INLINE IfxGtm_Cdtm IfxGtm_Dtm_getCdtmIndexForAtom(IfxGtm_Atom atom);

/**
 * \brief Returns the DTM index corresponding to the specified ATOM and channel.
 *
 * \param[in] atom    The ATOM object. Range: \ref IfxGtm_Atom
 * \param[in] channel The ATOM channel. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval IfxGtm_Dtm The DTM index corresponding to the specified ATOM and channel. Range: \ref IfxGtm_Dtm
 */
IFX_INLINE IfxGtm_Dtm IfxGtm_Dtm_getDtmIndexForAtom(IfxGtm_Atom atom, IfxGtm_Atom_Ch channel);

/**
 * \brief Returns the DTM channel corresponding to the given ATOM channel.
 *
 * \param[in] atomChannel The ATOM channel number. Range: \ref IfxGtm_Atom_Ch
 *
 * \retval IfxGtm_Dtm_Ch The corresponding DTM channel for the given ATOM channel. Range: \ref IfxGtm_Dtm_Ch
 */
IFX_INLINE IfxGtm_Dtm_Ch IfxGtm_Dtm_getDtmChannelForAtom(IfxGtm_Atom_Ch atomChannel);

/**
 * \brief Sets the deadtime for both rising and falling edges of a specific channel in the DTM module.
 *
 * \param[inout] dtm	     Pointer to the DTM object.
 * \param[in]    channel     Index of the channel to configure. Range: \ref IfxGtm_Dtm_Ch
 * \param[in]    risingEdge  Deadtime value for the rising edge. Range: 0 to 0x3FF
 * \param[in]    fallingEdge Deadtime value for the falling edge. Range: 0 to 0x3FF
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Dtm_setDeadtime(Ifx_GTM_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, uint32 risingEdge, uint32 fallingEdge);

/**
 * \brief Returns the clock source of the DTM object.
 *
 * \param[in] dtm Pointer to the DTM object whose clock source is to be retrieved.
 *
 * \retval IfxGtm_Dtm_ClockSource The clock source of the DTM object. Range: \ref IfxGtm_Dtm_ClockSource
 */
IFX_INLINE IfxGtm_Dtm_ClockSource IfxGtm_Dtm_getClockSource(Ifx_GTM_CDTM_DTM *dtm);

/**
 * \brief Sets the signal polarity at output 1 for the specified DTM channel.
 *
 * \param[inout] dtm	  Pointer to the DTM object.
 * \param[in]    channel  Index of the channel to configure. Range: \ref IfxGtm_Dtm_Ch
 * \param[in]    polarity Polarity on Output 1 Channel x. Range: \ref IfxGtm_Dtm_OutputPolarity
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Dtm_setOutput1Polarity(Ifx_GTM_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_OutputPolarity polarity);

/**
 * \brief Set TSEL0 Input selection for dead time / edge trigger generation
 *
 * \param[inout] dtm			Pointer to the DTM object.
 * \param[in] 	 channel 		DTM Channel to configure. Range: \ref IfxGtm_Dtm_Ch
 * \param[in] 	 inputSelection Input Selection on TSEL0 Channel x. Range: \ref IfxGtm_Dtm_InputSelection
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Dtm_setTSel0Input(Ifx_GTM_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_InputSelection inputSelection);

/**
 * \brief Returns the DTM channel corresponding to the given TOM channel.
 *
 * \param[in] tomChannel The TOM channel number to find the corresponding DTM channel for.
 *
 * \retval IfxGtm_Dtm_Ch The DTM channel corresponding to the given TOM channel. Range: \ref IfxGtm_Dtm_Ch
 */
IFX_INLINE IfxGtm_Dtm_Ch IfxGtm_Dtm_getDtmChannelForTom(IfxGtm_Tom_Ch tomChannel);

/**
 * \brief Returns the CDTM index corresponding to the given TOM.
 *
 * \param[in] tom The TOM object. Range: \ref IfxGtm_Tom
 *
 * \retval IfxGtm_Cdtm The CDTM index associated with the provided TOM. Range: \ref IfxGtm_Cdtm
 */
IFX_INLINE IfxGtm_Cdtm IfxGtm_Dtm_getCdtmIndexForTom(IfxGtm_Tom tom);

/**
 * \brief Returns the DTM index corresponding to the specified TOM and channel.
 *
 * \param[in] tom 	  The TOM object. Range: \ref IfxGtm_Tom
 * \param[in] channel The TOM channel. Range: \ref IfxGtm_Tom_Ch
 *
 * \retval IfxGtm_Dtm The DTM index corresponding to the specified TOM and channel. Range: \ref IfxGtm_Dtm
 */
IFX_INLINE IfxGtm_Dtm IfxGtm_Dtm_getDtmIndexForTom(IfxGtm_Tom tom, IfxGtm_Tom_Ch channel);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Returns the base address of the selected DTM instance.
 *
 * \param[in] gtm 		Pointer to the GTM register base.
 * \param[in] cdtmIndex CDTM index. Range: \ref IfxGtm_Cdtm
 * \param[in] dtmIndex  DTM index. Range: \ref IfxGtm_Dtm
 *
 * \retval Ifx_GTM_CDTM_DTM* Base address of the selected DTM instance.
 */
IFX_EXTERN Ifx_GTM_CDTM_DTM *IfxGtm_Dtm_getDtmPointer(Ifx_GTM *gtm, IfxGtm_Cdtm cdtmIndex, IfxGtm_Dtm dtmIndex);

/**
 * \brief Returns the clock frequency in Hz of the specified DTM
 *
 * \param[in] gtm 		Pointer to the GTM register base.
 * \param[in] cdtmIndex CDTM index. Range: \ref IfxGtm_Cdtm
 * \param[in] dtmIndex  DTM index. Range: \ref IfxGtm_Dtm
 *
 * \retval float32 DTM input clock frequency in Hz
 */
IFX_EXTERN float32 IfxGtm_Dtm_getClockFrequency(Ifx_GTM *gtm, IfxGtm_Cdtm cdtmIndex, IfxGtm_Dtm dtmIndex);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxGtm_Dtm_setClockSource(Ifx_GTM_CDTM_DTM *dtm, IfxGtm_Dtm_ClockSource clockSource)
{
    dtm->CTRL.B.CLK_SEL = clockSource;
}


IFX_INLINE void IfxGtm_Dtm_setOutput0DeadTimePath(Ifx_GTM_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_DeadTimePath deadTimePath)
{
    uint32 shift = (8 * (uint32)channel) + 3;
    uint32 mask  = 1 << shift;

    dtm->CH_CTRL2.U = (dtm->CH_CTRL2.U & ~mask) | ((uint32)deadTimePath << shift);
}


IFX_INLINE void IfxGtm_Dtm_setOutput1DeadTimePath(Ifx_GTM_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_DeadTimePath deadTimePath)
{
    uint32 shift = (8 * (uint32)channel) + 7;
    uint32 mask  = 1 << shift;

    dtm->CH_CTRL2.U = (dtm->CH_CTRL2.U & ~mask) | ((uint32)deadTimePath << shift);
}


IFX_INLINE void IfxGtm_Dtm_setOutput1Function(Ifx_GTM_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_Output1Function output1Function)
{
    uint32 shift = (8 * (uint32)channel) + 4;
    uint32 mask  = 3 << shift;

    dtm->CH_CTRL1.U = (dtm->CH_CTRL1.U & ~mask) | ((uint32)output1Function << shift);
}


IFX_INLINE void IfxGtm_Dtm_setOutput1Select(Ifx_GTM_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_Output1Select output1Select)
{
    uint32 shift = 8 * (uint32)channel;
    uint32 mask  = 1 << shift;

    dtm->CH_CTRL1.U = (dtm->CH_CTRL1.U & ~mask) | ((uint32)output1Select << shift);
}


IFX_INLINE IfxGtm_Cdtm IfxGtm_Dtm_getCdtmIndexForAtom(IfxGtm_Atom atom)
{
    return IfxGtm_dtmAtom_map[atom];
}


IFX_INLINE IfxGtm_Dtm IfxGtm_Dtm_getDtmIndexForAtom(IfxGtm_Atom atom, IfxGtm_Atom_Ch channel)
{
    IfxGtm_Dtm dtm;

    if (IfxGtm_dtmAtom_map[atom] != IfxGtm_Cdtm_none)
    {
        dtm = channel <= IfxGtm_Atom_Ch_3 ? IfxGtm_Dtm_4 : IfxGtm_Dtm_5;
    }
    else
    {
        dtm = IfxGtm_Dtm_none;
    }

    return dtm;
}


IFX_INLINE IfxGtm_Dtm_Ch IfxGtm_Dtm_getDtmChannelForAtom(IfxGtm_Atom_Ch atomChannel)
{
    IfxGtm_Dtm_Ch channel;

    if ((atomChannel >= IfxGtm_Atom_Ch_0) && (atomChannel <= IfxGtm_Atom_Ch_3))
    {
        channel = (IfxGtm_Dtm_Ch)atomChannel;
    }
    else if ((atomChannel >= IfxGtm_Atom_Ch_4) && (atomChannel <= IfxGtm_Atom_Ch_7))
    {
        channel = (IfxGtm_Dtm_Ch)(atomChannel - IfxGtm_Atom_Ch_4);
    }
    else
    {
        channel = IfxGtm_Dtm_Ch_none;
    }

    return channel;
}


IFX_INLINE void IfxGtm_Dtm_setDeadtime(Ifx_GTM_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, uint32 risingEdge, uint32 fallingEdge)
{
    dtm->CH[channel].DTV.B.RELRISE = risingEdge;
    dtm->CH[channel].DTV.B.RELFALL = fallingEdge;
}


IFX_INLINE IfxGtm_Dtm_ClockSource IfxGtm_Dtm_getClockSource(Ifx_GTM_CDTM_DTM *dtm)
{
    return (IfxGtm_Dtm_ClockSource)dtm->CTRL.B.CLK_SEL;
}


IFX_INLINE void IfxGtm_Dtm_setOutput1Polarity(Ifx_GTM_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_OutputPolarity polarity)
{
    uint32 shift = ((uint32)channel << IFXGTM_DTM_CH_SHIFT_POS) + IFX_GTM_CDTM_DTM_CH_CTRL2_POL1_0_OFF;
    uint32 mask  = (uint32)IFX_GTM_CDTM_DTM_CH_CTRL2_POL1_0_MSK << shift;
    uint32 value = (uint32)polarity << shift;

    Ifx__ldmst(&(dtm->CH_CTRL2), mask, value);
}


IFX_INLINE void IfxGtm_Dtm_setTSel0Input(Ifx_GTM_CDTM_DTM *dtm, IfxGtm_Dtm_Ch channel, IfxGtm_Dtm_InputSelection inputSelection)
{
    uint32 shift = ((uint32)channel << IFXGTM_DTM_CH_SHIFT_POS) + IFX_GTM_CDTM_DTM_CH_CTRL3_TSEL0_0_OFF;
    uint32 mask  = (uint32)IFX_GTM_CDTM_DTM_CH_CTRL3_TSEL0_0_MSK << shift;
    uint32 value = (uint32)inputSelection << shift;

    Ifx__ldmst(&(dtm->CH_CTRL3), mask, value);
}


IFX_INLINE IfxGtm_Dtm_Ch IfxGtm_Dtm_getDtmChannelForTom(IfxGtm_Tom_Ch tomChannel)
{
    IfxGtm_Dtm_Ch channel;

    if ((tomChannel >= IfxGtm_Tom_Ch_0) && (tomChannel <= IfxGtm_Tom_Ch_3))
    {
        channel = (IfxGtm_Dtm_Ch)tomChannel;
    }
    else if ((tomChannel >= IfxGtm_Tom_Ch_4) && (tomChannel <= IfxGtm_Tom_Ch_7))
    {
        channel = (IfxGtm_Dtm_Ch)(tomChannel - IfxGtm_Tom_Ch_4);
    }
    else
    {
        channel = IfxGtm_Dtm_Ch_none;
    }

    return channel;
}


IFX_INLINE IfxGtm_Cdtm IfxGtm_Dtm_getCdtmIndexForTom(IfxGtm_Tom tom)
{
    return IfxGtm_dtmTom_map[tom];
}


IFX_INLINE IfxGtm_Dtm IfxGtm_Dtm_getDtmIndexForTom(IfxGtm_Tom tom, IfxGtm_Tom_Ch channel)
{
    IfxGtm_Dtm dtm;

    if (IfxGtm_dtmTom_map[tom] != IfxGtm_Cdtm_none)
    {
        if ((channel >= IfxGtm_Tom_Ch_0) && (channel <= IfxGtm_Tom_Ch_3))
        {
            dtm = IfxGtm_Dtm_0;
        }
        else if ((channel >= IfxGtm_Tom_Ch_4) && (channel <= IfxGtm_Tom_Ch_7))
        {
            dtm = IfxGtm_Dtm_1;
        }
        else
        {
            dtm = IfxGtm_Dtm_none;
        }
    }
    else
    {
        dtm = IfxGtm_Dtm_none;
    }

    return dtm;
}


#endif /* IFXGTM_DTM_H */
