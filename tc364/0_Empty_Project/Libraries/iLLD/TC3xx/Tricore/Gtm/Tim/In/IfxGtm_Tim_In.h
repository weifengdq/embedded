/**
 * \file IfxGtm_Tim_In.h
 * \brief GTM IN details
 * \ingroup IfxLld_Gtm
 *
 * \version iLLD_1_20_0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Gtm_Tim_In_Usage How to use the TIM Input Interface
 * \ingroup IfxLld_Gtm_Tim_In
 *
 *
 * \section Preparation Preparation
 * \subsection Include Include Files
 *
 * Include following header file into your C code:
 * \code
 *     #include "Gtm/Tim/In/IfxGtm_Tim_In.h"
 * \endcode
 *
 *
 * \subsection Variables Variables
 * Define global variables if necessary
 *
 * \code
 * IfxGtm_Tim_In TimPwmTest_Handler;	// Handler for TIM config
 * \endcode
 *
 * \subsection Interrupts Interrupts
 * Define Interrupts if needed
 *
 * \code
 * IFX_INTERRUPT(TimTest_ISR, 0, ISR_PRIORITY_TIMTEST);
 *
 * void TimTest_ISR(void)
 * {
 * 	 IfxGtm_Tim_In_onIsr(&TimPwmTest_Handler);
 * }
 * \endcode
 *
 *
 * \subsection Initialization Initialization
 *
 * // TIM measurement initialization
 * \code
 * IfxGtm_Tim_In_Config TimPwmTest_Config; // Config Structure for TIM
 * IfxGtm_Tim_In_Config *config = &TimPwmTest_Config;
 * IfxGtm_Tim_In_initConfig(config, &MODULE_GTM);
 *
 * //Configure the Channel used
 * config->gtm                          = &MODULE_GTM;
 * config->timIndex                     = IfxGtm_Tim_0;
 * config->channelIndex                 = IfxGtm_Tim_Ch_0;
 *
 * // Configure Interrupt parameters
 * config->irqMode                      = IfxGtm_IrqMode_pulseNotify;
 * config->isrProvider                  = ISR_PROVIDER_TIMTEST;
 * config->isrPriority                  = ISR_PRIORITY_TIMTEST;
 *
 * // Enable the CMU clock for TIM
 * MODULE_GTM.CMU.CLK_EN.B.EN_CLK0 = 0x2;     // enable the CMU clock 0
 *
 * // Configure the Capture Configurations
 * config->capture.irqOnNewVal          = TRUE;
 * config->capture.irqOnCntOverflow     = FALSE;
 * config->capture.irqOnEcntOverflow    = FALSE;
 * config->capture.irqOnDatalost        = FALSE;
 * config->capture.clock                = IfxGtm_Cmu_Clk_0;
 * config->capture.mode                 = Ifx_Pwm_Mode_leftAligned;
 *
 * // Configure Timeout
 * config->timeout.irqOnTimeout         = FALSE;
 * config->timeout.clock                = IfxGtm_Cmu_Clk_0;
 * config->timeout.timeout              = 5.0;
 *
 * // Configure the Input
 * config->filter.input                 = IfxGtm_Tim_In_Input_currentChannel;
 * config->filter.inputPin              = &IfxGtm_TIM0_0_P02_0_IN; // Use Port 02 channel 0
 * config->filter.inputPinMode          = IfxPort_InputMode_noPullDevice;
 *
 * // Configure Filter parameters
 * config->filter.risingEdgeMode        = IfxGtm_Tim_In_ConfigFilterMode_immediateEdgePropagation;
 * config->filter.fallingEdgeMode       = IfxGtm_Tim_In_ConfigFilterMode_immediateEdgePropagation;
 * config->filter.risingEdgeFilterTime  = 0;
 * config->filter.fallingEdgeFilterTime = 0;
 * config->filter.clock                 = IfxGtm_Cmu_Tim_Filter_Clk_0;
 *
 * // Initialize the TIM Channel Now
 * IfxGtm_Tim_In_init(&TimPwmTest_Handler, config);
 *
 * The TIM interface is ready for measurement.
 * \endcode
 *
 * \defgroup IfxLld_Gtm_Tim_In TIM Input Interface
 * \ingroup IfxLld_Gtm_Tim
 * \defgroup IfxLld_Gtm_Tim_In_DataStructures Data Structures
 * \ingroup IfxLld_Gtm_Tim_In
 * \defgroup IfxLld_Gtm_Tim_In_Enumerations Enumerations
 * \ingroup IfxLld_Gtm_Tim_In
 * \defgroup IfxLld_Gtm_Tim_In_Funtions Funtions
 * \ingroup IfxLld_Gtm_Tim_In
 */

#ifndef IFXGTM_TIM_IN_H
#define IFXGTM_TIM_IN_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_PinMap/IfxGtm_PinMap.h"
#include "Gtm/Std/IfxGtm_Tim.h"
#include "Gtm/Std/IfxGtm_Cmu.h"
#include "Cpu/Std/IfxCpu.h"
#include "_Utilities/Ifx_Assert.h"
#include "StdIf/IfxStdIf_PwmHl.h"

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Gtm_Tim_In_Enumerations
 * \{ */
/** \brief Config Filter Mode
 */
typedef enum
{
    IfxGtm_Tim_In_ConfigFilterMode_immediateEdgePropagation,      /**< \brief Immediate edge propagation mode */
    IfxGtm_Tim_In_ConfigFilterMode_individualDeglitchTimeUpDown,  /**< \brief Individual deglitch time mode (Up Down) */
    IfxGtm_Tim_In_ConfigFilterMode_individualDeglitchTimeHold,    /**< \brief Individual deglitch time mode (Hold) */
    IfxGtm_Tim_In_ConfigFilterMode_none                           /**< \brief No filter */
} IfxGtm_Tim_In_ConfigFilterMode;

/** \brief Input Source
 */
typedef enum
{
    IfxGtm_Tim_In_Input_currentChannel,   /**< \brief Use the input from the current channel */
    IfxGtm_Tim_In_Input_adjacentChannel,  /**< \brief Use the input from the adjacent channel */
    IfxGtm_Tim_In_Input_aux               /**< \brief Use the input from the aux */
} IfxGtm_Tim_In_Input;

/** \} */

/** \brief Active edge for measurement
 */
typedef enum
{
    IfxGtm_Tim_In_ActiveEdge_falling,  /**< \brief Use falling edge as active edge */
    IfxGtm_Tim_In_ActiveEdge_raising,  /**< \brief Use raising edge as active edge */
    IfxGtm_Tim_In_ActiveEdge_both      /**< \brief Use both edge as active edge */
} IfxGtm_Tim_In_ActiveEdge;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Gtm_Tim_In_DataStructures
 * \{ */
/** \brief Configuration structure for TIM capture
 */
typedef struct
{
    boolean                  irqOnNewVal;             /**< \brief If TRUE, the interrupt on new value is enabled */
    boolean                  irqOnCntOverflow;        /**< \brief If TRUE, the interrupt on CNT overflow is enabled */
    boolean                  irqOnEcntOverflow;       /**< \brief If TRUE, the interrupt on ECNT (Edge counter) overflow is enabled */
    boolean                  irqOnDatalost;           /**< \brief If TRUE, the interrupt on data lost (GPR0, GPR1) is enabled */
    IfxGtm_Cmu_Clk           clock;                   /**< \brief Timer input clock */
    Ifx_Pwm_Mode             mode;                    /**< \brief PWM mode, only Ifx_Pwm_Mode_leftAligned and Ifx_Pwm_Mode_righAligned are supported */
    IfxGtm_Tim_In_ActiveEdge activeEdge;              /**< \brief Active edge to be selected as falling, raising or both */
    uint32                   gateCount;               /**< \brief Shadow count value */
} IfxGtm_Tim_In_ConfigCapture;

/** \brief Configuration structure for TIM filter
 */
typedef struct
{
    IfxGtm_Cmu_Tim_Filter_Clk      clock;                       /**< \brief Timeout clock */
    IfxGtm_Tim_In_ConfigFilterMode risingEdgeMode;              /**< \brief Filter mode for rising edge */
    IfxGtm_Tim_In_ConfigFilterMode fallingEdgeMode;             /**< \brief Filter mode for falling edge */
    float32                        risingEdgeFilterTime;        /**< \brief Rising edge filter time  in second */
    float32                        fallingEdgeFilterTime;       /**< \brief Falling edge filter time in second */
    boolean                        irqOnGlitch;                 /**< \brief If TRUE, the interrupt on glitch is enabled */
    IfxGtm_Tim_In_Input            input;                       /**< \brief selected input */
    IfxGtm_Tim_TinMap             *inputPin;                    /**< \brief If defined, this value overwrites the IfxGtm_Tim_In_Config.filter.input, IfxGtm_Tim_In_Config.timIndex, IfxGtm_Tim_In_Config.channelIndex */
    IfxPort_InputMode              inputPinMode;                /**< \brief Input pin mode */
} IfxGtm_Tim_In_ConfigFilter;

/** \brief Configuration structure for TIM timeout
 */
typedef struct
{
    IfxGtm_Cmu_Clk clock;              /**< \brief Timeout clock */
    float32        timeout;            /**< \brief Timeout in second. Value of 0 disable the timeout functionality see 27.10.3 Timeout Detection Unit (TDU) */
    boolean        irqOnTimeout;       /**< \brief If TRUE, the interrupt on timeout is enabled */
} IfxGtm_Tim_In_ConfigTimeout;

/** \} */

/** \addtogroup IfxLld_Gtm_Tim_In_DataStructures
 * \{ */
/** \brief Driver Handle
 */
typedef struct
{
    Ifx_GTM_TIM_CH *channel;                     /**< \brief TIM channel used */
    uint32          periodTick;                  /**< \brief Period value in clock ticks */
    uint32          pulseLengthTick;             /**< \brief Duty value in clock ticks */
    boolean         dataCoherent;                /**< \brief TRUE, if the duty and period values are measured from the same period */
    boolean         overflowCnt;                 /**< \brief TRUE if the last measurement show an overflow in CNT */
    boolean         newData;                     /**< \brief TRUE when values are updated, and  if none of the counter CNT, CNTS have overflowed */
    boolean         dataLost;                    /**< \brief TRUE if data are lost */
    uint32          edgeCounterUpper;            /**< \brief upper part of the edge counter */
    boolean         glitch;                      /**< \brief TRUE if glitch is detected */
    float32         captureClockFrequency;       /**< \brief Capture clock frequency in Hz */
    IfxGtm_Tim      timIndex;                    /**< \brief Index of the TIM module being used. */
    IfxGtm_Tim_Ch   channelIndex;                /**< \brief Index of the TIM channel being used. */
    uint16          edgeCount;                   /**< \brief number of edges counted. */
} IfxGtm_Tim_In;

/** \brief Configuration structure for TIM input capture
 */
typedef struct
{
    Ifx_GTM                    *gtm;                /**< \brief GTM used */
    IfxGtm_Tim                  timIndex;           /**< \brief TIM index */
    IfxGtm_Tim_Ch               channelIndex;       /**< \brief Channel index */
    IfxGtm_IrqMode              irqMode;            /**< \brief Interrupt mode for the new value available */
    IfxSrc_Tos                  isrProvider;        /**< \brief Interrupt service provider for the timer interrupt */
    Ifx_Priority                isrPriority;        /**< \brief Set the interrupt priority for new value available. If 0, no interrupt will be generated */
    IfxGtm_Tim_In_ConfigCapture capture;            /**< \brief Capture configuration */
    IfxGtm_Tim_In_ConfigFilter  filter;             /**< \brief Filter configuration */
    IfxGtm_Tim_In_ConfigTimeout timeout;            /**< \brief Timeout configuration */
    IfxGtm_Tim_Mode             mode;               /**< \brief TIM channel Mode */
} IfxGtm_Tim_In_Config;

/** \} */

/** \addtogroup IfxLld_Gtm_Tim_In_Funtions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Clears the new data flag.
 *
 * This function resets the newData flag within the provided driver handle,
 * indicating that any previously set new data status is now cleared.
 *
 * \param[inout] driver  Pointer to the TIM Input handle
 *
 * \retval None
 */
IFX_INLINE void IfxGtm_Tim_In_clearNewData(IfxGtm_Tim_In *driver);

/**
 * \brief Returns the duty cycle in percent for the specified TIM input driver.
 *
 * This function calculates and returns the duty cycle as a percentage value.
 * The duty cycle is derived from the period and pulse length values stored in the driver structure.
 * The \a dataCoherent parameter indicates whether the duty cycle calculation is based on coherent period and duty values or values from adjacent periods.
 *
 * \param[in]  driver       Pointer to the TIM Input handle
 * \param[out] dataCoherent Boolean indicating whether the duty cycle was calculated with coherent values for period and duty (TRUE) or with values from adjacent periods (FALSE).
 *
 * \retval float32 Duty cycle percentage (Range: 0.0 to 100.0).
 */
IFX_INLINE float32 IfxGtm_Tim_In_getDutyPercent(IfxGtm_Tim_In *driver, boolean *dataCoherent);

/**
 * \brief Returns the period of the TIM input signal in seconds.
 *
 * This function calculates and returns the period of the input signal connected to the TIM module
 * in seconds. The period is derived from the clock ticks and the capture clock frequency
 * configured in the driver structure.
 *
 * \param[in] driver Pointer to the TIM Input handle
 *
 * \retval float32 The period of the TIM input signal in seconds.
 */
IFX_INLINE float32 IfxGtm_Tim_In_getPeriodSecond(IfxGtm_Tim_In *driver);

/**
 * \brief Returns the period value in clock ticks for the specified timer input driver.
 *
 * This function retrieves the period value measured in clock ticks from the timer input driver.
 * The period value represents the duration of one full cycle of the timer input signal.
 *
 * \param[in] driver Pointer to the TIM Input handle
 *
 * \retval sint32 The period value in clock ticks.
 */
IFX_INLINE sint32 IfxGtm_Tim_In_getPeriodTicks(IfxGtm_Tim_In *driver);

/**
 * \brief Returns the measured pulse length in clock ticks.
 *
 * This function retrieves the pulse length value stored within the provided TIM Input driver object.
 *
 * \param[in] driver Pointer to the TIM Input handle
 *
 * \retval sint32 The pulse length value measured in clock ticks.
 */
IFX_INLINE sint32 IfxGtm_Tim_In_getPulseLengthTick(IfxGtm_Tim_In *driver);

/**
 * \brief Checks if data loss has occurred in the TIM Input module.
 *
 * This function determines whether data loss has been detected in the specified TIM Input driver instance.
 *
 * \param[in] driver Pointer to the TIM Input handle
 *
 * \retval TRUE Data loss has occurred.
 *         FALSE No data loss has occurred.
 */
IFX_INLINE boolean IfxGtm_Tim_In_isDataLost(IfxGtm_Tim_In *driver);

/**
 * \brief Checks if new data is available (new data flag) for the TIM Input driver.
 *
 * This function determines whether new data has been received by the TIM Input driver since the last check.
 *
 * \param[in] driver Pointer to the TIM Input handle
 *
 * \retval TRUE New data is available.
 *         FALSE No new data is available.
 */
IFX_INLINE boolean IfxGtm_Tim_In_isNewData(IfxGtm_Tim_In *driver);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Initializes the input capture object
 *
 * This function initializes the TIM input capture driver with the provided configuration.
 * It sets up the necessary parameters for the input capture operation, including the GTM module,
 * timer index, channel index, interrupt settings, and capture configuration.
 *
 * \param[inout] driver Pointer to the TIM Input handle
 * \param[in]    config Configuration structure containing setup parameters for the input capture
 *
 * \retval TRUE If the Initialization successful.
 *         FALSE If the Initialization failed.
 */
IFX_EXTERN boolean IfxGtm_Tim_In_init(IfxGtm_Tim_In *driver, const IfxGtm_Tim_In_Config *config);

/**
 * \brief Initializes the configuration structure to default values for the TIM input capture.
 *
 * This function sets up the provided configuration structure with default values suitable
 * for the TIM input capture functionality. The configuration structure includes various
 * settings such as the GTM module, TIM index, channel index, interrupt mode, and other
 * capture and filter configurations.
 *
 * \param[inout] config Configuration structure for the input capture Timer that will be initialized.
 * \param[in]    gtm    Pointer to the GTM module to be used for the configuration.
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Tim_In_initConfig(IfxGtm_Tim_In_Config *config, Ifx_GTM *gtm);

/**
 * \brief Updates the driver state in response to an interrupt generated by the IfxGtm_Tim_In driver.
 *
 * This function is designed to be called within the interrupt service routine (ISR) to update the driver's state
 * based on the interrupt event. It processes the interrupt and updates the necessary variables within the driver object.
 *
 * \param[inout] driver Pointer to the TIM Input handle
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Tim_In_onIsr(IfxGtm_Tim_In *driver);

/**
 * \brief Updates the period and duty cycle for the timer input module.
 *
 * This function updates the period and duty cycle values for the specified timer input driver.
 * It ensures that the timer input module operates with the latest configuration settings.
 *
 * \param[inout] driver Pointer to the TIM Input handle
 *
 * \retval None
 */
IFX_EXTERN void IfxGtm_Tim_In_update(IfxGtm_Tim_In *driver);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxGtm_Tim_In_clearNewData(IfxGtm_Tim_In *driver)
{
    driver->newData = FALSE;
}


IFX_INLINE float32 IfxGtm_Tim_In_getDutyPercent(IfxGtm_Tim_In *driver, boolean *dataCoherent)
{
    float32 duty;
    boolean interruptState = IfxCpu_disableInterrupts();
    duty          = (float32)(driver->pulseLengthTick * 100) / driver->periodTick;
    *dataCoherent = driver->dataCoherent;
    IfxCpu_restoreInterrupts(interruptState);

    return duty;
}


IFX_INLINE float32 IfxGtm_Tim_In_getPeriodSecond(IfxGtm_Tim_In *driver)
{
    return IfxGtm_Tim_In_getPeriodTicks(driver) / driver->captureClockFrequency;
}


IFX_INLINE sint32 IfxGtm_Tim_In_getPeriodTicks(IfxGtm_Tim_In *driver)
{
    return driver->periodTick;
}


IFX_INLINE sint32 IfxGtm_Tim_In_getPulseLengthTick(IfxGtm_Tim_In *driver)
{
    return driver->pulseLengthTick;
}


IFX_INLINE boolean IfxGtm_Tim_In_isDataLost(IfxGtm_Tim_In *driver)
{
    return driver->dataLost;
}


IFX_INLINE boolean IfxGtm_Tim_In_isNewData(IfxGtm_Tim_In *driver)
{
    return driver->newData;
}


#endif /* IFXGTM_TIM_IN_H */
