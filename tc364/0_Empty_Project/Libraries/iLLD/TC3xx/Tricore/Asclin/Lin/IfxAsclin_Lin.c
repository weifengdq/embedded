/**
 * \file IfxAsclin_Lin.c
 * \brief ASCLIN LIN details
 *
 * \version iLLD_1_20_0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxAsclin_Lin.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxAsclin_Lin_checkForReceivedHeaderFlags(IfxAsclin_Lin *asclin)
{
    /* getting the pointer to ASCLIN registers from module handler*/
    Ifx_ASCLIN *asclinSFR = asclin->asclin;            

    /* check Rx header end acknowledgement */
    if (IfxAsclin_getRxHeaderEndFlagStatus(asclinSFR)) /* RHE flag*/
    {
        IfxAsclin_clearRxHeaderEndFlag(asclinSFR);
        asclin->acknowledgmentFlags.rxHeaderEnd = 1;
    }

    /* check for Rx header error flags */
    if (IfxAsclin_getHeaderTimeoutFlagStatus(asclinSFR))     /* HT flag*/
    {
        IfxAsclin_clearHeaderTimeoutFlag(asclinSFR);
        asclin->errorFlagsStatus.headerTimeout = 1;
    }

    if (IfxAsclin_getCollisionDetectionErrorFlagStatus(asclinSFR))     /* CE flag*/
    {
        IfxAsclin_clearCollisionDetectionErrorFlag(asclinSFR);
        asclin->errorFlagsStatus.collisionDetectionError = 1;
    }

    if (IfxAsclin_getFrameErrorFlagStatus(asclinSFR)) /* FE flag*/
    {
        IfxAsclin_clearFrameErrorFlag(asclinSFR);
        asclin->errorFlagsStatus.frameError = 1;
    }

    if (IfxAsclin_getLinAutoBaudDetectionErrorFlagStatus(asclinSFR))     /* LA flag*/
    {
        IfxAsclin_clearLinAutoBaudDetectionErrorFlag(asclinSFR);
        asclin->errorFlagsStatus.linAutobaudDetectionError = 1;
    }

    if (IfxAsclin_getLinParityErrorFlagStatus(asclinSFR)) /* LP flag*/
    {
        IfxAsclin_clearLinParityErrorFlag(asclinSFR);
        asclin->errorFlagsStatus.linParityError = 1;
    }
}


void IfxAsclin_Lin_checkForReceivedResponseFlags(IfxAsclin_Lin *asclin)
{
    /* getting the pointer to ASCLIN registers from module handler*/
    Ifx_ASCLIN *asclinSFR = asclin->asclin; 

    /* check Rx response end acknowledgement*/
    if (IfxAsclin_getRxResponseEndFlagStatus(asclinSFR))
    {
        IfxAsclin_clearRxResponseEndFlag(asclinSFR);
        asclin->acknowledgmentFlags.rxResponseEnd = 1;
    }

    /* check for Rx response error flags */
    if (IfxAsclin_getRxFifoOverflowFlagStatus(asclinSFR)) /* RFO flag*/
    {
        IfxAsclin_clearRxFifoOverflowFlag(asclinSFR);
        asclin->errorFlagsStatus.rxFifoOverflow = 1;
    }

    if (IfxAsclin_getCollisionDetectionErrorFlagStatus(asclinSFR))     /* CE flag*/
    {
        IfxAsclin_clearCollisionDetectionErrorFlag(asclinSFR);
        asclin->errorFlagsStatus.collisionDetectionError = 1;
    }

    if (IfxAsclin_getFrameErrorFlagStatus(asclinSFR)) /* FE flag*/
    {
        IfxAsclin_clearFrameErrorFlag(asclinSFR);
        asclin->errorFlagsStatus.frameError = 1;
    }

    if (IfxAsclin_getLinChecksumErrorFlagStatus(asclinSFR))     /* LC flag*/
    {
        IfxAsclin_clearLinChecksumErrorFlag(asclinSFR);
        asclin->errorFlagsStatus.linChecksumError = 1;
    }

    if (IfxAsclin_getResponseTimeoutFlagStatus(asclinSFR))     /* RT flag*/
    {
        IfxAsclin_clearResponseTimeoutFlag(asclinSFR);
        asclin->errorFlagsStatus.responseTimeout = 1;
    }

    if ((asclin->linMode == IfxAsclin_LinMode_slave) && (IfxAsclin_getBreakDetectedFlagStatus(asclinSFR))) /* BD flag only in slave mode*/
    {
        IfxAsclin_clearBreakDetectedFlag(asclinSFR);
        asclin->errorFlagsStatus.breakDetected = 1;
    }
}


void IfxAsclin_Lin_checkForTransmittedHeaderFlags(IfxAsclin_Lin *asclin)
{
    /* getting the pointer to ASCLIN registers from module handler*/
    Ifx_ASCLIN *asclinSFR = asclin->asclin;            

    /* check Tx header end acknowledgement */
    if (IfxAsclin_getTxHeaderEndFlagStatus(asclinSFR)) /* THE flag*/
    {
        IfxAsclin_clearTxHeaderEndFlag(asclinSFR);
        asclin->acknowledgmentFlags.txHeaderEnd = 1;
    }

    /* check for Tx header error flags */
    if (IfxAsclin_getHeaderTimeoutFlagStatus(asclinSFR))     /* HT flag*/
    {
        IfxAsclin_clearHeaderTimeoutFlag(asclinSFR);
        asclin->errorFlagsStatus.headerTimeout = 1;
    }

    if (IfxAsclin_getCollisionDetectionErrorFlagStatus(asclinSFR))     /* CE flag*/
    {
        IfxAsclin_clearCollisionDetectionErrorFlag(asclinSFR);
        asclin->errorFlagsStatus.collisionDetectionError = 1;
    }

    if (IfxAsclin_getFrameErrorFlagStatus(asclinSFR)) /* FE flag*/
    {
        IfxAsclin_clearFrameErrorFlag(asclinSFR);
        asclin->errorFlagsStatus.frameError = 1;
    }

    if (IfxAsclin_getLinParityErrorFlagStatus(asclinSFR)) /* LP flag*/
    {
        IfxAsclin_clearLinParityErrorFlag(asclinSFR);
        asclin->errorFlagsStatus.linParityError = 1;
    }
}


void IfxAsclin_Lin_checkForTransmittedResponseFlags(IfxAsclin_Lin *asclin)
{
    /* getting the pointer to ASCLIN registers from module handler*/
    Ifx_ASCLIN *asclinSFR = asclin->asclin;              

    /* check Tx response end acknowledgement */
    if (IfxAsclin_getTxResponseEndFlagStatus(asclinSFR)) /* TRE flag*/
    {
        IfxAsclin_clearTxResponseEndFlag(asclinSFR);
        asclin->acknowledgmentFlags.txResponseEnd = 1;
    }

    /* check for Tx response error flags */
    if (IfxAsclin_getTxFifoOverflowFlagStatus(asclinSFR)) /* TFO flag*/
    {
        IfxAsclin_clearTxFifoOverflowFlag(asclinSFR);
        asclin->errorFlagsStatus.txFifoOverflow = 1;
    }

    if (IfxAsclin_getCollisionDetectionErrorFlagStatus(asclinSFR))     /* CE flag*/
    {
        IfxAsclin_clearCollisionDetectionErrorFlag(asclinSFR);
        asclin->errorFlagsStatus.collisionDetectionError = 1;
    }

    if (IfxAsclin_getResponseTimeoutFlagStatus(asclinSFR))     /* RT flag*/
    {
        IfxAsclin_clearResponseTimeoutFlag(asclinSFR);
        asclin->errorFlagsStatus.responseTimeout = 1;
    }

    if ((asclin->linMode == IfxAsclin_LinMode_slave) && (IfxAsclin_getBreakDetectedFlagStatus(asclinSFR))) /* BD flag only in slave mode*/
    {
        IfxAsclin_clearBreakDetectedFlag(asclinSFR);
        asclin->errorFlagsStatus.breakDetected = 1;
    }
}


void IfxAsclin_Lin_clearFlagsStatus(IfxAsclin_Lin *asclin)
{
    /*clear acknowledgement flags status */
    asclin->acknowledgmentFlags.txHeaderEnd   = 0;
    asclin->acknowledgmentFlags.rxHeaderEnd   = 0;
    asclin->acknowledgmentFlags.txResponseEnd = 0;
    asclin->acknowledgmentFlags.rxResponseEnd = 0;
    asclin->acknowledgmentFlags.txCompleted   = 0;

    /* clear error flags status*/
    asclin->errorFlagsStatus.headerTimeout             = 0;
    asclin->errorFlagsStatus.collisionDetectionError   = 0;
    asclin->errorFlagsStatus.frameError                = 0;
    asclin->errorFlagsStatus.responseTimeout           = 0;
    asclin->errorFlagsStatus.linParityError            = 0;
    asclin->errorFlagsStatus.breakDetected             = 0;
    asclin->errorFlagsStatus.linAutobaudDetectionError = 0;
    asclin->errorFlagsStatus.linChecksumError          = 0;
    asclin->errorFlagsStatus.txFifoOverflow            = 0;
    asclin->errorFlagsStatus.rxFifoOverflow            = 0;
}


void IfxAsclin_Lin_disableModule(IfxAsclin_Lin *asclin)
{
    /* getting the pointer to ASCLIN registers from module handler*/
    Ifx_ASCLIN *asclinSFR = asclin->asclin;       
    uint16      psw       = IfxScuWdt_getCpuWatchdogPassword();
    
    /* clearing the endinit protection*/
    IfxScuWdt_clearCpuEndinit(psw);  
    /* disabling the module*/
    IfxAsclin_setDisableModuleRequest(asclinSFR); 
    /* setting the endinit protection back on*/
    IfxScuWdt_setCpuEndinit(psw);                 
}


void IfxAsclin_Lin_ignoreHeader(IfxAsclin_Lin *asclin)
{
    /* getting the pointer to ASCLIN registers from module handler*/
    Ifx_ASCLIN *asclinSFR = asclin->asclin;   
    
    /* disable Rx FIFO*/
    IfxAsclin_enableRxFifoInlet(asclinSFR, FALSE);  
    /* set header only mode*/
    IfxAsclin_setHeaderResponseSelect(asclinSFR, IfxAsclin_HeaderResponseSelect_headerOnly); 
    /* clear all flags*/
    IfxAsclin_clearAllFlags(asclinSFR);                                                      
}


IfxAsclin_Status IfxAsclin_Lin_initModule(IfxAsclin_Lin *asclin, const IfxAsclin_Lin_Config *config)
{
    Ifx_ASCLIN      *asclinSFR = config->asclin;                        /* pointer to ASCLIN registers */
    IfxAsclin_Status status    = IfxAsclin_Status_noError;

    asclin->asclin = asclinSFR;                                         /* adding register pointer to module handler*/
    IfxAsclin_enableModule(asclinSFR);                                  /* enabling the module*/

    /* mode initialisation */
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock); /* disabling the clock*/
    asclinSFR->FRAMECON.B.MODE = IfxAsclin_FrameMode_initialise;        /* setting the module in Initialise mode*/
    asclinSFR->BITCON.B.PRESCALER = config->btc.prescaler - 1;          /* setting the prescaler*/
    IfxAsclin_setClockSource(asclinSFR, config->clockSource);           /* setting the clock source*/

    /* baudrate generation in both modes */
    status = (IfxAsclin_Status)IfxAsclin_setBitTiming(asclinSFR, config->brg.baudrate,
        config->btc.oversampling,
        config->bsc.samplePointPosition,
        config->bsc.medianFilter);                                      /* setting the baudrate bit fields to generate the required baudrate*/

    /* lin mode initialisation */
    asclinSFR->IOCR.B.ALTI = config->alti;                              /* selecting the Rx(alternate) input pin*/
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock); /* disabling the clock again*/
    asclinSFR->FRAMECON.B.MODE = config->frameMode;                     /* setting the module in Lin mode*/
    asclinSFR->LIN.CON.B.MS = config->linMode;                          /* configuring lin mode of operation (master/slave)*/

    /* auto baud rate detection in slave mode */
    if (config->linMode == IfxAsclin_LinMode_slave)
    {
        asclinSFR->LIN.CON.B.ABD = (config->brd.abd) ? 1 : 0;                                /* setting the auto baudrate detection (enable/disable)*/
        asclinSFR->BRD.B.UPPERLIMIT = config->brd.upperLimit;                                /* setting the upper limit for abd*/
        asclinSFR->BRD.B.LOWERLIMIT = config->brd.lowerLimit;                                /* setting the lower limit for abd*/
    }

    /* frame control initialization */
    Ifx_ASCLIN_FRAMECON asclinFrameCon = asclinSFR->FRAMECON;
    asclinFrameCon.B.PEN = (config->frame.parityEnable) ? 1 : 0;                             /* setting parity (enable/disable)*/
    asclinFrameCon.B.ODD = config->frame.parityType;                                         /* setting parity type (odd/even)*/
    asclinFrameCon.B.STOP = config->frame.stopBit;                                           /* setting the stop bit*/
    asclinFrameCon.B.CEN = (config->frame.collisionDetectionEnable) ? 1 : 0;                 /* setting collision detection (enable/disable)*/
    asclinFrameCon.B.MSB = config->frame.shiftDir;                                           /* setting the shift direction*/
    /* write back the register from local instance */
    asclinSFR->FRAMECON.U = asclinFrameCon.U;

    /* data control initialization */
    /* create a local instance for the register */
    Ifx_ASCLIN_DATCON asclinDataCon = asclinSFR->DATCON;
    asclinDataCon.B.DATLEN = config->data.dataLength;                                        /* setting the number of bytes to be transfered*/
    asclinDataCon.B.HO = config->data.headerOnly;                                            /* setting the header only or header and response mode*/
    asclinDataCon.B.RM = config->data.responseTimeoutMode;                                   /* setting the response timeout mode (frame/response)*/
    asclinDataCon.B.CSM = config->data.checksum;                                             /* setting the checksum mode (classic/enhanced)*/
    asclinDataCon.B.RESPONSE = __minu(config->data.responseTimeout, 256);                    /* setting the lin response timeout threshold*/
    /* write back the register from local instance */
    asclinSFR->DATCON.U = asclinDataCon.U;

    /* lin control initialization */
    asclinSFR->LIN.CON.B.CSEN = config->lin.csEnable ? 1 : 0;                                /* setting the hardware checksum (enable/disable)*/
    asclinSFR->LIN.CON.B.CSI = config->lin.csi;                                              /* setting checksum injection*/

    /* master specific initialization */
    if (config->linMode == IfxAsclin_LinMode_master)
    {
        asclinSFR->FRAMECON.B.IDLE = config->frame.idleDelay;                  /* setting idle delay for master*/
        asclinSFR->FRAMECON.B.LEAD = config->frame.leadDelay;                  /* setting lead delay for master mode*/
        asclinSFR->LIN.BTIMER.B.BREAK = config->lin.breakLength;               /* setting the break generation length*/
        asclinSFR->LIN.HTIMER.B.HEADER = config->lin.headerTimeout;            /* setting the header timeout value for master*/

        asclin->receiveIdEnable = config->receiveIdEnable;                     /* echoing the selection of receiving Id in its own Rx FIFO*/
    }

    /* slave specific initialization */
    if (config->linMode == IfxAsclin_LinMode_slave)
    {
        asclinSFR->FRAMECON.B.IDLE = config->frame.idleDelay;                  /* setting idle delay for slave */
        asclinSFR->FRAMECON.B.LEAD = config->frame.leadDelay;                  /* setting lead delay for slave mode */
        asclinSFR->LIN.BTIMER.B.BREAK = config->lin.breakLength;               /* setting the break detection length */
        asclinSFR->LIN.HTIMER.B.HEADER = config->lin.headerTimeout;            /* setting the header timeout value for slave*/
    }

    /* fifo control initialization */
    Ifx_ASCLIN_TXFIFOCON asclinTxFifoCon = asclinSFR->TXFIFOCON;
    Ifx_ASCLIN_RXFIFOCON asclinRxFifoCon = asclinSFR->RXFIFOCON;
    asclinTxFifoCon.B.INW = config->fifo.inWidth;                       /* setting Tx FIFO inlet width*/
    asclinTxFifoCon.B.ENO = FALSE ? 1 : 0;                              /* disabling Tx FIFO for recieving*/
    asclinRxFifoCon.B.OUTW = config->fifo.outWidth;                     /* setting Rx FIFO outlet width*/
    asclinRxFifoCon.B.BUF = config->fifo.buffMode;                      /* setting Rx FIFO mode*/
    asclinRxFifoCon.B.ENI = FALSE ? 1 : 0;                              /* disabling Rx FIFO for transmitting*/
    /* Write back to the register memory */
    asclinSFR->TXFIFOCON.U =  asclinTxFifoCon.U;
    asclinSFR->RXFIFOCON.U =  asclinRxFifoCon.U;

    asclinSFR->RXFIFOCON.B.FLUSH = 1;                                   /* flushing Rx FIFO*/
    asclinSFR->TXFIFOCON.B.FLUSH = 1;                                   /* flushing Tx FIFO*/

    /* Interrupt and flags configuration */
	asclin->isInterruptMode = config->isInterruptMode;
    IfxAsclin_Lin_initInterrupt(asclinSFR, &config->interrupt, config->isInterruptMode);

    /* Pin mapping*/
    IfxAsclin_Lin_initPin(config->pins);

    IfxAsclin_setClockSource(asclinSFR, config->clockSource); /* setting the clock source*/

    asclin->linMode = config->linMode;                        /* echoing the mode of operation to module handler*/
    return status;
}

void IfxAsclin_Lin_initInterrupt(Ifx_ASCLIN *asclinSFR, const IfxAsclin_Lin_InterruptConfig *interruptConfig, boolean interruptModeFlag)
{
    /* disable and clear all interrupt flags */
    IfxAsclin_disableAllFlags(asclinSFR);         /* disable all flags*/
    IfxAsclin_clearAllFlags(asclinSFR);           /* clear all flags*/

    /* Initializing the Interrupts */
    IfxSrc_Tos tos = interruptConfig->typeOfService;

    if (interruptModeFlag)
    {
        Ifx_ASCLIN_FLAGSENABLE flagsenable;
        flagsenable.U = 0;

        if ((interruptConfig->rxPriority > 0) || (tos == IfxSrc_Tos_dma))
        {
            volatile Ifx_SRC_SRCR *src;
            src = IfxAsclin_getSrcPointerRx(asclinSFR);
            IfxSrc_init(src, tos, interruptConfig->rxPriority);

            flagsenable.B.RHE = interruptConfig->enabledInterrupt.rxReceivedHeader;
            flagsenable.B.RRE = interruptConfig->enabledInterrupt.rxReceivedResponse;

            IfxSrc_enable(src);
        }

        if ((interruptConfig->txPriority > 0) || (tos == IfxSrc_Tos_dma))
        {
            volatile Ifx_SRC_SRCR *src;
            src = IfxAsclin_getSrcPointerTx(asclinSFR);
            IfxSrc_init(src, tos, interruptConfig->txPriority);

            flagsenable.B.THE = interruptConfig->enabledInterrupt.txTransmittedHeader;
            flagsenable.B.TRE = interruptConfig->enabledInterrupt.txTransmittedResponse;

            IfxSrc_enable(src);
        }

	    /*These interrupts are not serviced by dma*/
        if (interruptConfig->exPriority > 0) 
        {
            volatile Ifx_SRC_SRCR *src;
            src = IfxAsclin_getSrcPointerEr(asclinSFR);
            IfxSrc_init(src, tos, interruptConfig->exPriority);

            flagsenable.B.BDE  = interruptConfig->enabledInterrupt.exBreakDetected;
            flagsenable.B.TCE  = interruptConfig->enabledInterrupt.exTransmissionCompleted;

            flagsenable.B.CEE  = interruptConfig->enabledInterrupt.exCollisionDetectionError;
            flagsenable.B.FEE  = interruptConfig->enabledInterrupt.exFramingError;
            flagsenable.B.HTE  = interruptConfig->enabledInterrupt.exHeaderTimeout;
            flagsenable.B.LAE  = interruptConfig->enabledInterrupt.exLinAutobaudDetectionError;
            flagsenable.B.LCE  = interruptConfig->enabledInterrupt.exLinChecksumError;
            flagsenable.B.LPE  = interruptConfig->enabledInterrupt.exLinParityError;
            flagsenable.B.RFOE = interruptConfig->enabledInterrupt.exReceiveFIFOOverflow;
            flagsenable.B.RTE  = interruptConfig->enabledInterrupt.exResponseTimeout;
            flagsenable.B.TFOE = interruptConfig->enabledInterrupt.exTransmitFIFOOverflow;

            IfxSrc_enable(src);
        }

        /*Update FLAGSENABLE register in one shot*/
        asclinSFR->FLAGSENABLE.U = flagsenable.U;
    }
}

void IfxAsclin_Lin_initPin(const IfxAsclin_Lin_Pins *pins)
{

    if (pins != NULL_PTR)
    {
        IfxAsclin_Rx_In *rx = pins->rx;

        if (rx != NULL_PTR)
        {
            IfxAsclin_initRxPin(rx, pins->rxMode, pins->pinDriver);
        }

        IfxAsclin_Tx_Out *tx = pins->tx;

        if (tx != NULL_PTR)
        {
            IfxAsclin_initTxPin(tx, pins->txMode, pins->pinDriver);
        }
    }
}


void IfxAsclin_Lin_initModuleConfig(IfxAsclin_Lin_Config *config, Ifx_ASCLIN *asclin)
{
    config->asclin      = asclin;
    config->frameMode   = IfxAsclin_FrameMode_lin;                                             /* LIN mode*/
    config->linMode     = IfxAsclin_LinMode_master;                                            /* Lin Master mode*/
    config->clockSource = IfxAsclin_ClockSource_ascFastClock;                                  /* Asclin fast clock, fasclinf*/
    config->alti        = IfxAsclin_RxInputSelect_0;                                           /* alternate input 0;*/

    /* Default values for baudrate */
    config->brg.baudrate                   = 19200.0f;                                         /* default baudrate (the fractional dividier setup will be calculated in initModule)*/
    /* Default Values for Bit Timings */
    config->btc.prescaler                  = 4;                                                /* default prescaler*/
    config->btc.oversampling               = IfxAsclin_OversamplingFactor_16;                  /* default oversampling factor*/
    /* Default Values for Bit sampling */
    config->bsc.filterDepth                = 24U;                                              /* digital glitch filter depth 24*/
    config->bsc.medianFilter               = IfxAsclin_SamplesPerBit_one;                      /* one sample per bit*/
    config->bsc.samplePointPosition        = IfxAsclin_SamplePointPosition_3;                  /* sample point position at 3*/
    /* Default Values for Frame Control */
    config->frame.parityEnable             = FALSE;                                            /* disable parity*/
    config->frame.parityType               = IfxAsclin_ParityType_even;                        /* even parity (if parity enabled) */
    config->frame.stopBit                  = IfxAsclin_StopBit_1;                              /* one stop bit */
    config->frame.shiftDir                 = IfxAsclin_ShiftDirection_lsbFirst;                /* shift diection LSB first */
    config->frame.collisionDetectionEnable = FALSE;
    /* Default Values for Data Control */
    config->data.dataLength                = IfxAsclin_DataLength_8;                           /* number of bytes of the response */
    config->data.headerOnly                = IfxAsclin_HeaderResponseSelect_headerAndResponse; /* header and response */
    config->data.responseTimeoutMode       = IfxAsclin_LinResponseTimeoutMode_frameTimeout;    /* frame timeout */
    config->data.checksum                  = IfxAsclin_Checksum_enhanced;                      /* enhanced checksum */
    config->data.responseTimeout           = 255;
    /* Default Values for fifo Control */
    config->fifo.outWidth                  = IfxAsclin_RxFifoOutletWidth_1;                    /* 8-bit wide read */
    config->fifo.inWidth                   = IfxAsclin_TxFifoInletWidth_1;                     /* 8-bit wide write */
    config->fifo.buffMode                  = IfxAsclin_ReceiveBufferMode_rxFifo;               /* RxFIFO */
    /* Default Values for Lin Control */
    config->lin.csEnable                   = TRUE;                                             /* checksum enable */
    config->lin.csi                        = IfxAsclin_ChecksumInjection_written;              /* 8-bit wide write */

    /* Default Values for Interrupt Config */
    config->interrupt.rxPriority    = 0;                                                       /* receive interrupt priority 0*/
    config->interrupt.txPriority    = 0;                                                       /* transmit interrupt priority 0*/
    config->interrupt.exPriority    = 0;                                                       /* error interrupt priority 0*/
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                                         /* type of service CPU0*/
    config->isInterruptMode         = FALSE;                                                   /* default is in polling mode*/

    /* configuration for master mode */
    {
        config->receiveIdEnable   = FALSE;                 /* receive Id in Rx Fifo after sending */
        config->frame.idleDelay   = IfxAsclin_IdleDelay_2; /* idle dalay 2 bits */
        config->frame.leadDelay   = IfxAsclin_LeadDelay_1; /*lead delay in master 1 bit */
        /* Default Values for Lin Control */
        config->lin.breakLength   = 13;                    /* break generation length 13 */
        config->lin.headerTimeout = 56;                    /* header timeout value in master 56 */
    }

    /*configuration for enabling interrupts*/
    {
        config->interrupt.enabledInterrupt.rxReceivedHeader            = FALSE;
        config->interrupt.enabledInterrupt.rxReceivedResponse          = FALSE;
        config->interrupt.enabledInterrupt.txTransmittedHeader         = FALSE;
        config->interrupt.enabledInterrupt.txTransmittedResponse       = FALSE;
        config->interrupt.enabledInterrupt.exBreakDetected             = FALSE;
        config->interrupt.enabledInterrupt.exTransmissionCompleted     = FALSE;
        config->interrupt.enabledInterrupt.exHeaderTimeout             = FALSE;
        config->interrupt.enabledInterrupt.exResponseTimeout           = FALSE;
        config->interrupt.enabledInterrupt.exLinParityError            = FALSE;
        config->interrupt.enabledInterrupt.exLinAutobaudDetectionError = FALSE;
        config->interrupt.enabledInterrupt.exLinChecksumError          = FALSE;
        config->interrupt.enabledInterrupt.exFramingError              = FALSE;
        config->interrupt.enabledInterrupt.exCollisionDetectionError   = FALSE;
        config->interrupt.enabledInterrupt.exReceiveFIFOOverflow       = FALSE;
        config->interrupt.enabledInterrupt.exTransmitFIFOOverflow      = FALSE;
    }

    config->pins = NULL_PTR;                               /* pins to null pointer*/
}


void IfxAsclin_Lin_receiveHeader(IfxAsclin_Lin *asclin, uint8 *id)
{
    boolean result = 0;
    
    /* prepare for header reception */
    IfxAsclin_Lin_prepareHeaderReception(asclin); 
    /* wait until receive header end acknowledgemnet*/
    result |= IfxAsclin_Lin_waitForReceivedHeader(asclin); 

    if (result == 1)
    {
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }
    else
    {
	    /*read the ID byte*/
        IfxAsclin_Lin_readHeader(asclin, id);           
    }
}


void IfxAsclin_Lin_receiveResponse(IfxAsclin_Lin *asclin, uint8 *data, uint32 length)
{
    boolean result = 0;
    
    /* prepare the response reception */
    IfxAsclin_Lin_prepareResponseReception(asclin, length); 
    /* wait until receive response end acknowledgemnet or an error is occured*/
    result |= IfxAsclin_Lin_waitForReceivedResponse(asclin); 

    if (result == 1)
    {
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }
    else
    {
	    /* read the data bytes */
        IfxAsclin_Lin_readResponse(asclin, data, length); 
    }
}


void IfxAsclin_Lin_sendHeader(IfxAsclin_Lin *asclin, uint8 *id)
{
    boolean     result    = 0;
    /* getting the pointer to ASCLIN registers from module handler*/
    Ifx_ASCLIN *asclinSFR = asclin->asclin;   
    
    /* clearing all flags*/
    IfxAsclin_clearAllFlags(asclinSFR);                

    if (asclin->receiveIdEnable)                       /* if receiving the sent id byte into its own Rx FIFO is selected*/
    {
	/* flushing Rx FIFO*/
        IfxAsclin_flushRxFifo(asclinSFR);              
	/* enabling Rx FIFO */
        IfxAsclin_enableRxFifoInlet(asclinSFR, TRUE);  
    }
    else
    {
	    /* disabling Rx FIFO */
        IfxAsclin_enableRxFifoInlet(asclinSFR, FALSE);            
    }

    /* flushing Tx FIFO */
    IfxAsclin_flushTxFifo(asclinSFR); 
    /* enabling Tx FIFO for transmitting*/
    IfxAsclin_enableTxFifoOutlet(asclinSFR, TRUE);   
    /* writing the ID byte */
    IfxAsclin_write8(asclinSFR, id, 1U);  
    /* setting THRQS flag */
    IfxAsclin_setTransmitHeaderRequestFlag(asclinSFR);            

    if (asclin->isInterruptMode == FALSE)                         /*Only for Polling Mode*/
    {
	    /* waiting until transmit header end acknowledgemnet */
        result |= IfxAsclin_Lin_waitForTransmittedHeader(asclin); 

        if (result == 1)
        {
            IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
        }
    }
    else
    {
        IfxAsclin_Lin_clearFlagsStatus(asclin);
        asclin->linFrameData.flags.txHeaderInProgress    = TRUE;
        asclin->linFrameData.flags.txHeaderErrorOccurred = FALSE;
    }
}


void IfxAsclin_Lin_sendResponse(IfxAsclin_Lin *asclin, uint8 *data, uint32 length)
{
    boolean     result    = 0;
    Ifx_ASCLIN *asclinSFR = asclin->asclin;                                 /* getting the pointer to ASCLIN registers from module handler*/
    IfxAsclin_setDataLength(asclinSFR, (IfxAsclin_DataLength)(length - 1)); /* set number of bytes to be transfered */
    IfxAsclin_clearAllFlags(asclinSFR);                                     /* clear all flags */
    IfxAsclin_flushTxFifo(asclinSFR);                                       /* flushing Tx FIFO */
    IfxAsclin_enableRxFifoInlet(asclinSFR, FALSE);                          /* disable Rx FIFO */
    IfxAsclin_enableTxFifoOutlet(asclinSFR, TRUE);                          /* enable Tx FIFO for transmitting */
    IfxAsclin_write8(asclinSFR, data, length);                              /* write the data bytes; */
    IfxAsclin_setTransmitResponseRequestFlag(asclinSFR);                    /* set TRRQS flag */
    result |= IfxAsclin_Lin_waitForTransmittedResponse(asclin);             /* wait until transmit response end acknowledgemnet */

    if (result == 1)
    {
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }
}


boolean IfxAsclin_Lin_waitForReceivedHeader(IfxAsclin_Lin *asclin)
{
    boolean result = 0;
	
    /* clear all aknowledgement and error flags status */
    IfxAsclin_Lin_clearFlagsStatus(asclin);     

    /* wait until receive header end acknowledgemnet has been detected  */
    while (asclin->acknowledgmentFlags.rxHeaderEnd != 1)
    {
        IfxAsclin_Lin_checkForReceivedHeaderFlags(asclin);

        if ((asclin->errorFlagsStatus.headerTimeout == 1)
            || (asclin->errorFlagsStatus.collisionDetectionError == 1)
            || (asclin->errorFlagsStatus.frameError == 1)
            || (asclin->errorFlagsStatus.linAutobaudDetectionError == 1)
            || (asclin->errorFlagsStatus.linParityError == 1))
        {
            result = 1;
            break;
        }
    }

    return result;
}


boolean IfxAsclin_Lin_waitForReceivedResponse(IfxAsclin_Lin *asclin)
{
    boolean result = 0;
	
    /* clear all aknowledgement and error flags status */
    IfxAsclin_Lin_clearFlagsStatus(asclin);     

    /* wait until receive response end acknowledgemnet has been detected  */
    while (asclin->acknowledgmentFlags.rxResponseEnd != 1)
    {
        IfxAsclin_Lin_checkForReceivedResponseFlags(asclin);

        if ((asclin->errorFlagsStatus.rxFifoOverflow == 1)
            || (asclin->errorFlagsStatus.collisionDetectionError == 1)
            || (asclin->errorFlagsStatus.frameError == 1)
            || (asclin->errorFlagsStatus.linChecksumError == 1)
            || (asclin->errorFlagsStatus.responseTimeout == 1)
            || (asclin->errorFlagsStatus.breakDetected == 1))
        {
            result = 1;
            break;
        }
    }

    return result;
}


boolean IfxAsclin_Lin_waitForTransmittedHeader(IfxAsclin_Lin *asclin)
{
    boolean result = 0;
	
    /* clear all aknowledgement and error flags status */
    IfxAsclin_Lin_clearFlagsStatus(asclin);     

    /* wait until transmit header end acknowledgemnet has been detected */
    while (asclin->acknowledgmentFlags.txHeaderEnd != 1)
    {
        IfxAsclin_Lin_checkForTransmittedHeaderFlags(asclin);

        if ((asclin->errorFlagsStatus.headerTimeout == 1)
            || (asclin->errorFlagsStatus.collisionDetectionError == 1)
            || (asclin->errorFlagsStatus.frameError == 1)
            || (asclin->errorFlagsStatus.linParityError == 1))
        {
            result = 1;
            break;
        }
    }

    return result;
}


boolean IfxAsclin_Lin_waitForTransmittedResponse(IfxAsclin_Lin *asclin)
{
    boolean result = 0;
	
    /* clear all aknowledgement and error flags status */
    IfxAsclin_Lin_clearFlagsStatus(asclin);     

    /* wait until transmit response end acknowledgemnet has been detected */
    while (asclin->acknowledgmentFlags.txResponseEnd != 1)
    {
        IfxAsclin_Lin_checkForTransmittedResponseFlags(asclin);

        if ((asclin->errorFlagsStatus.txFifoOverflow == 1)
            || (asclin->errorFlagsStatus.collisionDetectionError == 1)
            || (asclin->errorFlagsStatus.responseTimeout == 1)
            || (asclin->errorFlagsStatus.breakDetected == 1))
        {
            result = 1;
            break;
        }
    }

    return result;
}


void IfxAsclin_Lin_isrError(IfxAsclin_Lin *asclin)
{
    /* getting the pointer to ASCLIN registers from module handler*/
    Ifx_ASCLIN *asclinSFR = asclin->asclin; 

    /* store and clear the flags*/
    if (IfxAsclin_getLinParityErrorFlagStatus(asclinSFR))
    {
        IfxAsclin_clearLinParityErrorFlag(asclinSFR);
        asclin->errorFlagsStatus.linParityError = 1;
    }

    if (IfxAsclin_getFrameErrorFlagStatus(asclinSFR))
    {
        IfxAsclin_clearFrameErrorFlag(asclinSFR);
        asclin->errorFlagsStatus.frameError = 1;
    }

    if (IfxAsclin_getRxFifoOverflowFlagStatus(asclinSFR))
    {
        IfxAsclin_clearRxFifoOverflowFlag(asclinSFR);
        asclin->errorFlagsStatus.rxFifoOverflow = 1;
    }

    if (IfxAsclin_getTxFifoOverflowFlagStatus(asclinSFR))
    {
        IfxAsclin_clearTxFifoOverflowFlag(asclinSFR);
        asclin->errorFlagsStatus.txFifoOverflow = 1;
    }

    if (IfxAsclin_getHeaderTimeoutFlagStatus(asclinSFR))
    {
        IfxAsclin_clearHeaderTimeoutFlag(asclinSFR);
        asclin->errorFlagsStatus.headerTimeout = 1;
    }

    if (IfxAsclin_getResponseTimeoutFlagStatus(asclinSFR))
    {
        IfxAsclin_clearResponseTimeoutFlag(asclinSFR);
        asclin->errorFlagsStatus.responseTimeout = 1;
    }

    if (IfxAsclin_getBreakDetectedFlagStatus(asclinSFR))
    {
        IfxAsclin_clearBreakDetectedFlag(asclinSFR);
        asclin->errorFlagsStatus.breakDetected = 1;
    }

    if (IfxAsclin_getLinAutoBaudDetectionErrorFlagStatus(asclinSFR))
    {
        IfxAsclin_clearLinAutoBaudDetectionErrorFlag(asclinSFR);
        asclin->errorFlagsStatus.linAutobaudDetectionError = 1;
    }

    if (IfxAsclin_getLinChecksumErrorFlagStatus(asclinSFR))
    {
        IfxAsclin_clearLinChecksumErrorFlag(asclinSFR);
        asclin->errorFlagsStatus.linChecksumError = 1;
    }

    if (IfxAsclin_getCollisionDetectionErrorFlagStatus(asclinSFR))
    {
        IfxAsclin_clearCollisionDetectionErrorFlag(asclinSFR);
        asclin->errorFlagsStatus.collisionDetectionError = 1;
    }

    if (IfxAsclin_getTransmissionCompletedFlagStatus(asclinSFR))
    {
        IfxAsclin_clearTransmissionCompletedFlag(asclinSFR);
        asclin->acknowledgmentFlags.txCompleted = 1;
    }

    /*Update acknowledgment flags*/
    if ((asclin->linFrameData.flags.txHeaderInProgress == 1)
        && ((asclin->errorFlagsStatus.headerTimeout == 1)
            || (asclin->errorFlagsStatus.collisionDetectionError == 1)
            || (asclin->errorFlagsStatus.frameError == 1)
            || (asclin->errorFlagsStatus.linParityError == 1)))
    {
        asclin->linFrameData.flags.txHeaderErrorOccurred = TRUE;
        asclin->acknowledgmentFlags.txHeaderEnd          = 1;
        asclin->linFrameData.flags.txHeaderInProgress    = FALSE;
    }

    if ((asclin->linFrameData.flags.txResponseInProgress == 1)
        && ((asclin->errorFlagsStatus.txFifoOverflow == 1)
            || (asclin->errorFlagsStatus.collisionDetectionError == 1)
            || (asclin->errorFlagsStatus.responseTimeout == 1)
            || (asclin->errorFlagsStatus.breakDetected == 1)))
    {
        asclin->linFrameData.flags.txResponseErrorOccurred = TRUE;
        asclin->acknowledgmentFlags.txResponseEnd          = 1;
        asclin->linFrameData.flags.txResponseInProgress    = FALSE;
    }

    if ((asclin->linFrameData.flags.rxHeaderInProgress == 1)
        && ((asclin->errorFlagsStatus.rxFifoOverflow == 1)
            || (asclin->errorFlagsStatus.headerTimeout == 1)
            || (asclin->errorFlagsStatus.collisionDetectionError == 1)
            || (asclin->errorFlagsStatus.frameError == 1)
            || (asclin->errorFlagsStatus.linAutobaudDetectionError == 1)
            || (asclin->errorFlagsStatus.linParityError == 1)))
    {
        asclin->linFrameData.flags.rxHeaderErrorOccurred = TRUE;
        asclin->acknowledgmentFlags.rxHeaderEnd          = 1;
        asclin->linFrameData.flags.rxHeaderInProgress    = FALSE;
    }

    if ((asclin->linFrameData.flags.rxResponseInProgress == 1)
        && ((asclin->errorFlagsStatus.rxFifoOverflow == 1)
            || (asclin->errorFlagsStatus.collisionDetectionError == 1)
            || (asclin->errorFlagsStatus.frameError == 1)
            || (asclin->errorFlagsStatus.linChecksumError == 1)
            || (asclin->errorFlagsStatus.responseTimeout == 1)
            || (asclin->errorFlagsStatus.breakDetected == 1)))
    {
        asclin->linFrameData.flags.rxResponseErrorOccurred = TRUE;
        asclin->acknowledgmentFlags.rxResponseEnd          = 1;
        asclin->linFrameData.flags.rxResponseInProgress    = FALSE;
    }
}


void IfxAsclin_Lin_isrReceive(IfxAsclin_Lin *asclin)
{
    /* getting the pointer to ASCLIN registers from module handler*/
    Ifx_ASCLIN *asclinSFR = asclin->asclin; 

    if (IfxAsclin_getRxHeaderEndFlagStatus(asclinSFR))
    {
        IfxAsclin_clearRxHeaderEndFlag(asclinSFR);
	    /* read the ID byte*/
        IfxAsclin_Lin_readHeader(asclin, &(asclin->linFrameData.headerID));
        asclin->acknowledgmentFlags.rxHeaderEnd       = 1;
        asclin->linFrameData.flags.rxHeaderInProgress = FALSE;
	    /* TX FIFO Outlet is disabled*/
        asclinSFR->TXFIFOCON.B.ENO                    = 0;                  
    }

    if (IfxAsclin_getRxResponseEndFlagStatus(asclinSFR))
    {
        IfxAsclin_clearRxResponseEndFlag(asclinSFR);
	    /* read the data bytes */
        IfxAsclin_Lin_readResponse(asclin, &(asclin->linFrameData.rxResponseData[0]), (asclin->linFrameData.rxResponseLength)); 
        asclin->acknowledgmentFlags.rxResponseEnd       = 1;
        asclin->linFrameData.flags.rxResponseInProgress = FALSE;
    }
}


void IfxAsclin_Lin_isrTransmit(IfxAsclin_Lin *asclin)
{
    /* getting the pointer to ASCLIN registers from module handler*/
    Ifx_ASCLIN *asclinSFR = asclin->asclin; 

    /* clear H/w Flag and update S/w Flags */
    if (IfxAsclin_getTxHeaderEndFlagStatus(asclinSFR))
    {
        IfxAsclin_clearTxHeaderEndFlag(asclinSFR);
        asclin->acknowledgmentFlags.txHeaderEnd       = 1;
        asclin->linFrameData.flags.txHeaderInProgress = FALSE;
    }

    if (IfxAsclin_getTxResponseEndFlagStatus(asclinSFR))
    {
        IfxAsclin_clearTxResponseEndFlag(asclinSFR);
        asclin->acknowledgmentFlags.txResponseEnd       = 1;
        asclin->linFrameData.flags.txResponseInProgress = FALSE;
    }
}


void IfxAsclin_Lin_sendFrame(IfxAsclin_Lin *asclin, IfxAsclin_Lin_PduType *pduptr)
{
    /* getting the pointer to ASCLIN registers from module handler*/
    Ifx_ASCLIN *asclinSFR = asclin->asclin;  
    
    /* setting the checksum mode (classic/enhanced)*/
    IfxAsclin_setChecksumMode(asclinSFR, pduptr->checksumMode); 
    asclin->linFrameData.headerID = pduptr->pid;

    if (pduptr->direction == IfxAsclin_Lin_Direction_TransmitHeader)
    {
        asclin->linFrameData.flags.txSendResponse   = FALSE;
        asclin->linFrameData.txResponseLength       = 0;
        asclin->linFrameData.flags.txSendHeaderOnly = TRUE;

        /*Enable Interrupt flags for Header Transmission*/
        Ifx_ASCLIN_FLAGSENABLE flagsenable;
        flagsenable.U            = 0;
        flagsenable.B.THE        = 1;
        flagsenable.B.HTE        = 1;
        flagsenable.B.CEE        = 1;
        flagsenable.B.FEE        = 1;
        flagsenable.B.LPE        = 1;
        asclinSFR->FLAGSENABLE.U = flagsenable.U;

        IfxAsclin_Lin_sendHeader(asclin, &(pduptr->pid));
    }

    else if ((pduptr->direction == IfxAsclin_Lin_Direction_TransmitHeaderAndResponse) || (pduptr->direction == IfxAsclin_Lin_Direction_TransmitHeaderAndReceiveResponse))
    {
	    /* set number of bytes to be transfered */
        IfxAsclin_setDataLength(asclinSFR, (IfxAsclin_DataLength)(pduptr->dataLength - 1)); 

        /*Configure RXFIFO*/
        Ifx_ASCLIN_RXFIFOCON rxfifocon;
        rxfifocon.U            = asclinSFR->RXFIFOCON.U;

        rxfifocon.B.BUF        = 0; /*RX in FIFO Mode*/
        rxfifocon.B.FLUSH      = 1; /*Empty Rx Fifo*/
        rxfifocon.B.ENI        = 1; /*RX FIFO Inlet is enabled*/

        asclinSFR->RXFIFOCON.U = rxfifocon.U;

        /*Configure TXFIFO*/
        Ifx_ASCLIN_TXFIFOCON txfifocon;
        txfifocon.U            = asclinSFR->TXFIFOCON.U;

        txfifocon.B.FLUSH      = 1; /*Empty Tx Fifo*/
        txfifocon.B.ENO        = 1; /*TX FIFO Outlet is enabled*/

        asclinSFR->TXFIFOCON.U = txfifocon.U;

        /*Clear interrupt event flags*/
        IfxAsclin_clearAllFlags(asclinSFR);                /* clearing all flags*/
        IfxAsclin_Lin_clearFlagsStatus(asclin);

        Ifx_ASCLIN_FLAGSENABLE flagsenable;
        flagsenable.U = 0;

        if (pduptr->direction == IfxAsclin_Lin_Direction_TransmitHeaderAndResponse)
        {
            /*Enable Tx interrupts*/
            flagsenable.B.THE = 1;
            flagsenable.B.TRE = 1;
            flagsenable.B.HTE = 1;

            /*Enable Ex interrupts*/
            flagsenable.B.TFOE                                 = 1;
            flagsenable.B.CEE                                  = 1;
            flagsenable.B.FEE                                  = 1;
            flagsenable.B.RTE                                  = 1;
            flagsenable.B.LPE                                  = 1;
            flagsenable.B.BDE                                  = 1;

            asclin->linFrameData.flags.txSendResponse          = TRUE;
            asclin->linFrameData.flags.txSendHeaderOnly        = FALSE;
            asclin->linFrameData.txResponseLength              = pduptr->dataLength;

            asclin->linFrameData.flags.txHeaderInProgress      = TRUE;
            asclin->linFrameData.flags.txHeaderErrorOccurred   = FALSE;
            asclin->linFrameData.flags.txResponseInProgress    = TRUE;
            asclin->linFrameData.flags.txResponseErrorOccurred = FALSE;
        }
        else if (pduptr->direction == IfxAsclin_Lin_Direction_TransmitHeaderAndReceiveResponse)
        {
            /*Enable Rx interrupts*/
            flagsenable.B.RRE = 1;
            flagsenable.B.THE = 1;
            flagsenable.B.RHE = 1;
            flagsenable.B.HTE = 1;

            /*Enable Ex interrupts*/
            flagsenable.B.RFOE                                 = 1;
            flagsenable.B.CEE                                  = 1;
            flagsenable.B.FEE                                  = 1;
            flagsenable.B.RTE                                  = 1;
            flagsenable.B.LCE                                  = 1;
            flagsenable.B.BDE                                  = 1;

	        /*RX FIFO Inlet is enabled*/
            asclinSFR->RXFIFOCON.B.ENI                         = 1; 

            asclin->linFrameData.flags.txSendResponse          = TRUE;
            asclin->linFrameData.flags.txSendHeaderOnly        = FALSE;
            asclin->linFrameData.rxResponseLength              = pduptr->dataLength;
            asclin->linFrameData.flags.txHeaderInProgress      = TRUE;
            asclin->linFrameData.flags.txHeaderErrorOccurred   = FALSE;
            asclin->linFrameData.flags.rxResponseInProgress    = TRUE;
            asclin->linFrameData.flags.rxResponseErrorOccurred = FALSE;
        }

        asclinSFR->FLAGSENABLE.U = flagsenable.U;

	    /* writing the ID byte */
        IfxAsclin_write8(asclinSFR, &(pduptr->pid), 1U);                      

        if (pduptr->direction == IfxAsclin_Lin_Direction_TransmitHeaderAndResponse)
        {
	        /* writing data bytes */
            IfxAsclin_write8(asclinSFR, pduptr->dataPtr, pduptr->dataLength);                     

            Ifx_ASCLIN_FLAGSSET flagsset;
            flagsset.U            = asclinSFR->FLAGSSET.U;

            flagsset.B.THRQS      = 1;
            flagsset.B.TRRQS      = 1;

            asclinSFR->FLAGSSET.U = flagsset.U;
        }

        else if (pduptr->direction == IfxAsclin_Lin_Direction_TransmitHeaderAndReceiveResponse)
        {
            //asclinSFR->RXFIFOCON.B.ENI = 1; /*RX FIFO Inlet is enabled*/
            asclinSFR->FLAGSSET.B.THRQS = 1;
        }
    }
}
