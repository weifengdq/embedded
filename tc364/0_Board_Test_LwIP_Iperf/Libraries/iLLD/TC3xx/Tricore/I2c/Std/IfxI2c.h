/**
 * \file IfxI2c.h
 * \brief I2C  basic functionality
 * \ingroup IfxLld_I2c
 *
 * \version iLLD_1_20_0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_I2c_Std_enums Enumerations
 * \ingroup IfxLld_I2c_Std
 * \defgroup IfxLld_I2c_Std_functions Functions
 * \ingroup IfxLld_I2c_Std
 * \defgroup IfxLld_I2c_Std_structures Data Structures
 * \ingroup IfxLld_I2c_Std
 */

#ifndef IFXI2C_H
#define IFXI2C_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxI2c_cfg.h"
#include "Scu/Std/IfxScuWdt.h"
#include "Scu/Std/IfxScuCcu.h"
#include "IfxI2c_bf.h"
#include "_PinMap/IfxI2c_PinMap.h"
#include "Src/Std/IfxSrc.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Master code for high speed mode
 */
#define IFXI2C_HIGHSPEED_MASTER_CODE (0xEU)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_I2c_Std_enums
 * \{ */
/** \brief Selects width of address bits (7 or 10 bits)
 * Definition in Ifx_I2C.ADDRCFG.B.TBAM
 */
typedef enum
{
    IfxI2c_AddressMode_7Bit  = 0, /**< \brief sets 7 bit address */
    IfxI2c_AddressMode_10Bit = 1  /**< \brief sets 10 bit address */
} IfxI2c_AddressMode;

typedef enum
{
    IfxI2c_BusStatus_idle        = 0, /**< \brief idle */
    IfxI2c_BusStatus_started     = 1, /**< \brief started */
    IfxI2c_BusStatus_busyMaster  = 2, /**< \brief busy Master */
    IfxI2c_BusStatus_remoteSlave = 3  /**< \brief remote Slave */
} IfxI2c_BusStatus;

/** \brief enables DTR interrupt flags
 * Definition in Ifx.I2C.IMSC.U
 */
typedef enum
{
    IfxI2c_DtrInterruptSource_lastSingleRequest = IFX_I2C_IMSC_LSREQ_INT_OFF,  /**< \brief last single service request */
    IfxI2c_DtrInterruptSource_singleRequest     = IFX_I2C_IMSC_SREQ_INT_OFF,   /**< \brief single service request */
    IfxI2c_DtrInterruptSource_lastBurstRequest  = IFX_I2C_IMSC_LBREQ_INT_OFF,  /**< \brief last burst service request */
    IfxI2c_DtrInterruptSource_burstRequest      = IFX_I2C_IMSC_BREQ_INT_OFF    /**< \brief burst service request */
} IfxI2c_DtrInterruptSource;

/** \brief enable error interrupt request source
 * Definition in Ifx.I2C.ERRIRQSM.U
 */
typedef enum
{
    IfxI2c_ErrorInterruptSource_rxFifoUnderflow = IFX_I2C_ERRIRQSM_RXF_UFL_OFF,  /**< \brief receive fifo underflow service request */
    IfxI2c_ErrorInterruptSource_rxFifoOverflow  = IFX_I2C_ERRIRQSM_RXF_OFL_OFF,  /**< \brief receive fifo overflow service request */
    IfxI2c_ErrorInterruptSource_txFifoUnderflow = IFX_I2C_ERRIRQSM_TXF_UFL_OFF,  /**< \brief transmit fifo underflow service request */
    IfxI2c_ErrorInterruptSource_txFifoOverflow  = IFX_I2C_ERRIRQSM_TXF_OFL_OFF   /**< \brief transmit fifo overflow service request */
} IfxI2c_ErrorInterruptSource;

/** \brief Select speed mode. Standard and Fast or High Speed mode.
 */
typedef enum
{
    IfxI2c_Mode_StandardAndFast = 0,  /**< \brief Sets Standard and Fast speed mode */
    IfxI2c_Mode_HighSpeed       = 1   /**< \brief Sets HighSpeed Mode */
} IfxI2c_Mode;

typedef enum
{
    IfxI2c_PinSelect_a = 0,
    IfxI2c_PinSelect_b = 1,
    IfxI2c_PinSelect_c = 2,
    IfxI2c_PinSelect_d = 3,
    IfxI2c_PinSelect_e = 4,
    IfxI2c_PinSelect_f = 5,
    IfxI2c_PinSelect_g = 6,
    IfxI2c_PinSelect_h = 7
} IfxI2c_PinSelect;

/** \brief enable protocol interrupt source
 * Definition in Ifx.I2C.PIRQSM.U
 */
typedef enum
{
    IfxI2c_ProtocolInterruptSource_addressMatch           = IFX_I2C_PIRQSM_AM_OFF,     /**< \brief address match service request */
    IfxI2c_ProtocolInterruptSource_generalCall            = IFX_I2C_PIRQSM_GC_OFF,     /**< \brief general call service request */
    IfxI2c_ProtocolInterruptSource_masterCode             = IFX_I2C_PIRQSM_MC_OFF,     /**< \brief master code service request */
    IfxI2c_ProtocolInterruptSource_arbitrationLost        = IFX_I2C_PIRQSM_AL_OFF,     /**< \brief arbitration lost service request */
    IfxI2c_ProtocolInterruptSource_notAcknowledgeReceived = IFX_I2C_PIRQSM_NACK_OFF,   /**< \brief not acknowledge received service request */
    IfxI2c_ProtocolInterruptSource_transmissionEnd        = IFX_I2C_PIRQSM_TX_END_OFF, /**< \brief transmission end service request */
    IfxI2c_ProtocolInterruptSource_receiveMode            = IFX_I2C_PIRQSM_RX_OFF      /**< \brief receive mode service request */
} IfxI2c_ProtocolInterruptSource;

/** \brief Enable/disable the sensitivity of the module to sleep signal\n
 * Definition in Ifx_I2C.CLC1.B.EDIS
 */
typedef enum
{
    IfxI2c_SleepMode_enable  = 0, /**< \brief enables sleep mode */
    IfxI2c_SleepMode_disable = 1  /**< \brief disables sleep mode */
} IfxI2c_SleepMode;

/** \} */

/** \brief set interrupt request
 * Definition in Ifx.I2C.ISR.U
 */
typedef enum
{
    IfxI2c_InterruptRequest_lastSingleRequest = IFX_I2C_ISR_LSREQ_INT_OFF,   /**< \brief last single request interrupt */
    IfxI2c_InterruptRequest_SingleRequest     = IFX_I2C_ISR_SREQ_INT_OFF,    /**< \brief single request interrupt */
    IfxI2c_InterruptRequest_lastBurstRequest  = IFX_I2C_ISR_LBREQ_INT_OFF,   /**< \brief last burst request interrupt */
    IfxI2c_InterruptRequest_burstRequest      = IFX_I2C_ISR_BREQ_INT_OFF,    /**< \brief burst request interrupt */
    IfxI2c_InterruptRequest_i2cError          = IFX_I2C_ISR_I2C_ERR_INT_OFF, /**< \brief i2c error interrupt */
    IfxI2c_InterruptRequest_i2cProtocol       = IFX_I2C_ISR_I2C_P_INT_OFF    /**< \brief i2c protocol interrupt */
} IfxI2c_InterruptRequest;

/** \brief Configure as master or slave
 * Definition in Ifx_I2C.ADDRCFG.B.MnS
 */
typedef enum
{
    IfxI2c_MasterNotSlave_slave  = 0, /**< \brief sets as slave */
    IfxI2c_MasterNotSlave_master = 1  /**< \brief sets as master */
} IfxI2c_MasterNotSlave;

/** \brief Selects RX burst size
 * Definition in Ifx_I2C.FIFOCFG.B.RXBS
 */
typedef enum
{
    IfxI2c_RxBurstSize_1Word = 0,  /**< \brief one word */
    IfxI2c_RxBurstSize_2Word = 1,  /**< \brief two word */
    IfxI2c_RxBurstSize_4Word = 2   /**< \brief four word */
} IfxI2c_RxBurstSize;

/** \brief Selects RX FIFO alignment
 * Definition in Ifx_I2C.FIFOCFG.B.RXFA
 */
typedef enum
{
    IfxI2c_RxFifoAlignment_byte     = 0,  /**< \brief byte aligned */
    IfxI2c_RxFifoAlignment_halfWord = 1,  /**< \brief half word aligned */
    IfxI2c_RxFifoAlignment_word     = 2   /**< \brief word aligned */
} IfxI2c_RxFifoAlignment;

/** \brief Selects RX FIFO flow control
 * Definition in Ifx_I2C.FIFOCFG.B.RXFC
 */
typedef enum
{
    IfxI2c_RxFifoFlowControl_disable = 0,  /**< \brief rx fifo not as flow controller */
    IfxI2c_RxFifoFlowControl_enable  = 1   /**< \brief rx fifo as flow controller */
} IfxI2c_RxFifoFlowControl;

/** \brief Selects TX burst size
 * Definition in Ifx_I2C.FIFOCFG.B.TXBS
 */
typedef enum
{
    IfxI2c_TxBurstSize_1Word = 0,  /**< \brief one word */
    IfxI2c_TxBurstSize_2Word = 1,  /**< \brief two word */
    IfxI2c_TxBurstSize_4Word = 2   /**< \brief four word */
} IfxI2c_TxBurstSize;

/** \brief Selects TX FIFO alignment
 * Definition in Ifx_I2C.FIFOCFG.B.TXFA
 */
typedef enum
{
    IfxI2c_TxFifoAlignment_byte     = 0,  /**< \brief byte aligned */
    IfxI2c_TxFifoAlignment_halfWord = 1,  /**< \brief half word aligned */
    IfxI2c_TxFifoAlignment_word     = 2   /**< \brief word aligned */
} IfxI2c_TxFifoAlignment;

/** \brief Selects TX FIFO flow control
 * Definition in Ifx_I2C.FIFOCFG.B.TXFC
 */
typedef enum
{
    IfxI2c_TxFifoFlowControl_disable = 0,  /**< \brief tx fifo not as flow controller */
    IfxI2c_TxFifoFlowControl_enable  = 1   /**< \brief tx fifo as flow controller */
} IfxI2c_TxFifoFlowControl;

/**
 * \brief SDA Delay Stages for Data Hold Time in Standard and Fast modes
 * Definition in Ifx_I2C.TIMCFG.B.SDA_DEL_HD_DAT
 */
typedef enum
{
	IfxI2c_SdaDelayStages_3 = 0,
    IfxI2c_SdaDelayStages_4,
    IfxI2c_SdaDelayStages_5,
    IfxI2c_SdaDelayStages_6,
    IfxI2c_SdaDelayStages_7,
    IfxI2c_SdaDelayStages_8,
    IfxI2c_SdaDelayStages_9,
    IfxI2c_SdaDelayStages_10,
    IfxI2c_SdaDelayStages_11,
    IfxI2c_SdaDelayStages_12,
    IfxI2c_SdaDelayStages_13,
    IfxI2c_SdaDelayStages_14,
    IfxI2c_SdaDelayStages_15,
    IfxI2c_SdaDelayStages_16,
    IfxI2c_SdaDelayStages_17,
    IfxI2c_SdaDelayStages_18,
    IfxI2c_SdaDelayStages_19,
    IfxI2c_SdaDelayStages_20,
    IfxI2c_SdaDelayStages_21,
    IfxI2c_SdaDelayStages_22,
    IfxI2c_SdaDelayStages_23,
    IfxI2c_SdaDelayStages_24,
    IfxI2c_SdaDelayStages_25,
    IfxI2c_SdaDelayStages_26,
    IfxI2c_SdaDelayStages_27,
    IfxI2c_SdaDelayStages_28,
    IfxI2c_SdaDelayStages_29,
    IfxI2c_SdaDelayStages_30,
    IfxI2c_SdaDelayStages_31,
    IfxI2c_SdaDelayStages_32,
    IfxI2c_SdaDelayStages_33,
    IfxI2c_SdaDelayStages_34,
    IfxI2c_SdaDelayStages_35,
    IfxI2c_SdaDelayStages_36,
    IfxI2c_SdaDelayStages_37,
    IfxI2c_SdaDelayStages_38,
    IfxI2c_SdaDelayStages_39,
    IfxI2c_SdaDelayStages_40,
    IfxI2c_SdaDelayStages_41,
    IfxI2c_SdaDelayStages_42,
    IfxI2c_SdaDelayStages_43,
    IfxI2c_SdaDelayStages_44,
    IfxI2c_SdaDelayStages_45,
    IfxI2c_SdaDelayStages_46,
    IfxI2c_SdaDelayStages_47,
    IfxI2c_SdaDelayStages_48,
    IfxI2c_SdaDelayStages_49,
    IfxI2c_SdaDelayStages_50,
    IfxI2c_SdaDelayStages_51,
    IfxI2c_SdaDelayStages_52,
    IfxI2c_SdaDelayStages_53,
    IfxI2c_SdaDelayStages_54,
    IfxI2c_SdaDelayStages_55,
    IfxI2c_SdaDelayStages_56,
    IfxI2c_SdaDelayStages_57,
    IfxI2c_SdaDelayStages_58,
    IfxI2c_SdaDelayStages_59,
    IfxI2c_SdaDelayStages_60,
    IfxI2c_SdaDelayStages_61,
    IfxI2c_SdaDelayStages_62,
    IfxI2c_SdaDelayStages_63,
    IfxI2c_SdaDelayStages_64,
    IfxI2c_SdaDelayStages_65,
    IfxI2c_SdaDelayStages_66
} IfxI2c_SdaDelayStages;

/**
 * \brief SDA Delay Stages for Data Hold Time in High-speed Mode
 * Definition in Ifx_I2C.TIMCFG.B.HS_SDA_DEL_HD_DAT
 */
typedef enum
{
	IfxI2c_SdaHsModeDelayStages_3 = 0,
	IfxI2c_SdaHsModeDelayStages_4,
	IfxI2c_SdaHsModeDelayStages_5,
	IfxI2c_SdaHsModeDelayStages_6,
	IfxI2c_SdaHsModeDelayStages_7,
	IfxI2c_SdaHsModeDelayStages_8,
	IfxI2c_SdaHsModeDelayStages_9,
	IfxI2c_SdaHsModeDelayStages_10
} IfxI2c_SdaHsModeDelayStages;

/**
 * \brief SCL Delay Stages for Hold Time Start (Restart) Bit
 * Definition in Ifx_I2C.TIMCFG.B.SCL_DEL_HD_STA
 */
typedef enum
{
	IfxI2c_SclDelayStages_12 = 0,
	IfxI2c_SclDelayStages_13,
	IfxI2c_SclDelayStages_14,
	IfxI2c_SclDelayStages_15,
	IfxI2c_SclDelayStages_16,
	IfxI2c_SclDelayStages_17,
	IfxI2c_SclDelayStages_18,
	IfxI2c_SclDelayStages_19
} IfxI2c_SclDelayStages;

/**
 * \brief SDA Delay Stages for Start/Stop bit in High-speed Mode
 * Definition in Ifx_I2C.TIMCFG.B.HS_SDA_DEL
 */
typedef enum
{
	IfxI2c_SdaHsModeStartStopDelayStages_3 = 0,
	IfxI2c_SdaHsModeStartStopDelayStages_4,
	IfxI2c_SdaHsModeStartStopDelayStages_5,
	IfxI2c_SdaHsModeStartStopDelayStages_6,
	IfxI2c_SdaHsModeStartStopDelayStages_7,
	IfxI2c_SdaHsModeStartStopDelayStages_8,
	IfxI2c_SdaHsModeStartStopDelayStages_9,
	IfxI2c_SdaHsModeStartStopDelayStages_10
} IfxI2c_SdaHsModeStartStopDelayStages;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \brief Structure for Address configuration register
 */
typedef struct
{
    uint32             slaveAddress;               /**< \brief slave address, use default value 0 when used in master mode */
    IfxI2c_AddressMode addressMode;                /**< \brief Ten bit address mode */
    boolean            generalCallEnable;          /**< \brief General call enable */
    boolean            masterCodeEnable;           /**< \brief Master code enable */
    boolean            stopOnNotAcknowledge;       /**< \brief stop on Not-acknowledge */
    boolean            stopOnPacketEnd;            /**< \brief stop on packet end */
} IfxI2c_AddrConfig;

/** \brief Structure for FIFO configuration register
 */
typedef struct
{
    IfxI2c_RxBurstSize       rxBurstSize;                /**< \brief rx burst size */
    IfxI2c_TxBurstSize       txBurstSize;                /**< \brief tx burst size */
    IfxI2c_RxFifoAlignment   rxFifoAlignment;            /**< \brief rx fifo alignment */
    IfxI2c_TxFifoAlignment   txFifoAlignment;            /**< \brief tx fifo alignment */
    IfxI2c_RxFifoFlowControl rxFifoFlowControl;          /**< \brief rx fifo flow control */
    IfxI2c_TxFifoFlowControl txFifoFlowControl;          /**< \brief tx fifo flow control */
    boolean                  clearRequestBehavior;       /**< \brief clear request behavior configuration */
} IfxI2c_FifoConfig;

/** \brief Structure for Timing configuration
 */
typedef struct
{
	IfxI2c_SdaDelayStages                 sdaDelHdDat;      	/**< \brief SDA Delay Stages for Data Hold Time in Standard and Fast modes (6-bits) */
	IfxI2c_SdaHsModeDelayStages           hsSdaDelHdDat; 		/**< \brief SDA Delay Stages for Data Hold Time in High-Speed Mode (3-bits) */
	IfxI2c_SclDelayStages                 sclDelHdSta;      	/**< \brief SCL Delay Stages for Hold Time Start (Restart) Bit (3-bits) */
	boolean                               enSclLowLen;     	    /**< \brief Enable Direct Configuration of SCL Low Period Length in Fast Mode (1-bit) */
	boolean                               fsSclLow;        	    /**< \brief Set Fast Mode SCL Low Period Timing (1-bit) */
	IfxI2c_SdaHsModeStartStopDelayStages  hsSdaDel; 	        /**< \brief SDA Delay Stages for Start/Stop Bit in High-Speed Mode (5-bits) */
    uint8 								  sclLowLen;        	/**< \brief SCL Low Period Length in Fast Mode (8-bits) */
} IfxI2c_TimingConfig;

/** \addtogroup IfxLld_I2c_Std_structures
 * \{ */
/** \brief Pin Structure
 */
typedef struct
{
    IfxI2c_Scl_InOut *scl;
    IfxI2c_Sda_InOut *sda;
    IfxPort_PadDriver padDriver;
} IfxI2c_Pins;

/** \} */

/** \brief Structure for Address and FIFO configuration registers
 */
typedef struct
{
    IfxI2c_AddrConfig addressConfig;       /**< \brief address config */
    IfxI2c_FifoConfig fifoConfig;          /**< \brief fifo config */
} IfxI2c_Config;

/** \addtogroup IfxLld_I2c_Std_functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Checks if the I2C bus is currently free for new transactions.
 *
 * \param[in] i2c Pointer to the I2C module handle.
 *
 * \retval TRUE  The bus is free and ready for new transactions.
 *         FALSE The bus is currently busy and cannot accept new transactions.
 */
IFX_INLINE boolean IfxI2c_busIsFree(Ifx_I2C *i2c);

/**
 * \brief Clears all DTR (Data Transfer Ready) Interrupt Sources for the I2C module.
 *
 * \param[inout] i2c Pointer to the I2C module handle.
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_clearAllDtrInterruptSources(Ifx_I2C *i2c);

/**
 * \brief Clears all Error Interrupt Sources for the I2C module.
 *
 * \param[inout] i2c Pointer to the I2C module handle.
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_clearAllErrorInterruptSources(Ifx_I2C *i2c);

/**
 * \brief Clears all Protocol Interrupt Sources for the I2C module.
 *
 * \param[inout] i2c Pointer to the I2C module handle.
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_clearAllProtocolInterruptSources(Ifx_I2C *i2c);

/**
 * \brief Clears the specified source of DTR (Data Transfer Ready) Interrupt for the I2C module.
 *
 * \param[inout] i2c    Pointer to the I2C module handle.
 * \param[in]    source DTR interrupt Source to be cleared.
 * 				        Range: \ref IfxI2c_DtrInterruptSource
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_clearDtrInterruptSource(Ifx_I2C *i2c, IfxI2c_DtrInterruptSource source);

/**
 * \brief Clears the specified source of Error Interrupt for the I2C instance.
 *
 * \param[inout] i2c    Pointer to the I2C module handle.
 * \param[in]    source Error interrupt Source to be cleared.
 * 					    Range: \ref IfxI2c_ErrorInterruptSource
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_clearErrorInterruptSource(Ifx_I2C *i2c, IfxI2c_ErrorInterruptSource source);

/**
 * \brief Clears the specified source of Protocol Interrupt for the I2C module.
 *
 * \param[inout] i2c    Pointer to the I2C module handle.
 * \param[in]    source Protocol interrupt Source to be cleared.
 *                      Range: \ref IfxI2c_ProtocolInterruptSource
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_clearProtocolInterruptSource(Ifx_I2C *i2c, IfxI2c_ProtocolInterruptSource source);

/**
 * \brief Clears the data Request Buffer for the I2C module.
 *
 * \param[inout] i2c Pointer to the I2C module handle.
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_clearRequestBuffer(Ifx_I2C *i2c);

/**
 * \brief Disables the specified source of DTR (Data Transfer Ready) Interrupt for the I2C module.
 *
 * \param[inout] i2c    Pointer to the I2C module handle.
 * \param [in]   source DTR Interrupt Source to disable.
 *             		    Range: \ref IfxI2c_DtrInterruptSource
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_disableDtrInterruptSource(Ifx_I2C *i2c, IfxI2c_DtrInterruptSource source);

/**
 * \brief Disables the Error Interrupt Flag for the I2C module.
 *
 * \param[inout] i2c Pointer to the I2C module handle.
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_disableErrorInterruptFlag(Ifx_I2C *i2c);

/**
 * \brief Disables the specified source of Error Interrupt for the I2C instance.
 *
 * \param[inout] i2c    Pointer to the I2C module handle.
 * \param[in]    source Error Interrupt Source to disable.
 * 					    Range: \ref IfxI2c_ErrorInterruptSource
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_disableErrorInterruptSource(Ifx_I2C *i2c, IfxI2c_ErrorInterruptSource source);

/**
 * \brief Disables the Protocol Interrupt Flag for the specified I2C instance.
 *
 * \param[inout] i2c Pointer to the I2C module handle.
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_disableProtocolInterruptFlag(Ifx_I2C *i2c);

/**
 * \brief Disables the specified Protocol Interrupt Source for the I2C module.
 *
 * \param[inout] i2c    Pointer to the I2C module handle.
 * \param[in]    source The Protocol Interrupt Source to disable.
 * 				        Range: \ref IfxI2c_ProtocolInterruptSource
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_disableProtocolInterruptSource(Ifx_I2C *i2c, IfxI2c_ProtocolInterruptSource source);

/**
 * \brief Enables the specified DTR (Data Transfer Request) Interrupt Source for the given I2C module.
 *
 * \param[inout] i2c    Pointer to the I2C module handle.
 * \param[in]    source DTR Interrupt Source to enable.
 * 					    Range: \ref IfxI2c_DtrInterruptSource
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_enableDtrInterruptSource(Ifx_I2C *i2c, IfxI2c_DtrInterruptSource source);

/**
 * \brief Enables the Error Interrupt Flag for the I2C module.
 * 
 * \param[inout] i2c Pointer to the I2C module handle.
 * 
 * \retval None
 */
IFX_INLINE void IfxI2c_enableErrorInterruptFlag(Ifx_I2C *i2c);

/**
 * \brief Enables the specified source of Error Interrupt for the I2C module.
 *
 * \param[inout] i2c    Pointer to the I2C module handle.
 * \param[in]    source Error Interrupt Source to enable.
 * 					    Range: \ref IfxI2c_ErrorInterruptSource
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_enableErrorInterruptSource(Ifx_I2C *i2c, IfxI2c_ErrorInterruptSource source);

/**
 * \brief Enables the Protocol Interrupt Flag for the I2C module.
 *
 * \param[inout] i2c Pointer to the I2C module handle.
 * 
 * \retval None
 */
IFX_INLINE void IfxI2c_enableProtocolInterruptFlag(Ifx_I2C *i2c);

/**
 * \brief Enables the specified source of Protocol Interrupt for I2C communication.
 *
 * \param[inout] i2c    Pointer to the I2C module handle.
 * \param[in]    source The Protocol Interrupt Source to be enabled.
 *					    Range: \ref IfxI2c_ProtocolInterruptSource
 * \retval None
 */
IFX_INLINE void IfxI2c_enableProtocolInterruptSource(Ifx_I2C *i2c, IfxI2c_ProtocolInterruptSource source);

/**
 * \brief Retrieves the current status of the I2C Bus.
 *
 * \param[in] i2c Pointer to the I2C module handle.
 *
 * \retval IfxI2c_BusStatus The current status of the I2C Bus. Possible Bus staus:
 * 							(\ref IfxI2c_BusStatus)
 * 							- IfxI2c_BusStatus_idle  		I2C-bus is free (no start condition detected).
 * 							- IfxI2c_BusStatus_started      A start condition has been detected on the bus (bus busy).
 * 							- IfxI2c_BusStatus_busyMaster   The device is working as master and has claimed the control on the I2C-bus (busy master).
 * 							- IfxI2c_BusStatus_remoteSlave  A remote master has accessed this device as slave.
 */
IFX_INLINE IfxI2c_BusStatus IfxI2c_getBusStatus(Ifx_I2C *i2c);

/**
 * \brief Returns the SRC pointer for I2C DTR (Data Transmit Ready) interrupt
 *
 * \param[in] i2c Pointer to the I2C module handle.
 *
 * \retval Ifx_SRC_SRCR* Pointer to the SRC register for I2C DTR interrupt
 */
IFX_INLINE volatile Ifx_SRC_SRCR *IfxI2c_getDtrSrcPointer(Ifx_I2C *i2c);

/**
 * \brief Retrieves the current raw status of a specified DTR (Data Transfer Request) Interrupt Source.
 *
 * \param[in] i2c    Pointer to the I2C module handle.
 * \param[in] source The DTR Interrupt Source to check.
 * 					 Range: \ref IfxI2c_DtrInterruptSource
 *
 * \retval TRUE  The specified DTR Interrupt Source is active.
 *         FALSE The specified DTR Interrupt Source is not active.
 */
IFX_INLINE boolean IfxI2c_getDtrinterruptSourceStatus(Ifx_I2C *i2c, IfxI2c_DtrInterruptSource source);

/**
 * \brief Returns the current status of the Error Interrupt Flag.
 *
 * \param[in] i2c Pointer to the I2C module handle.
 *
 * \retval TRUE  The Error Interrupt Flag is set.
 * 		   FALSE The Error Interrupt Flag is not set.
 */
IFX_INLINE boolean IfxI2c_getErrorInterruptFlagStatus(Ifx_I2C *i2c);

/**
 * \brief Indicates whether a specific Error Interrupt Source is active.
 *
 * \param[in] i2c    Pointer to the I2C module handle.
 * \param[in] source The Error Interrupt Source to check.
 *					 Range: \ref IfxI2c_ErrorInterruptSource
 *
 * \retval TRUE  The specified Error Interrupt Source is active.
 *         FALSE The specified Error Interrupt Source is not active.
 */
IFX_INLINE boolean IfxI2c_getErrorInterruptSourceStatus(Ifx_I2C *i2c, IfxI2c_ErrorInterruptSource source);

/**
 * \brief Returns the SRC pointer for I2C Error interrupt
 *
 * \param[in] i2c Pointer to the I2C module handle.
 *
 * \retval Ifx_SRC_SRCR* Pointer to the SRCR (Service Request Control Register) for the I2C Error Service interrupt.
 */
IFX_INLINE volatile Ifx_SRC_SRCR *IfxI2c_getErrorSrcPointer(Ifx_I2C *i2c);

/**
 * \brief Indicates whether the Protocol Interrupt is currently active.
 *
 * \param[in] i2c Pointer to the I2C module handle.
 *
 * \retval TRUE  The Protocol Interrupt Flag is set (active).
 *         FALSE The Protocol Interrupt Flag is not set (inactive).
 */
IFX_INLINE boolean IfxI2c_getProtocolInterruptFlagStatus(Ifx_I2C *i2c);

/**
 * \brief Checks and returns the status of a specified Protocol Interrupt Source.
 *
 * \param[in] i2c    Pointer to the I2C module handle.
 * \param[in] source The Protocol Interrupt Source to check.
 * 					 Range: \ref IfxI2c_ProtocolInterruptSource
 *
 * \retval TRUE  The specified Protocol Interrupt Source is active.
 * 		   FALSE The specified Protocol Interrupt Source is not active.
 */
IFX_INLINE boolean IfxI2c_getProtocolInterruptSourceStatus(Ifx_I2C *i2c, IfxI2c_ProtocolInterruptSource source);

/**
 * \brief Returns the SRC pointer for the I2C Protocol interrupt.
 *
 * \param[in] i2c Pointer to the I2C module handle.
 *
 * \retval Ifx_SRC_SRCR * Pointer to the SRCR register for the I2C Protocol interrupt.
 */
IFX_INLINE volatile Ifx_SRC_SRCR *IfxI2c_getProtocolSrcPointer(Ifx_I2C *i2c);

/**
 * \brief Indicates whether the Fifo is requesting new data to be sent.
 *
 * \param[in] i2c Pointer to the I2C module instance.
 *
 * \retval TRUE  If the Fifo is requesting new data.
 * 		   FALSE If the Fifo is not requesting new data.
 */
IFX_INLINE boolean IfxI2c_isFifoRequest(Ifx_I2C *i2c);

/**
 * \brief Runs the I2C module, initializing it for communication.
 *
 * \param[inout] i2c Pointer to the I2C module instance.
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_run(Ifx_I2C *i2c);

/**
 * \brief Configures the I2C Address width to 7 or 10 bits.
 *
 * \param[inout] i2c  Pointer to the I2C module instance.
 * \param[in]    mode Selects width of address bits (7-bit or 10-bit).
 *                    Range: \ref IfxI2c_AddressMode
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_setBitAddressMode(Ifx_I2C *i2c, IfxI2c_AddressMode mode);

/**
 * \brief Selects the Pin for I2C communication.
 *
 * \param[inout] i2c   Pointer to the I2C module instance.
 * \param[in]    pisel Pin selection to be configured.
 * 					   Range: \ref IfxI2c_PinSelect
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_setPinSelection(Ifx_I2C *i2c, IfxI2c_PinSelect pisel);

/**
 * \brief Sets the number of bytes to be received in a packet for the I2C module.
 *
 * \param[inout] i2c  Pointer to the I2C module instance.
 * \param[in]    size The number of bytes to be received in a packet. This value determines
 *                    the size of the receive buffer for the I2C module.
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_setReceivePacketSize(Ifx_I2C *i2c, Ifx_SizeT size);

/**
 * \brief Sets the Slave Device Address for I2C communication.
 *
 * \param[inout] i2c     Pointer to the I2C module instance.
 * \param[in]    address The slave device address to be set. Depending on setting of TBAM(Ten bit Address Mode),
 *            	         this is either a 7-bit address (bits [7:1]) or a 10-bit address (bits [9:0])
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_setSlaveDeviceAddress(Ifx_I2C *i2c, uint16 address);

/**
 * \brief Configures the I2C module's sensitivity to sleep signals.
 *
 * \param[inout] i2c  Pointer to the I2C module instance.
 * \param[in]    mode Sleep mode configuration.
 * 				      Range: \ref IfxI2c_SleepMode
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_setSleepMode(Ifx_I2C *i2c, IfxI2c_SleepMode mode);

/** \brief Sets the number of bytes to be transmitted in a packet.
 *
 * \param[inout] i2c  Pointer to the I2C module instance.
 * \param[in]    size Number of bytes to be transmitted in a packet (non-negative integer).
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_setTransmitPacketSize(Ifx_I2C *i2c, Ifx_SizeT size);

/**
 * \brief Stops the I2C communication.
 *
 * \param[inout] i2c Pointer to the I2C module instance.
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_stop(Ifx_I2C *i2c);
/**
 * \brief Waits until the I2C Bus is free.
 *
 * \param[in] i2c Pointer to the I2C module instance.
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_waitBusFree(Ifx_I2C *i2c);

/**
 * \brief Writes a 4-byte packet into the I2C Fifo for transmission.
 *
 * \param[inout] i2c    Pointer to the I2C module instance.
 * \param[in]    packet A 32-bit value containing the 4 bytes to be written into the FIFO. The bytes are written in the order:
 * 					    - Byte 0: Most significant byte of the packet
 * 					    - Byte 1: Next most significant byte of the packet
 * 					    - Byte 2: Next least significant byte of the packet
 * 					    - Byte 3: Least significant byte of the packet
 * 					    Range: 0x8000H to 0xBFFCH
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_writeFifo(Ifx_I2C *i2c, uint32 packet);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Configures the I2C module to operate as a Master.
 *
 * \param[inout] i2c Pointer to the I2C module instance.
 *
 * \retval None
 */
IFX_EXTERN void IfxI2c_configureAsMaster(Ifx_I2C *i2c);

/**
 * \brief Disables the I2C module, stopping all communication and resetting the module to its initial state.
 *
 * \param[in] i2c Pointer to the I2C module instance.
 *
 * \retval None
 */
IFX_EXTERN void IfxI2c_disableModule(Ifx_I2C *i2c);

/**
 * \brief Enables the DTR (Data Transfer Request) Interrupt for the specified I2C instance.
 *
 * \param[in] i2c           Pointer to the I2C module instance.
 * \param[in] typeOfService Type of service to be used for the interrupt handling.
 * 							This can be either CPU based handling or
 * 							DMA based handling (\ref IfxSrc_Tos_dma).
 * 							Range: \ref IfxSrc_Tos
 * \param[in] priority      The priority level for the interrupt.
 *							Range: 0x00 to 0xFF
 * \retval None
 */
IFX_EXTERN void IfxI2c_enableDtrInterrupt(Ifx_I2C *i2c, IfxSrc_Tos typeOfService, uint16 priority);

/**
 * \brief Enables the Error Interrupt for the I2C module
 *
 * \param[in] i2c           Pointer to the I2C module instance.
 * \param[in] typeOfService Type of service to be used for the interrupt handling.
 * 							This can be either CPU based handling or
 * 							DMA based handling (\ref IfxSrc_Tos_dma).
 * 							Range: \ref IfxSrc_Tos
 * \param[in] priority      Priority level for the interrupt.
 * 							Range: 0x00 to 0xFF
 *
 * \retval None
 */
IFX_EXTERN void IfxI2c_enableErrorInterrupt(Ifx_I2C *i2c, IfxSrc_Tos typeOfService, uint16 priority);

/**
 * \brief Enables the specified I2C module.
 *
 * \param[inout] i2c Pointer to the I2C module instance.
 *
 * \retval None
 */
IFX_EXTERN void IfxI2c_enableModule(Ifx_I2C *i2c);

/**
 * \brief Enables the protocol interrupt for handling I2C communication events.
 *
 * \param[in] i2c           Pointer to the I2C module instance.
 * \param[in] typeOfService Type of service to be used for the interrupt handling.
 * 							This can be either CPU based handling or
 * 							DMA based handling (\ref IfxSrc_Tos_dma).
 * 							Range: \ref IfxSrc_Tos
 * \param[in] priority      Priority level for the interrupt.
 * 							Range: 0x00 to 0xFF
 *
 * \retval None
 */
IFX_EXTERN void IfxI2c_enableProtocolInterrupt(void *i2c, IfxSrc_Tos typeOfService, uint16 priority);

/**
 * \brief Retrieves the base Address of the I2C module corresponding to the given index.
 *
 * \param[in] i2c Resource index of the I2C module.
 * 				  Range: \ref IfxI2c_Index
 *
 * \retval Ifx_I2C* Pointer to the I2C module's register base address.
 */
IFX_EXTERN Ifx_I2C *IfxI2c_getAddress(IfxI2c_Index i2c);

/**
 * \brief Returns the actual Baudrate configured for the I2C module.
 *
 * \param[in] i2c Pointer to the I2C module instance.
 *
 * \retval float32 The actual Baudrate configured for the I2C module in Hz.
 */
IFX_EXTERN float32 IfxI2c_getBaudrate(Ifx_I2C *i2c);

/**
 * \brief Retrieves the resource Index of the specified I2C module.
 *
 * \param[in] i2c Pointer to the I2C module instance.
 *
 * \retval IfxI2c_Index The resource Index of the I2C module.
 * 						(\ref IfxI2c_Index)
 * 						- IfxI2c_Index_none I2C index not Selected.
 * 						- IfxI2c_Index_0    I2C Index 0
 * 						- IfxI2c_Index_1    I2C Index 1
 */
IFX_EXTERN IfxI2c_Index IfxI2c_getIndex(Ifx_I2C *i2c);

/**
 * \brief Initializes the SCL and SDA pins for I2C communication.
 *
 * \param[in] scl 	 	Pointer to the SCL pin configuration structure.
 * \param[in] sda 		Pointer to the SDA pin configuration structure.
 * \param[in] padDriver The pad driver mode to be used for the SCL and SDA pins.
 * 						Range: \ref IfxPort_PadDriver
 *
 * \retval None
 */
IFX_EXTERN void IfxI2c_initSclSdaPin(const IfxI2c_Scl_InOut *scl, const IfxI2c_Sda_InOut *sda, IfxPort_PadDriver padDriver);

/**
 * \brief Releases the Bus by generating a stop condition.
 *
 * \param[inout] i2c Pointer to the I2C module instance.
 *
 * \retval None
 */
IFX_EXTERN void IfxI2c_releaseBus(Ifx_I2C *i2c);
/**
 * \brief Resets the Fifo buffer of the I2C module to its initial state.
 *
 * \param[inout] i2c Pointer to the I2C module instance.
 *
 * \retval None
 */
IFX_EXTERN void IfxI2c_resetFifo(Ifx_I2C *i2c);

/**
 * \brief Resets the I2C Module to its initial state.
 *
 * \param[inout] i2c Pointer to the I2C module instance.
 *
 * \retval None
 */
IFX_EXTERN void IfxI2c_resetModule(Ifx_I2C *i2c);

/**
 * \brief Configures the I2C module to operate at the specified Baudrate
 *
 * \param[inout] i2c      Pointer to the I2C module instance.
 * \param[in]    baudrate Desired Baudrate in Hz for the I2C communication.
 *                        Range: StandardandFast mode up to 400 kHz/s (20kHz/s - 400kHz/s)
 *                               High-speed mode up to 3.4 Mbit/s (500kHz/s - 3.4MHz/s)
 *
 * \retval None
 */
IFX_EXTERN void IfxI2c_setBaudrate(Ifx_I2C *i2c, float32 baudrate);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Configures the Interrupt Request source for the I2C module.
 *
 * \param[inout] i2c    Pointer to the I2C module instance.
 * \param[in]    source The Interrupt Request source to be configured. This parameter determines which I2C events will generate an interrupt.
 * 					    Range: \ref IfxI2c_InterruptRequest
 *
 * \retval None
 */
IFX_INLINE void IfxI2c_setInterruptRequest(Ifx_I2C *i2c, IfxI2c_InterruptRequest source);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Configures the I2C module to operate in Slave mode.
 *
 * \param[inout] i2c Pointer to the I2C module instance.
 *
 * \retval None
 */
IFX_EXTERN void IfxI2c_configureAsSlave(Ifx_I2C *i2c);

/**
 * \brief Configures the Address and Fifo registers for the I2C module according to the provided configuration.
 *
 * \param[inout] i2c    Pointer to the I2C module instance.
 * \param[in]    config Pointer to the configuration structure containing the address and fifo settings.
 *
 * \retval None
 */
IFX_EXTERN void IfxI2c_configureAddrFifo(Ifx_I2C *i2c, const IfxI2c_Config *config);

/**
 * \brief Configures the Timing of the I2C-bus signals SCL and SCA for the I2C module.
 *
 * \param[inout] i2c 	      Pointer to the I2C module instance.
 * \param[in]    timingConfig Pointer to a structure containing the timing configuration parameters.
 * 						      The structure includes settings for SDA and SCL delays in different modes,
 * 						      as well as control flags for specific timing features.
 *
 * \retval None
 *
 * \note If the timing configuration is not explicitly set by the user, default values for the TIMCFG register
 *       are set in the \ref IfxI2c_setBaudrate API.
 */
IFX_EXTERN void IfxI2c_configureTiming(Ifx_I2C *i2c, const IfxI2c_TimingConfig *timingConfig);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE boolean IfxI2c_busIsFree(Ifx_I2C *i2c)
{
    boolean free = FALSE;

    if (i2c->BUSSTAT.B.BS == IfxI2c_BusStatus_idle)
    {
        free = TRUE;
    }

    return free;
}


IFX_INLINE void IfxI2c_clearAllDtrInterruptSources(Ifx_I2C *i2c)
{
    i2c->ICR.U = (1 << IFX_I2C_ICR_LSREQ_INT_OFF) | (1 << IFX_I2C_ICR_SREQ_INT_OFF) | (1 << IFX_I2C_ICR_LBREQ_INT_OFF) | (1 << IFX_I2C_ICR_BREQ_INT_OFF);
}


IFX_INLINE void IfxI2c_clearAllErrorInterruptSources(Ifx_I2C *i2c)
{
    i2c->ERRIRQSC.U = (1 << IFX_I2C_ERRIRQSC_RXF_UFL_OFF) | (1 << IFX_I2C_ERRIRQSC_RXF_OFL_OFF) | (1 << IFX_I2C_ERRIRQSC_TXF_UFL_OFF) | (1 << IFX_I2C_ERRIRQSC_TXF_OFL_OFF);
}


IFX_INLINE void IfxI2c_clearAllProtocolInterruptSources(Ifx_I2C *i2c)
{
    i2c->PIRQSC.U = (1 << IFX_I2C_PIRQSC_AM_OFF) | (1 << IFX_I2C_PIRQSC_GC_OFF) | (1 << IFX_I2C_PIRQSC_MC_OFF) | (1 << IFX_I2C_PIRQSC_AL_OFF) | (1 << IFX_I2C_PIRQSC_NACK_OFF) | (1 << IFX_I2C_PIRQSC_TX_END_OFF) | (1 << IFX_I2C_PIRQSC_RX_OFF);
}


IFX_INLINE void IfxI2c_clearDtrInterruptSource(Ifx_I2C *i2c, IfxI2c_DtrInterruptSource source)
{
    i2c->ICR.U = (1 << source);
}


IFX_INLINE void IfxI2c_clearErrorInterruptSource(Ifx_I2C *i2c, IfxI2c_ErrorInterruptSource source)
{
    i2c->ERRIRQSC.U = (1 << source);
}


IFX_INLINE void IfxI2c_clearProtocolInterruptSource(Ifx_I2C *i2c, IfxI2c_ProtocolInterruptSource source)
{
    i2c->PIRQSC.U = (1 << source);
}


IFX_INLINE void IfxI2c_clearRequestBuffer(Ifx_I2C *i2c)
{
    i2c->FIFOCFG.B.CRBC = 1;
}


IFX_INLINE void IfxI2c_disableDtrInterruptSource(Ifx_I2C *i2c, IfxI2c_DtrInterruptSource source)
{
    i2c->IMSC.U &= ~(1 << source);
}


IFX_INLINE void IfxI2c_disableErrorInterruptFlag(Ifx_I2C *i2c)
{
    i2c->IMSC.B.I2C_ERR_INT = 0;
}


IFX_INLINE void IfxI2c_disableErrorInterruptSource(Ifx_I2C *i2c, IfxI2c_ErrorInterruptSource source)
{
    i2c->ERRIRQSM.U &= ~(1 << source);
}


IFX_INLINE void IfxI2c_disableProtocolInterruptFlag(Ifx_I2C *i2c)
{
    i2c->IMSC.B.I2C_P_INT = 0;
}


IFX_INLINE void IfxI2c_disableProtocolInterruptSource(Ifx_I2C *i2c, IfxI2c_ProtocolInterruptSource source)
{
    i2c->PIRQSM.U &= ~(1 << source);
}


IFX_INLINE void IfxI2c_enableDtrInterruptSource(Ifx_I2C *i2c, IfxI2c_DtrInterruptSource source)
{
    i2c->IMSC.U |= (1 << source);
}


IFX_INLINE void IfxI2c_enableErrorInterruptFlag(Ifx_I2C *i2c)
{
    i2c->IMSC.B.I2C_ERR_INT = 1;
}


IFX_INLINE void IfxI2c_enableErrorInterruptSource(Ifx_I2C *i2c, IfxI2c_ErrorInterruptSource source)
{
    i2c->ERRIRQSM.U |= (1 << source);
}


IFX_INLINE void IfxI2c_enableProtocolInterruptFlag(Ifx_I2C *i2c)
{
    i2c->IMSC.B.I2C_P_INT = 1;
}


IFX_INLINE void IfxI2c_enableProtocolInterruptSource(Ifx_I2C *i2c, IfxI2c_ProtocolInterruptSource source)
{
    i2c->PIRQSM.U |= (1 << source);
}


IFX_INLINE IfxI2c_BusStatus IfxI2c_getBusStatus(Ifx_I2C *i2c)
{
    return (IfxI2c_BusStatus)i2c->BUSSTAT.B.BS;
}


IFX_INLINE volatile Ifx_SRC_SRCR *IfxI2c_getDtrSrcPointer(Ifx_I2C *i2c)
{
#if IFXI2C_NUM_MODULES > 1
    if (i2c == &MODULE_I2C0)
    {
        return &MODULE_SRC.I2C.I2C[0].DTR;
    }
    else
    {
        return &MODULE_SRC.I2C.I2C[1].DTR;
    }
#else
    return &MODULE_SRC.I2C.I2C[0].DTR;
#endif
}


IFX_INLINE boolean IfxI2c_getDtrinterruptSourceStatus(Ifx_I2C *i2c, IfxI2c_DtrInterruptSource source)
{
    return (i2c->RIS.U & (1 << source)) ? TRUE : FALSE;
}


IFX_INLINE boolean IfxI2c_getErrorInterruptFlagStatus(Ifx_I2C *i2c)
{
    return i2c->RIS.B.I2C_ERR_INT;
}


IFX_INLINE boolean IfxI2c_getErrorInterruptSourceStatus(Ifx_I2C *i2c, IfxI2c_ErrorInterruptSource source)
{
    return (i2c->ERRIRQSS.U & (1 << source)) ? TRUE : FALSE;
}


IFX_INLINE volatile Ifx_SRC_SRCR *IfxI2c_getErrorSrcPointer(Ifx_I2C *i2c)
{
#if IFXI2C_NUM_MODULES > 1
    if (i2c == &MODULE_I2C0)
    {
        return &MODULE_SRC.I2C.I2C[0].ERR;
    }
    else
    {
        return &MODULE_SRC.I2C.I2C[1].ERR;
    }
#else
    return &MODULE_SRC.I2C.I2C[0].ERR;
#endif
}


IFX_INLINE boolean IfxI2c_getProtocolInterruptFlagStatus(Ifx_I2C *i2c)
{
    return i2c->RIS.B.I2C_P_INT;
}


IFX_INLINE boolean IfxI2c_getProtocolInterruptSourceStatus(Ifx_I2C *i2c, IfxI2c_ProtocolInterruptSource source)
{
    return (i2c->PIRQSS.U & (1 << source)) ? TRUE : FALSE;
}


IFX_INLINE volatile Ifx_SRC_SRCR *IfxI2c_getProtocolSrcPointer(Ifx_I2C *i2c)
{
#if IFXI2C_NUM_MODULES > 1
    if (i2c == &MODULE_I2C0)
    {
        return &MODULE_SRC.I2C.I2C[0].P;
    }
    else
    {
        return &MODULE_SRC.I2C.I2C[1].P;
    }
#else
    return &MODULE_SRC.I2C.I2C[0].P;
#endif
}


IFX_INLINE boolean IfxI2c_isFifoRequest(Ifx_I2C *i2c)
{
    return i2c->RIS.U & 0x0F ? TRUE : FALSE;
}


IFX_INLINE void IfxI2c_run(Ifx_I2C *i2c)
{
    i2c->RUNCTRL.U = 1;
}


IFX_INLINE void IfxI2c_setBitAddressMode(Ifx_I2C *i2c, IfxI2c_AddressMode mode)
{
    i2c->ADDRCFG.B.TBAM = mode;
}


IFX_INLINE void IfxI2c_setPinSelection(Ifx_I2C *i2c, IfxI2c_PinSelect pisel)
{
    i2c->GPCTL.B.PISEL = pisel;
}


IFX_INLINE void IfxI2c_setReceivePacketSize(Ifx_I2C *i2c, Ifx_SizeT size)
{
    i2c->MRPSCTRL.B.MRPS = size;
}


IFX_INLINE void IfxI2c_setSlaveDeviceAddress(Ifx_I2C *i2c, uint16 address)
{
    i2c->ADDRCFG.B.ADR = address;
}


IFX_INLINE void IfxI2c_setSleepMode(Ifx_I2C *i2c, IfxI2c_SleepMode mode)
{
    i2c->CLC1.B.EDIS = mode;
}


IFX_INLINE void IfxI2c_setTransmitPacketSize(Ifx_I2C *i2c, Ifx_SizeT size)
{
    i2c->TPSCTRL.B.TPS = size;
}


IFX_INLINE void IfxI2c_stop(Ifx_I2C *i2c)
{
    i2c->RUNCTRL.U = 0;
}


IFX_INLINE void IfxI2c_waitBusFree(Ifx_I2C *i2c)
{
    while (IfxI2c_getBusStatus(i2c) != IfxI2c_BusStatus_idle)
    {}
}


IFX_INLINE void IfxI2c_writeFifo(Ifx_I2C *i2c, uint32 packet)
{
    i2c->TXD.U = packet;
}


IFX_INLINE void IfxI2c_setInterruptRequest(Ifx_I2C *i2c, IfxI2c_InterruptRequest source)
{
    i2c->ISR.U |= (1 << source);
}


#endif /* IFXI2C_H */
