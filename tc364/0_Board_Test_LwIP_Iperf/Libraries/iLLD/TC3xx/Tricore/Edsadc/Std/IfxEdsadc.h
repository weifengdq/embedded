/**
 * \file IfxEdsadc.h
 * \brief EDSADC  basic functionality
 * \ingroup IfxLld_Edsadc
 *
 * \version iLLD_1_20_0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Edsadc_Std_Enum Enumerations
 * \ingroup IfxLld_Edsadc_Std
 * \defgroup IfxLld_Edsadc_Std_Operative Operative Functions
 * \ingroup IfxLld_Edsadc_Std
 * \defgroup IfxLld_Edsadc_Std_Support Support Functions
 * \ingroup IfxLld_Edsadc_Std
 * \defgroup IfxLld_Edsadc_Std_Interrupt Interrupt Functions
 * \ingroup IfxLld_Edsadc_Std
 * \defgroup IfxLld_Edsadc_Std_IO IO Pin Configuration Functions
 * \ingroup IfxLld_Edsadc_Std
 */

#ifndef IFXEDSADC_H
#define IFXEDSADC_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxEdsadc_cfg.h"
#include "Src/Std/IfxSrc.h"
#include "Scu/Std/IfxScuCcu.h"
#include "_PinMap/IfxEdsadc_PinMap.h"
#include "Cpu/Std/IfxCpu_Intrinsics.h"
#include "IfxEdsadc_reg.h"
#include "IfxEdsadc_bf.h"

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Edsadc_Std_Enum
 * \{ */
/** \brief Analog Clock Synchronization Delay
 * Definition in Ifx_DSADC.MODCFG.B.ACSD
 */
typedef enum
{
    IfxEdsadc_AnalogClockSyncDelay_noDelay     = 0,    /**< \brief no delay */
    IfxEdsadc_AnalogClockSyncDelay_cycleDelay1 = 1,    /**< \brief Delay of 1 Cycle  */
    IfxEdsadc_AnalogClockSyncDelay_cycleDelay2,        /**< \brief Delay of 2 Cycle  */
    IfxEdsadc_AnalogClockSyncDelay_cycleDelay3,        /**< \brief Delay of 3 Cycle  */
    IfxEdsadc_AnalogClockSyncDelay_cycleDelay4,        /**< \brief Delay of 4 Cycle  */
    IfxEdsadc_AnalogClockSyncDelay_cycleDelay5,        /**< \brief Delay of 5 Cycle  */
    IfxEdsadc_AnalogClockSyncDelay_cycleDelay6,        /**< \brief Delay of 6 Cycle  */
    IfxEdsadc_AnalogClockSyncDelay_cycleDelay7         /**< \brief Delay of 7 Cycle  */
} IfxEdsadc_AnalogClockSyncDelay;

/** \brief Service request generation (auxiliary)\n
 * Definition in Ifx_EDSADC.FCFGM.B.SRGA
 */
typedef enum
{
    IfxEdsadc_AuxServiceRequest_never          = 0,  /**< \brief Never, service requests disabled */
    IfxEdsadc_AuxServiceRequest_compEvent      = 1,  /**< \brief As selected by bitfield ESEL */
    IfxEdsadc_AuxServiceRequest_timestampEvent = 2,  /**< \brief Timestamp Event */
    IfxEdsadc_AuxServiceRequest_altSource      = 3   /**< \brief Alternate source: Capturing of a sign delay value to register CGSYNCx (x = 0 - 5) */
} IfxEdsadc_AuxServiceRequest;

/** \brief Carrier generation mode\n
 * Definition in Ifx_EDSADC.CGCFG.B.CGMOD
 */
typedef enum
{
    IfxEdsadc_CarrierWaveformMode_stopped  = 0,  /**< \brief Carrier Generator stopped */
    IfxEdsadc_CarrierWaveformMode_square   = 1,  /**< \brief Carrier Generator generates square wave */
    IfxEdsadc_CarrierWaveformMode_triangle = 2,  /**< \brief Carrier Generator generates triangle wave */
    IfxEdsadc_CarrierWaveformMode_sine     = 3   /**< \brief Carrier Generator generates sine wave */
} IfxEdsadc_CarrierWaveformMode;

/** \brief Select the data to be returned when register RESM is read
 * Definition in Ifx_DSADC.DICFG.B.DRM
 */
typedef enum
{
    IfxEdsadc_DataRead_signOnHighbit      = 0,  /**< \brief Single: Issue one 16-bit value per read access (sign on high bits) */
    IfxEdsadc_DataRead_timestampOnHighbit = 1,  /**< \brief Single: Issue one 16-bit value per read access (timestamp on high bits) */
    IfxEdsadc_DataRead_double             = 2   /**< \brief Double: Issue two 16-bit values per read access */
} IfxEdsadc_DataRead;

/** \brief Data stream select
 * Definition in Ifx_DSADC.DICFG.B.DSS
 */
typedef enum
{
    IfxEdsadc_DataStream_onChipModulator        = 0,  /**< \brief select data stream from on chip modulator */
    IfxEdsadc_DataStream_doubleDataClockEdge    = 3,  /**< \brief External modulator, use rising and falling clock edge */
    IfxEdsadc_DataStream_directFallingClockEdge = 4,  /**< \brief External modulator, use each falling clock edge */
    IfxEdsadc_DataStream_directRisingClockEdge  = 5,  /**< \brief External modulator, use each rising clock edge */
    IfxEdsadc_DataStream_secondFallingClockEdge = 6,  /**< \brief External modulator, use every 2nd falling clock edge */
    IfxEdsadc_DataStream_secondRisingClockEdge  = 7   /**< \brief External modulator, use every 2nd rising clock edge */
} IfxEdsadc_DataStream;

/** \brief Trimming Value for Dithering function
 * Definition in Ifx_DSADC.GLOBCFG.B.DITRIM
 */
typedef enum
{
    IfxEdsadc_DitheringIntensity_minimum = 0,  /**< \brief Minimum dithering intensity */
    IfxEdsadc_DitheringIntensity_low     = 1,  /**< \brief Low dithering intensity */
    IfxEdsadc_DitheringIntensity_medium  = 2,  /**< \brief Medium dithering intensity */
    IfxEdsadc_DitheringIntensity_high    = 3   /**< \brief High */
} IfxEdsadc_DitheringIntensity;

/** \brief Define when comparator event is generated
 * Definition in Ifx_DSADC.FCFGM.B.ESEL
 */
typedef enum
{
    IfxEdsadc_EventSelect_everyNewResult = 0,  /**< \brief Always, for each new result value */
    IfxEdsadc_EventSelect_insideBoundry  = 1,  /**< \brief If result is inside the boundary band */
    IfxEdsadc_EventSelect_outsideBoundry = 2   /**< \brief If result is outside the boundary band */
} IfxEdsadc_EventSelect;

/** \brief Defines the duration of the additional filter effect, based on values input to the
 * filter
 */
typedef enum
{
    IfxEdsadc_FilterRunTimeInputCycle_2  = 0, /**< \brief 2 input cycles */
    IfxEdsadc_FilterRunTimeInputCycle_4  = 1, /**< \brief 4 input cycles */
    IfxEdsadc_FilterRunTimeInputCycle_8  = 2, /**< \brief 8 input cycles */
    IfxEdsadc_FilterRunTimeInputCycle_16 = 3  /**< \brief 16 input cycles */
} IfxEdsadc_FilterRunTimeInputCycle;

/** \brief Specifies Slew Rate Filter Strength
 */
typedef enum
{
    IfxEdsadc_FilterStrength_minimum = 0,  /**< \brief Minimum filter effect, early attenuation, linear operation */
    IfxEdsadc_FilterStrength_weak    = 1,  /**< \brief Weak filter effect */
    IfxEdsadc_FilterStrength_medium  = 2,  /**< \brief Medium filter effect */
    IfxEdsadc_FilterStrength_maximum = 3   /**< \brief maximum filter effect */
} IfxEdsadc_FilterStrength;

/** \brief Enumeration describing selection of supervisor signal from channels
 */
typedef enum
{
    IfxEdsadc_SvSigSel_none                  = 0,  /**< \brief No supervision signal */
    IfxEdsadc_SvSigSel_internalRegulator1_2V = 1,  /**< \brief Internal Regulator 1.2V */
    IfxEdsadc_SvSigSel_internalRegulator3_3V = 2,  /**< \brief Internal Regulator 3.3V */
} IfxEdsadc_SvSigSel;

/** \brief Fractional Reference Voltage Enable
 */
typedef enum
{
    IfxEdsadc_FractionalRefVoltage_disable = 0,  /**< \brief VREFX is not connected */
    IfxEdsadc_FractionalRefVoltage_enable  = 1   /**< \brief VREFX is connected, value according to VREFXSEL */
} IfxEdsadc_FractionalRefVoltage;

/** \brief Fraction reference voltage selection
 */
typedef enum
{
    IfxEdsadc_FractionalRefVoltageSelection_div2  = 0, /**< \brief VREFX = VAREF / 2 */
    IfxEdsadc_FractionalRefVoltageSelection_div4  = 1, /**< \brief VREFX = VAREF / 4 */
    IfxEdsadc_FractionalRefVoltageSelection_div8  = 2  /**< \brief VREFX = VAREF / 8 */
} IfxEdsadc_FractionalRefVoltageSelection;

/** \brief Modulator configuration of positive/negative input line\n
 * Definition in Ifx_DSADC.MODCFGx.B.INCFGP and Ifx_DSADC.MODCFGx.B.INCFGN
 */
typedef enum
{
    IfxEdsadc_InputConfig_inputPin          = 0,  /**< \brief Modulator input connected to external pin */
    IfxEdsadc_InputConfig_supplyVoltage     = 1,  /**< \brief Modulator input connected to supply voltage V_ddm */
    IfxEdsadc_InputConfig_commonModeVoltage = 2,  /**< \brief Modulator input connected to common mode voltage V_cm */
    IfxEdsadc_InputConfig_referenceGround   = 3   /**< \brief Modulator input connected to reference ground V_ref */
} IfxEdsadc_InputConfig;

/** \brief Demodulator input data source selection\n
 * Definition in Ifx_EDSADC.DICFG.B.DSRC
 */
typedef enum
{
    IfxEdsadc_InputDataSource_directInputA   = 0,  /**< \brief External, from input A, direct */
    IfxEdsadc_InputDataSource_invertedInputA = 1,  /**< \brief External, from input A, inverted */
    IfxEdsadc_InputDataSource_directInputB   = 2,  /**< \brief External, from input B, direct */
    IfxEdsadc_InputDataSource_invertedInputB = 3,  /**< \brief External, from input B, inverted */
    IfxEdsadc_InputDataSource_directInputC   = 4,  /**< \brief External, from input C, direct */
    IfxEdsadc_InputDataSource_invertedInputC = 5,  /**< \brief External, from input C, inverted */
    IfxEdsadc_InputDataSource_directInputD   = 6,  /**< \brief External, from input D, direct */
    IfxEdsadc_InputDataSource_invertedInputD = 7   /**< \brief External, from input D, inverted */
} IfxEdsadc_InputDataSource;

/** \brief Modulator gain select of analog input path\n
 * Definition in Ifx_DSADC.MODCFGx.B.GAINSEL
 */
typedef enum
{
    IfxEdsadc_InputGain_factor1  = 0, /**< \brief Input gain factor: 1 */
    IfxEdsadc_InputGain_factor2  = 1, /**< \brief Input gain factor: 2 */
    IfxEdsadc_InputGain_factor4  = 2, /**< \brief Input gain factor: 4 */
} IfxEdsadc_InputGain;

/** \brief specifies input multiplexer control mode defined in MODULE_EDSADC.MODCFG.B.INMODE
 */
typedef enum
{
    IfxEdsadc_InputMuxControlMode_softwareControl = 0,  /**< \brief Trigger Event by software (INMUX follows INSEL) */
    IfxEdsadc_InputMuxControlMode_fallingEdge     = 1,  /**< \brief Trigger Event on Falling edge */
    IfxEdsadc_InputMuxControlMode_risingEdge      = 2,  /**< \brief Trigger Event on Rising edge */
    IfxEdsadc_InputMuxControlMode_always          = 3   /**< \brief Trigger event on any edge */
} IfxEdsadc_InputMuxControlMode;

/** \brief Modulator input pin selection\n
 * Definition in Ifx_DSADC.MODCFGx.B.INMUX
 */
typedef enum
{
    IfxEdsadc_InputPin_a = 0,  /**< \brief Pin A connected to modulator input */
    IfxEdsadc_InputPin_b = 1,  /**< \brief Pin B connected to modulator input */
    IfxEdsadc_InputPin_c = 2,  /**< \brief Pin C connected to modulator input */
    IfxEdsadc_InputPin_d = 3   /**< \brief Pin D connected to modulator input */
} IfxEdsadc_InputPin;

/** \brief Controls the data shifter after the integrator that selects the portion of the
 * integrator data for the result register
 */
typedef enum
{
    IfxEdsadc_IntegrationShiftControl_0 = 0,      /**< \brief Integration Shift value  */
    IfxEdsadc_IntegrationShiftControl_1,          /**< \brief Integration Shift value  */
    IfxEdsadc_IntegrationShiftControl_2,          /**< \brief Integration Shift value  */
    IfxEdsadc_IntegrationShiftControl_3,          /**< \brief Integration Shift value  */
    IfxEdsadc_IntegrationShiftControl_4,          /**< \brief Integration Shift value  */
    IfxEdsadc_IntegrationShiftControl_5           /**< \brief Integration Shift value  */
} IfxEdsadc_IntegrationShiftControl;

/** \brief Integrator window size\n
 * Definition in Ifx_DSADC.IWCTR.B.IWS
 */
typedef enum
{
    IfxEdsadc_IntegrationWindowSize_internalControl = 0,  /**< \brief Internal control: stop integrator after REPVAL+1 integration cycles */
    IfxEdsadc_IntegrationWindowSize_externalControl = 1   /**< \brief External control: stop integrator when bit INTEN becomes 0 */
} IfxEdsadc_IntegrationWindowSize;

/** \brief Integrator trigger mode\n
 * NOTE: switch-first to bypassed before using other mode\n
 * Definition in Ifx_EDSADC.DICFG.B.ITRMODE
 */
typedef enum
{
    IfxEdsadc_IntegratorTrigger_bypassed     = 0, /**< \brief No integration trigger, integrator bypassed */
    IfxEdsadc_IntegratorTrigger_fallingEdge  = 1, /**< \brief Trigger event upon a falling edge */
    IfxEdsadc_IntegratorTrigger_risingEdge   = 2, /**< \brief Trigger event upon a rising edge */
    IfxEdsadc_IntegratorTrigger_alwaysActive = 3  /**< \brief No trigger, integrator active all the time */
} IfxEdsadc_IntegratorTrigger;

/** \brief Service request generation (main chain)\n
 * Definition in Ifx_EDSADC.FCFGM.B.SRGM
 */
typedef enum
{
    IfxEdsadc_MainServiceRequest_never          = 0,  /**< \brief Never, service requests disabled */
    IfxEdsadc_MainServiceRequest_highGateSignal = 1,  /**< \brief While gate (selected trigger signal) is high */
    IfxEdsadc_MainServiceRequest_lowGateSignal  = 2,  /**< \brief While gate (selected trigger signal) is low */
    IfxEdsadc_MainServiceRequest_everyNewResult = 3   /**< \brief Always, for each new result value */
} IfxEdsadc_MainServiceRequest;

/** \brief Modulator divider factor for modulator clock\n
 * Definition in Ifx_EDSADC.MODCFGx.B.DIVM
 */
typedef enum
{
    IfxEdsadc_ModulatorClockDivider_div4 = 0,      /**< \brief f_mod = f_clk / 4  */
    IfxEdsadc_ModulatorClockDivider_div6,          /**< \brief f_mod = f_clk / 6  */
    IfxEdsadc_ModulatorClockDivider_div8,          /**< \brief f_mod = f_clk / 8  */
    IfxEdsadc_ModulatorClockDivider_div10,         /**< \brief f_mod = f_clk / 10  */
    IfxEdsadc_ModulatorClockDivider_div12,         /**< \brief f_mod = f_clk / 12  */
    IfxEdsadc_ModulatorClockDivider_div14,         /**< \brief f_mod = f_clk / 14  */
    IfxEdsadc_ModulatorClockDivider_div16,         /**< \brief f_mod = f_clk / 16  */
    IfxEdsadc_ModulatorClockDivider_div18          /**< \brief f_mod = f_clk / 18  */
} IfxEdsadc_ModulatorClockDivider;

/** \brief Defines the way the modulator clock is generated
 * Definition in Ifx_DSADC.GLOBCFG.B.USC
 */
typedef enum
{
    IfxEdsadc_ModulatorClockGeneration_syncMode   = 0,
    IfxEdsadc_ModulatorClockGeneration_unsyncMode = 1
} IfxEdsadc_ModulatorClockGeneration;

/** \brief Enable the offset compensation filter
 * Definition in Ifx_DSADC.FCFGM.B.OCEN
 */
typedef enum
{
    IfxEdsadc_OffsetCompensationFilter_disabled        = 0,  /**< \brief Offset Compensation filter disabled */
    IfxEdsadc_OffsetCompensationFilter_enablewithRateA = 1,  /**< \brief Enable offset compensation filter, adjust OFFCOMP with rate A */
    IfxEdsadc_OffsetCompensationFilter_enablewithRateB = 2,  /**< \brief Enable offset compensation filter, adjust OFFCOMP with rate B */
    IfxEdsadc_OffsetCompensationFilter_enablewithRateC = 3,  /**< \brief Enable offset compensation filter, adjust OFFCOMP with rate C */
    IfxEdsadc_OffsetCompensationFilter_enablewithRateD = 4,  /**< \brief Enable offset compensation filter, adjust OFFCOMP with rate D */
    IfxEdsadc_OffsetCompensationFilter_enablewithRateE = 5,  /**< \brief Enable offset compensation filter, adjust OFFCOMP with rate E */
    IfxEdsadc_OffsetCompensationFilter_enablewithRateF = 6,  /**< \brief Enable offset compensation filter, adjust OFFCOMP with rate F */
    IfxEdsadc_OffsetCompensationFilter_enablewithRateG = 7   /**< \brief Enable offset compensation filter, adjust OFFCOMP with rate G */
} IfxEdsadc_OffsetCompensationFilter;

/** \brief Overshoot Compensation Enable.
 * Defined in fx_DSADC.FCFGM.B.OVCEN
 */
typedef enum
{
    IfxEdsadc_OvershootCompensation_disabled = 0,  /**< \brief Disabled, feed FIR filter directly */
    IfxEdsadc_OvershootCompensation_enabled  = 1   /**< \brief Attenuate response to fast edges */
} IfxEdsadc_OvershootCompensation;

/** \brief Rectifier sign source\n
 * Selects the sign signal that is to be delayed.\n
 * Definition in Ifx_DSADC.RECT.B.SSRC
 */
typedef enum
{
    IfxEdsadc_RectifierSignSource_onChipGenerator = 0,  /**< \brief On-chip carrier generator */
    IfxEdsadc_RectifierSignSource_nextChannel     = 1,  /**< \brief Sign of result of next channel */
    IfxEdsadc_RectifierSignSource_externalA       = 2,  /**< \brief External sign signal A */
    IfxEdsadc_RectifierSignSource_externalB       = 3   /**< \brief External sign signal B */
} IfxEdsadc_RectifierSignSource;

/** \brief Sign Source Channel
 * Definition in Ifx_EDSADC.RECTCFG.B.SSCH
 */
typedef enum
{
    IfxEdsadc_SignSourceChannel_0  = 0,   /**< \brief Sign result from channel 0 */
    IfxEdsadc_SignSourceChannel_1  = 1,   /**< \brief Sign result from channel 1 */
    IfxEdsadc_SignSourceChannel_2  = 2,   /**< \brief Sign result from channel 2 */
    IfxEdsadc_SignSourceChannel_3  = 3,   /**< \brief Sign result from channel 3 */
	IfxEdsadc_SignSourceChannel_4  = 4,   /**< \brief Sign result from channel 4 */
	IfxEdsadc_SignSourceChannel_5  = 5,   /**< \brief Sign result from channel 5 */
	IfxEdsadc_SignSourceChannel_6  = 6,   /**< \brief Sign result from channel 6 */
	IfxEdsadc_SignSourceChannel_7  = 7,   /**< \brief Sign result from channel 7 */
	IfxEdsadc_SignSourceChannel_8  = 8,   /**< \brief Sign result from channel 8 */
	IfxEdsadc_SignSourceChannel_9  = 9,   /**< \brief Sign result from channel 9 */
	IfxEdsadc_SignSourceChannel_10 = 10,  /**< \brief Sign result from channel 10 */
	IfxEdsadc_SignSourceChannel_11 = 11,  /**< \brief Sign result from channel 11 */
	IfxEdsadc_SignSourceChannel_12 = 12,  /**< \brief Sign result from channel 12 */
	IfxEdsadc_SignSourceChannel_13 = 13   /**< \brief Sign result from channel 13 */
} IfxEdsadc_SignSourceChannel;

/** \brief Restart the filter chain when an integration window starts
 */
typedef enum
{
    IfxEdsadc_RestartFilterChain_on  = 0,
    IfxEdsadc_RestartFilterChain_off = 1
} IfxEdsadc_RestartFilterChain;

/** \brief specifies result display mode (signed/unsigned)
 * Definition in Ifx_DSADC.DICFG.B.RDM
 */
typedef enum
{
    IfxEdsadc_ResultDisplayMode_signed   = 0, /**< \brief Signed: result values range from -215 to +215 */
    IfxEdsadc_ResultDisplayMode_unsigned = 1  /**< \brief Unsigned: result values range from 0 to +216 (shifted by 215) */
} IfxEdsadc_ResultDisplayMode;

/** \brief Demodulator sample clock source select\n
 * Definition in Ifx_EDSADC.DICFG.B.CSRC
 */
typedef enum
{
    IfxEdsadc_SampleClockSource_internal = 0,  /**< \brief Internal clock */
    IfxEdsadc_SampleClockSource_inputA   = 3,  /**< \brief External clock, from Input A */
    IfxEdsadc_SampleClockSource_inputB   = 4,  /**< \brief External clock, from Input B */
    IfxEdsadc_SampleClockSource_inputC   = 5   /**< \brief External clock, from Input C */
} IfxEdsadc_SampleClockSource;

/** \brief Service request fifo level
 * Definition in Ifx_EDSADC.RFC.B.SRLVL
 */
typedef enum
{
    IfxEdsadc_ServiceRequestFifolevel_1 = 0,      /**< \brief Generate a service request when Fifo contain level 1 Value  */
    IfxEdsadc_ServiceRequestFifolevel_2,          /**< \brief Generate a service request when Fifo contain level 2 Value  */
    IfxEdsadc_ServiceRequestFifolevel_3,          /**< \brief Generate a service request when Fifo contain level 3 Value  */
    IfxEdsadc_ServiceRequestFifolevel_4           /**< \brief Generate a service request when Fifo contain level 4 Value  */
} IfxEdsadc_ServiceRequestFifolevel;

/** \brief FIFO Fill Level
 * Definition in Ifx_EDSADC.RFC.B.FILL
 */
typedef enum
{
    IfxEdsadc_fifofilllevel_0 = 0,      /**< \brief Result FIFO is empty  */
    IfxEdsadc_fifofilllevel_1,          /**< \brief Result FIFO contains 1 valid value   */
    IfxEdsadc_fifofilllevel_2,          /**< \brief Result FIFO contains 2 valid values  */
    IfxEdsadc_fifofilllevel_3,          /**< \brief Result FIFO contains 3 valid values  */
	IfxEdsadc_fifofilllevel_4,          /**< \brief Result FIFO contains 4 valid values  */
} IfxEdsadc_FifoFillLevel;

/** \brief Enable/disable the sensitivity of the module to sleep signal\n
 * Definition in Ifx_EDSADC.CLC.B.EDIS
 */
typedef enum
{
    IfxEdsadc_SleepMode_enable  = 0, /**< \brief enables sleep mode */
    IfxEdsadc_SleepMode_disable = 1  /**< \brief disables sleep mode */
} IfxEdsadc_SleepMode;

/** \brief Defines when the slew rate filter is activated
 */
typedef enum
{
    IfxEdsadc_StepDetectionMode_lastInput       = 0, /**< \brief Compare threshold to difference of current and last input */
    IfxEdsadc_StepDetectionMode_secondlastInput = 1  /**< \brief Compare threshold to difference of current and second-last input */
} IfxEdsadc_StepDetectionMode;

/** \brief Adjusts the analog circuitry to the supply voltage used in the application
 * system.Defined In defined in MODULE_EDSADC.GLOBCFG.B.SUPLEV
 */
typedef enum
{
    IfxEdsadc_SupplyVoltageLevel_automaticControl = 0,  /**< \brief voltage range is controlled by the power supply */
    IfxEdsadc_SupplyVoltageLevel_upperVoltage     = 1,  /**< \brief Upper voltage range: assume a 5 V power supply is connected */
    IfxEdsadc_SupplyVoltageLevel_lowerVoltage     = 2   /**< \brief Lower voltage range: assume a 3.3 V power supply is connected */
} IfxEdsadc_SupplyVoltageLevel;

/** \brief OCDS Suspend Control (OCDS.SUS)
 */
typedef enum
{
    IfxEdsadc_SuspendMode_none = 0,  /**< \brief No suspend */
    IfxEdsadc_SuspendMode_hard = 1,  /**< \brief Hard Suspend */
    IfxEdsadc_SuspendMode_soft = 2   /**< \brief Soft Suspend */
} IfxEdsadc_SuspendMode;

/** \brief Time Stamp Counter Clock Selection
 */
typedef enum
{
    IfxEdsadc_TimeStampCounterClockSelection_div1 = 0,  /**< \brief fTSTMP = fMOD */
    IfxEdsadc_TimeStampCounterClockSelection_div2 = 1,  /**< \brief fTSTMP = fMOD/2 */
    IfxEdsadc_TimeStampCounterClockSelection_div4 = 2,  /**< \brief fTSTMP = fMOD/4 */
    IfxEdsadc_TimeStampCounterClockSelection_div8 = 3   /**< \brief fTSTMP = fMOD/8 */
} IfxEdsadc_TimeStampCounterClockSelection;

/** \brief Timestamp trigger mode\n
 * Definition in Ifx_EDSADC.DICFG.B.TSTRMODE
 */
typedef enum
{
    IfxEdsadc_TimestampTrigger_noTrigger   = 0,  /**< \brief No timestamp trigger */
    IfxEdsadc_TimestampTrigger_fallingEdge = 1,  /**< \brief Trigger event upon a falling edge */
    IfxEdsadc_TimestampTrigger_risingEdge  = 2,  /**< \brief Trigger event upon a rising edge */
    IfxEdsadc_TimestampTrigger_eachEdge    = 3   /**< \brief Trigger event upon each edge */
} IfxEdsadc_TimestampTrigger;

/** \brief Trigger select\n
 * Definition in Ifx_EDSADC.DICFG.B.TRSEL
 */
typedef enum
{
    IfxEdsadc_TriggerInput_a = 0,   /**< \brief GTM EDSADC Trigger 0 */
    IfxEdsadc_TriggerInput_b = 1,   /**< \brief GTM EDSADC Trigger 1 */
    IfxEdsadc_TriggerInput_c = 2,   /**< \brief GTM ADC Trigger 0 */
    IfxEdsadc_TriggerInput_d = 3,   /**< \brief GTM ADC Trigger 1 */
    IfxEdsadc_TriggerInput_e = 4,   /**< \brief Trigger/gate via port input P33.0 */
    IfxEdsadc_TriggerInput_f = 5,   /**< \brief Trigger/gate via port input P33.4 */
    IfxEdsadc_TriggerInput_g = 6,   /**< \brief ERU pattern detection output 0 */
    IfxEdsadc_TriggerInput_h = 7,   /**< \brief Trigger/gate, channel 0,input H */
    IfxEdsadc_TriggerInput_i = 8,   /**< \brief Trigger/gate, channel 0,input I */
    IfxEdsadc_TriggerInput_j = 9,   /**< \brief Trigger/gate, channel 0,input J */
    IfxEdsadc_TriggerInput_k = 10,  /**< \brief GTM ADC Trigger 2 */
    IfxEdsadc_TriggerInput_l = 11,  /**< \brief GTM ADC Trigger 3 */
    IfxEdsadc_TriggerInput_m = 12,  /**< \brief GTM DSADC Trigger 2 */
    IfxEdsadc_TriggerInput_n = 13,  /**< \brief GTM DSADC Trigger 3 */
    IfxEdsadc_TriggerInput_o = 14,  /**< \brief Trigger/gate, channel 0,input O */
    IfxEdsadc_TriggerInput_p = 15   /**< \brief Trigger/gate, channel 0,input P */
} IfxEdsadc_TriggerInput;

/** \brief Controls the dithering function for each modulator separately
 * Definition in Ifx_DSADC.MODCFG.B.DITHEN
 */
typedef enum
{
    IfxEdsadc_dithering_disabled = 0,  /**< \brief dithering function disabled */
    IfxEdsadc_dithering_enabled  = 1   /**< \brief dithering function enabled */
} IfxEdsadc_dithering;

/** \brief Automatic Power Control
 * Definition in Ifx_DSADC.MODCFG.B.APC
 */
typedef enum
{
    IfxEdsadc_AutomaticPowerControl_off              = 0,  /**< \brief Modulator active while its associated bit MxRUN is set */
	IfxEdsadc_AutomaticPowerControl_slowStandbyMode  = 1,  /**< \brief on-chip modulator and voltage regulator are deactivated, external modulator clock is disabled,
                                                            * while the gate signal (selected trigger) is inactive */
	IfxEdsadc_AutomaticPowerControl_fastStandbyMode  = 2   /**< \brief on-chip modulator is deactivated, external modulator clock is disabled,
                                                            * while the gate signal (selected trigger) is inactive */
} IfxEdsadc_AutomaticPowerControl;

/** \} */

/** \brief Allows copying of bitfield AMX into bitfield TIMESTAMP
 */
typedef enum
{
    IfxEdsadc_AnalogMux_doNotCopyAmx = 0,  /**< \brief Do not copy, timestamp uses all 16 bits */
    IfxEdsadc_AnalogMux_copyAmx      = 1   /**< \brief Copy AMX to bits TIMESTAMP[15:14], timestamp uses lower 14 bits */
} IfxEdsadc_AnalogMux;

/** \brief Timestamp Counter Run Control
 */
typedef enum
{
    IfxEdsadc_TimeStampCounterControl_off = 0,  /**< \brief Timestamp counter is off */
    IfxEdsadc_TimeStampCounterControl_on  = 1   /**< \brief Timestamp counter is counting at the rate selected by bitfield TSCLK */
} IfxEdsadc_TimeStampCounterControl;

/** \brief Slew Rate Filter Strength
 * Definition in Ifx_EDSADC.OVSCFGx.B.SRFS
 */
typedef enum
{
    IfxEdsadc_SlewRateFilterStrength_min    = 0, /**< \brief Minimum filter effect, early attenuation, linear operation */
	IfxEdsadc_SlewRateFilterStrength_weak   = 1, /**< \brief Weak filter effect */
	IfxEdsadc_SlewRateFilterStrength_medium = 2, /**< \brief Medium filter effect */
	IfxEdsadc_SlewRateFilterStrength_max    = 3  /**< \brief Maximum filter effect, steep beginning, smooth end */
} IfxEdsadc_SlewRateFilterStrength;

/** \brief Slew Rate Filter Run Time
 * Definition in Ifx_EDSADC.OVSCFGx.B.SRFRT
 */
typedef enum
{
    IfxEdsadc_SlewrateFilterRuntime_inputCycles2   = 0, /**< \brief 2 input cycles */
	IfxEdsadc_SlewrateFilterRuntime_inputCycles4   = 1, /**< \brief 4 input cycles */
	IfxEdsadc_SlewrateFilterRuntime_inputCycles8   = 2, /**< \brief 8 input cycles */
	IfxEdsadc_SlewrateFilterRuntime_inputCycles16  = 3  /**< \brief 16 input cycles */
} IfxEdsadc_SlewrateFilterRuntime;

/** \brief Auxiliary Filter Decimation Factor Selection
 */
typedef enum
{
	IfxEdsadc_AuxiliaryFilterDecimationFactor_16 = 0,  /**< \brief CIC Filter decimation factor OSR = 16 */
	IfxEdsadc_AuxiliaryFilterDecimationFactor_32 = 1   /**< \brief CIC Filter decimation factor OSR = 32 */
}IfxEdsadc_AuxiliaryFilterDecimationFactor;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \brief Modulator Configuration
 */
typedef struct
{
    float32                        modulatorClockPeriod;         /**< \brief Modulator clock period */
    IfxEdsadc_InputGain            inputGain;                    /**< \brief Modulator gain select of analog input path */
    IfxEdsadc_AnalogClockSyncDelay analogClockSyncDelay;         /**< \brief Define the delay in clock cycle after sync signal */
    IfxEdsadc_InputConfig          positiveInput;                /**< \brief Modulator configuration of positive input line */
    IfxEdsadc_InputConfig          negativeInput;                /**< \brief Modulator configuration of negative input line */
    IfxEdsadc_InputPin             inputPin;                     /**< \brief Modulator input pin selection */
    IfxEdsadc_dithering            ditheringEnabled;             /**< \brief Control the Dithering Function for each modulator */
    boolean                        integratorResetEnabled;       /**< \brief Control the modulator overload handling */
    boolean                        inputMuxActionControl;        /**< \brief Defines the mechanism by which the input multiplexer is controlled */
    IfxEdsadc_InputMuxControlMode  triggerEvent;                 /**< \brief Defines the condition for a trigger event to control the input multiplexer */
} IfxEdsadc_ModulatorConfig;

/** \addtogroup IfxLld_Edsadc_Std_Operative
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Returns the module's suspend state.
 *
 * \param[in] edsadc Pointer to the EDSADC module.
 *
 * \retval TRUE if the module is suspended and FALSE if the module is not yet suspended.
 */
IFX_INLINE boolean IfxEdsadc_isModuleSuspended(Ifx_EDSADC *edsadc);

/** \brief Sets the sensitivity of the module to sleep signal
 *
 * \param[inout] edsadc Pointer to the EDSADC module.
 * \param[in]    mode   Mode selection (enable/disable).
 *					    Range:\ref IfxEdsadc_SleepMode
 *
 * \return None
 */
IFX_INLINE void IfxEdsadc_setSleepMode(Ifx_EDSADC *edsadc, IfxEdsadc_SleepMode mode);

/**
 * \brief Configures the module to hard/soft suspend mode.
 *
 * \note The api works only when the OCDS is enabled and in Supervisor Mode.
 *       When OCDS is disabled the OCS suspend control is ineffective.
 *
 * \param[inout] edsadc Pointer to the EDSADC module.
 * \param[in]    mode   Module suspend mode.
 *                      Range:\ref IfxEdsadc_SuspendMode
 *
 * \retval None
 */
IFX_INLINE void IfxEdsadc_setSuspendMode(Ifx_EDSADC *edsadc, IfxEdsadc_SuspendMode mode);

/**
 * \brief Starts a scan operation on the specified EDSADC module by enabling the selected modulators and channels.
 *
 * \note Refer device specific Edsadc_cfg file for device specific channels numbers.
 *
 * \param[inout] edsadc      Pointer to the EDSADC module.
 * \param[in]    Bitmask     specifying the modulators to activate.
 *                           Range: 0x0001 to 0x3FFF. (This range is applicable for TC39XB device variant)
 * \param[in] channelMask Bitmask representing the channels to be enabled. Each bit in this mask corresponds to a specific channel.
 *                        Range: 0x0001 to 0x3FFF. (This range is applicable for TC39XB device variant)
 *
 * \retval None
 */
IFX_INLINE void IfxEdsadc_startScan(Ifx_EDSADC *edsadc, uint32 modulatorMask, uint32 channelMask);

/**
 * \brief Stops the scan operation for the specified modulators.
 *
 * \note Refer device specific Edsadc_cfg file for device specific channels numbers.
 *
 * \param[inout] edsadc         Pointer to the EDSADC module.
 * \param[in]    modulatorMask  Bitmask specifying which modulators to stop. Each bit in the mask corresponds to a modulator.
 *                              Range: 0x0001 to 0x3FFF. (This range is applicable for TC39XB device variant)
 *
 *\retval None
 */
IFX_INLINE void IfxEdsadc_stopScan(Ifx_EDSADC *edsadc, uint32 modulatorMask);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Disables the EDSADC module.
 *
 * \param[inout] edsadc Pointer to the EDSADC module.
 *
 * \retval None
 */
IFX_EXTERN void IfxEdsadc_disableModule(Ifx_EDSADC *edsadc);

/**
 * \brief Enables the EDSADC module.
 *
 * \param[inout] edsadc Pointer to the EDSADC module.
 *
 * \retval None
 */
IFX_EXTERN void IfxEdsadc_enableModule(Ifx_EDSADC *edsadc);

/** 
 * \brief Resets the EDSADC module.
 *
 * \param[inout] edsadc Pointer to the EDSADC module.
 *
 * \retval None
 */
IFX_EXTERN void IfxEdsadc_resetModule(Ifx_EDSADC *edsadc);

/** \} */

/** \addtogroup IfxLld_Edsadc_Std_Support
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Retrieves the main comb decimation factor for the specified channel.
 *
 * \param[in]  edsadc  Pointer to the EDSADC module.
 * \param[in]  channel Channel ID.
 *                     Range:\ref IfxEdsadc_ChannelId
 *
 * \retval uint16. Return the main comb decimation factor
 *         Range: 0 to 255.
 */
IFX_INLINE uint16 IfxEdsadc_getMainCombDecimation(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/**
 * \brief Retrieves the main result of the specified EDSADC channel.
 *
 * \note When RDM=1 (unsigned data), the raw value from the result
 *       register has to be manipulated by subtracting with 32768 (2^16)
 *       to get the correct raw value
 *
 * \param[in]  edsadc  Pointer to the EDSADC module.
 * \param[in]  channel Channel ID.
 *                     Range:\ref IfxEdsadc_ChannelId
 *
 * \retval sint16. Return result from the main filter chain
 */
IFX_INLINE sint16 IfxEdsadc_getMainResult(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/**
 * \brief Retrieves the subsequent result from the specified EDSADC channel.
 *
 * \note When RDM=1 (unsigned data), the raw value from the result
 *       register has to be manipulated by subtracting with 32768 (2^16)
 *       to get the correct raw value
 *
 * \param[in]  edsadc  Pointer to the EDSADC module.
 * \param[in]  channel Channel ID.
 *                     Range:\ref IfxEdsadc_ChannelId
 *
 * \retval sint32. Return result from the main filter chain
 */
IFX_INLINE sint32 IfxEdsadc_getSubsequentResult(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/**
 * \brief Checks if the EDSADC module is enabled.
 *
 * \param[in] edsadc Pointer to the EDSADC module.
 *
 * \retval TRUE if the module is enabled and FALSE if the module is disabled.
 */
IFX_INLINE boolean IfxEdsadc_isModuleEnabled(Ifx_EDSADC *edsadc);

/** 
 * \brief Set the carrier waveform mode
 *
 * \param[inout] edsadc       Pointer to the EDSADC module.
 * \param[in]    waveformMode The waveform mode to set.
 *                            Range:\ref IfxEdsadc_CarrierWaveformMode
 *
 * \retval None
 */
IFX_INLINE void IfxEdsadc_setCarrierMode(Ifx_EDSADC *edsadc, IfxEdsadc_CarrierWaveformMode waveformMode);

/**
 * \brief Retrieves the auxiliary result from the specified EDSADC channel.
 *
 * \param[in]  edsadc  Pointer to the EDSADC module.
 * \param[in]  channel Channel ID.
 *                     Range:\ref IfxEdsadc_ChannelId
 *
 * \retval uint16. Return most recent result of auxiliary filter.
 *         Range: 0 to FFFF.
 */
IFX_INLINE uint16 IfxEdsadc_getAuxResult(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** 
 * \brief Get the sample frequency of the integrator output in Hz
 *
 * \param[in]  edsadc  Pointer to the EDSADC module.
 * \param[in]  channel Channel ID.
 *                     Range:\ref IfxEdsadc_ChannelId
 *
 * \retval float32 Frequency of the integrator output in Hz.
 */
IFX_EXTERN float32 IfxEdsadc_getIntegratorOutFreq(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/**
 * \brief Gets the main combined output frequency for the specified EDSADC channel.
 *
 * \param[in]  edsadc  Pointer to the EDSADC module.
 * \param[in]  channel Channel ID.
 *                     Range:\ref IfxEdsadc_ChannelId
 *
 * \retval float32 Frequency of the integrator output in Hz.
 */
IFX_EXTERN float32 IfxEdsadc_getMainCombOutFreq(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/** 
 * \brief Estimate the group delay of main filter chain in seconds
 *
 * \param[in] edsadc  Pointer to the EDSADC module.
 * \param[in]  channel Channel ID.
 *                     Range:\ref IfxEdsadc_ChannelId
 *
 * \retval float32 Estimated group delay of the main filter chain in seconds.
 */
IFX_EXTERN float32 IfxEdsadc_getMainGroupDelay(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/** 
 * \brief Get the modulator clock frequency in Hz
 *
 * \param[in]  edsadc  Pointer to the EDSADC module.
 * \param[in]  channel Channel ID.
 *                     Range:\ref IfxEdsadc_ChannelId
 *
 * \retval float32 Modulator clock frequency in Hz.
 */
IFX_EXTERN float32 IfxEdsadc_getModulatorClockFreq(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/**
 * \brief Gets the input clock frequency of the EDSADC modulator in Hz.
 *
 * \param[in] edsadc Pointer to the EDSADC module.
 *
 * \retval float32 Input clock frequency of the modulator in Hz.
 */
IFX_EXTERN float32 IfxEdsadc_getModulatorInputClockFreq(Ifx_EDSADC *edsadc);

/** \} */

/** \addtogroup IfxLld_Edsadc_Std_Interrupt
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Returns a pointer to the auxiliary source register of a specified channel in the EDSADC module.
 *
 * \param[in]  edsadc  Pointer to the EDSADC module.
 * \param[in]  channel Channel Id
 * 					   Range:\ref IfxEdsadc_ChannelId
 *
 * \retval volatile Ifx_SRC_SRCR *. Address/pointer to the interrupt source register
 */
IFX_EXTERN volatile Ifx_SRC_SRCR *IfxEdsadc_getAuxSrc(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/**
 * \brief Returns a pointer to the main source register of a specified channel in the EDSADC module.
 *
 * \param[in]  edsadc  Pointer to the EDSADC module.
 * \param[in]  channel Channel Id
 *                     Range:\ref IfxEdsadc_ChannelId
 *
 * retval volatile Ifx_SRC_SRCR *. Address/pointer to the interrupt source register
 */
IFX_EXTERN volatile Ifx_SRC_SRCR *IfxEdsadc_getMainSrc(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/** \} */

/** \addtogroup IfxLld_Edsadc_Std_IO
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Initializes a CGPWM output pin.
 *
 * \param[in]  cgPwm     Pointer to the CGPWM output configuration structure.
 * \param[in]  pinMode   Output mode to be set for the PWM pin (e.g., push-pull or open-drain).
 *                       Range:\ref IfxPort_OutputMode
 * \param[in]  padDriver The pad driver mode to be configured.
 *                       Range:\ref IfxPort_PadDriver
 *
 * \retval None
 */
IFX_INLINE void IfxEdsadc_initCgPwmPin(const IfxEdsadc_Cgpwm_Out *cgPwm, IfxPort_OutputMode pinMode, IfxPort_PadDriver padDriver);

/**
 * \brief Initializes a CIN input pin.
 *
 * \param[in]  cIn       Pointer to the CIN pin configuration structure.
 * \param[in]  cInMode   The pin input mode to be configured.
 *                       Range:\ref IfxPort_InputMode
 * \param[in]  padDriver The pad driver configuration to be applied.
 *                       Range:\ref IfxPort_PadDriver
 *
 * \retval None
 */
IFX_INLINE void IfxEdsadc_initCinPin(const IfxEdsadc_Cin_In *cIn, IfxPort_InputMode cInMode, IfxPort_PadDriver padDriver);

/** 
 * \brief Initializes a COUT output
 *
 * \param[in]  cout      Pointer to the COUT pin configuration structure.
 * \param[in]  pinMode   Output mode to be set for the PWM pin (e.g., push-pull or open-drain).
 *                       Range:\ref IfxPort_OutputMode
 * \param[in]  padDriver The pad driver configuration to be applied.
 *                       Range:\ref IfxPort_PadDriver
 *
 * \retval None
 */
IFX_INLINE void IfxEdsadc_initCoutPin(const IfxEdsadc_Cout_Out *cout, IfxPort_OutputMode pinMode, IfxPort_PadDriver padDriver);

/**
 * \brief Initializes the EDSADC digital input pin with the specified mode and pad driver settings.
 *
 * \param[in]  dIn       Pointer to the digital input pin configuration structure.
 * \param[in]  dInMode   The pin input mode to be configured.
 *                       Range:\ref IfxPort_InputMode
 * \param[in]  padDriver The pad driver configuration to be applied.
 *                       Range:\ref IfxPort_PadDriver
 *
 * \retval None
 */
IFX_INLINE void IfxEdsadc_initDinPin(const IfxEdsadc_Din_In *dIn, IfxPort_InputMode dInMode, IfxPort_PadDriver padDriver);

/**
 * \brief Initializes the DSN pin with the specified input mode and pad driver settings.
 *
 * \param[in]  dsn       Pointer to the DSN input configuration structure.
 * \param[in]  pinMode   The pin input mode to be configured.
 *					     Range:\ref IfxPort_InputMode
 * \param[in]  padDriver The pad driver configuration to be applied.
 *                       Range:\ref IfxPort_PadDriver
 *
 * \retval None
 */
IFX_INLINE void IfxEdsadc_initDsnPin(const IfxEdsadc_Dsn_In *dsn, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver);

/** 
 * \brief Initializes the DSP pin with the specified input mode and pad driver settings.
 *
 * \param[in]  dsp       Pointer to the DSP pin configuration structure.
 * \param[in]  pinMode   The pin input mode to be configured.
 *					     Range:\ref IfxPort_InputMode
 * \param[in]  padDriver The pad driver configuration to be applied.
 *                       Range:\ref IfxPort_PadDriver
 *
 * \retval None
 */
IFX_INLINE void IfxEdsadc_initDspPin(const IfxEdsadc_Dsp_In *dsp, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver);

/** 
 * \brief Initializes a ITR input
 *
 * \param[in]  itr       Pointer to the ITR pin configuration structure.
 * \param[in]  itrMode   The pin input mode to be configured.
 *					     Range:\ref IfxPort_InputMode
 * \param[in]  padDriver The pad driver configuration to be applied.
 *                       Range:\ref IfxPort_PadDriver
 *
 * \retval None
 */
IFX_INLINE void IfxEdsadc_initItrPin(const IfxEdsadc_Itr_In *itr, IfxPort_InputMode itrMode, IfxPort_PadDriver padDriver);

/**
 * \brief Initializes the specified SG pin with the given input mode and pad driver configuration.
 *
 * \param[in]  sg         Pointer to the SG input channel configuration structure.
 * \param[in]  pinMode   The pin input mode to be configured.
 *					     Range:\ref IfxPort_InputMode
 * \param[in]  padDriver The pad driver configuration to be applied.
 *                       Range:\ref IfxPort_PadDriver
 *
 * \retval None
 */
IFX_INLINE void IfxEdsadc_initSgPin(const IfxEdsadc_Sg_In *sg, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver);

/**
 * \brief Flushes the FIFO for the specified EDSADC channel.
 *
 * \param[inout] edsadc  Pointer to the EDSADC module.
 * \param[in]    channel The channel ID
 *					     Range:\ref IfxEdsadc_ChannelId.
 *
 * \retval None
 */
IFX_INLINE void IfxEdsadc_flushFifo(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/**
 * \brief Retrieves the fill level of the FIFO buffer for the specified EDSADC channel.
 *
 * \param[in] edsadc  Pointer to the EDSADC module.
 * \param[in]  channel The channel ID for which to retrieve the FIFO fill level.
                       Range:\ref IfxEdsadc_ChannelId.
 *
 * \retval IfxEdsadc_FifoFillLevel The current fill level of the FIFO buffer, indicating the number of data elements stored.
 *         Range:\ref IfxEdsadc_FifoFillLevel
 */
IFX_INLINE IfxEdsadc_FifoFillLevel IfxEdsadc_getEdsadcFifoFillLevel(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/**
 * \brief Clears the read error flag for the specified EDSADC channel.
 *
 * \param[inout] edsadc  Pointer to the EDSADC module.
 * \param[in]    channel The channel ID for which the read error flag needs to be cleared.
 *				         Range:\ref IfxEdsadc_ChannelId
 *
 * \retval None
 */
IFX_INLINE void Ifx_Edsadc_ClearReadErrorFlag(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/**
 * \brief Clears the write error flag for the specified channel.
 *
 * \param[inout] edsadc  Pointer to the EDSADC module.
 * \param[in]    channel The channel ID for which the write error flag needs to be cleared.
 *                       Range:\ref IfxEdsadc_ChannelId
 *
 * \retval None
 */
IFX_INLINE void Ifx_Edsadc_ClearWriteErrorFlag(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Gets the positive input line configuration for the specified EDSADC channel.
 *
 * \param[in]  edsadc  Pointer to the EDSADC module.
 * \param[in]  channel The channel ID for which the positive input line configuration is to be retrieved.
 *                     Range:\ref IfxEdsadc_ChannelId
 *
 * \retval uint8 The configuration value of the positive input line for the specified channel.
 *          Range: 0: Modulator input connected to external pin.
 *                 1: Modulator input connected to reference voltage.
 * 			       2: Modulator input connected to common mode voltage.
 *                 3: Modulator input connected to reference ground.
 */
IFX_INLINE uint8 IfxEdsadc_getPositiveInputLineConfiguration(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/**
 * \brief Retrieves the negative input line configuration for the specified channel.
 *
 * \param[in]  edsadc  Pointer to the EDSADC module.
 * \param[in]  channel The channel ID for which the positive input line configuration is to be retrieved.
 *                     Range:\ref IfxEdsadc_ChannelId
 *
 * \retval uint8 The configuration value of the negative input line for the specified channel.
 *          Range: 0: Modulator input connected to external pin.
 *                 1: Modulator input connected to reference voltage.
 * 			       2: Modulator input connected to common mode voltage.
 *                 3: Modulator input connected to reference ground.
 */
IFX_INLINE uint8 IfxEdsadc_getNegativeInputLineConfiguration(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/** 
 * \brief Sets the Offset compensation Value
 *
 * \param[inout] edsadc  Pointer to the EDSADC module.
 * \param[in]    channel The channel ID.
 *                       Range:\ref IfxEdsadc_ChannelId
 * \param[in] value   Offset compensation value to be set.
 *
 * \retval None
 */
IFX_INLINE void IfxEdsadc_setOffsetCompensationValue(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel, uint16 value);

/**
 * \brief Gets the result register address for the specified EDSADC channel.
 *
 * \param[in]  edsadc  Pointer to the EDSADC module.
 * \param[in]  channel The channel ID for which the result register address is to be retrieved.
 *                     Range:\ref IfxEdsadc_ChannelId
 *
 * \retval uint32 * Pointer to the result register address of the specified channel.
 *         Range: 0x00000001 to 0xFFFFFFFF.
 */
IFX_INLINE uint32 *IfxEdsadc_getResultRegisterAddress(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/**
 * \brief Retrieves the calibration status of the specified EDSADC channel.
 *
 * \param[in]  edsadc  Pointer to the EDSADC module.
 * \param[in]  channel The channel ID for which to retrieve the calibration status.
 *                     Range:\ref IfxEdsadc_ChannelId
 *
 * \retval uint8
 *         Range: 0: Uncalibrated, initial state after reset
 *                1: The calibration algorithm is currently running
 *                2: Calibrated, normal operation is possible
 *                3: Calibration terminated incorrectly
 */
IFX_INLINE uint8 IfxEdsadc_getCalibrationStatus(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Sets the common mode voltage configuration for the specified EDSADC channel.
 *
 * \param[inout] edsadc        Pointer to the EDSADC module.
 * \param[in]    channel       Channel ID
 *					           Range: IfxEdsadc_ChannelId
 * \param[in]    voltage       The fractional reference voltage selection.
 *                             Range: \ref IfxEdsadc_FractionalRefVoltageSelection
 * \param[in]    refMode       The fractional reference voltage enable/disable.
 *                             Range: \ref IfxEdsadc_FractionalRefVoltage
 * \param[in]    positiveInput The positive input configuration value.
 *                             Range: 0 to 255 (bitmask for channels).
 * \param[in]    negativeInput The negative input configuration value.
 *                             Range: 0 to 255 (bitmask for channels).
 *
 * \retval None
 */
IFX_EXTERN void IfxEdsadc_setCommonModeVoltage(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel, IfxEdsadc_FractionalRefVoltageSelection voltage, IfxEdsadc_FractionalRefVoltage refMode, uint8 positiveInput, uint8 negativeInput);

/**
 * \brief Sets the gain correction factor for the specified EDSADC channel.
 *
 * \param[inout] edsadc     Pointer to the EDSADC module.
 * \param[in]    channel    Channel ID for which the gain correction factor will be set.
 *                          Range: \ref IfxEdsadc_ChannelId
 * \param[in]    gainFactor Multiplication factor for gain correction.
 *                          Range: 0 to 4095.
 * \param[in]    cicShift   Position of the CIC filter output shifter.
 *                          Range: 0 to 31.
 *
 * \retval None
 */
IFX_EXTERN void IfxEdsadc_setGainCorrectionFactor(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel, uint16 gainFactor, uint8 cicShift);

/**
 * \brief Configures the timestamp counter for the specified EDSADC channel.
 *
 * \param[inout] edsadc                Pointer to the EDSADC module.
 * \param[in]    channel               Channel ID.
 *                                     Range \ref IfxEdsadc_ChannelId
 * \param[in]    timeStampCounterClock The clock selection for the timestamp counter.
 *                                     Range: \ref IfxEdsadc_TimeStampCounterClockSelection
 * \param[in]    runControl            The run control for the timestamp counter.
 *                                     Range:\ref IfxEdsadc_TimeStampCounterControl
 * \param[in]    analogMuxCopy         The analog mux copy setting.
 *                                     Range:\ref IfxEdsadc_AnalogMux
 *
 * \retval None
 */
IFX_EXTERN void IfxEdsadc_setTimeStampCounter(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel, IfxEdsadc_TimeStampCounterClockSelection timeStampCounterClock, IfxEdsadc_TimeStampCounterControl runControl, IfxEdsadc_AnalogMux analogMuxCopy);

/**
 * \brief Configures the gain control parameters for the specified EDSADC channel.
 *
 * \param[inout] edsadc            Pointer to the EDSADC module.
 * \param[in]    channel           Channel ID.
 *                                 Range:\ref IfxEdsadc_ChannelId
 * \param[in]    gainFactor        Multiplication factor for gain correction.
 *                                 Range: 0 to FFFF.
 * \param[in]    cicShift          Position of the CIC filter output shifter.
 *                                 Range: 0 to 31.
 * \param[in]    cicDecimationRate Decimation rate of the CIC filter during calibration.
 *                                 Range: 0 to 255.
 *
 * \retval None
 */
IFX_EXTERN void IfxEdsadc_setGainControl(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel, uint16 gainFactor, uint8 cicShift, uint8 cicDecimationRate);

/**
 * \brief Configures the gain calibration for a specific EDSADC channel.
 *
 * \param[inout] edsadc    Pointer to the EDSADC module.
 * \param[in]    channel   The channel ID to configure the gain calibration for.
 *                         Range:\ref IfxEdsadc_ChannelId
 * \param[in]    calFactor Multiplication factor for gain calibration.
 *                         Range: 0 to FFFF.
 * \param[in]    calTarget The target value for the gain calibration.
 *                         Range: 0 to FFFF.
 *
 * \retval None
 */
IFX_EXTERN void IfxEdsadc_setGainCalibration(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel, uint16 calFactor, uint16 calTarget);

/**
 * \brief Configures the modulator for the specified EDSADC channel.
 *
 * \param[inout] edsadc  Pointer to the EDSADC module.
 * \param[in]    channel The channel ID to configure the modulator for.
 *                       Range:\ref IfxEdsadc_ChannelId
 * \param[in]    config  Pointer to the modulator configuration structure.
 *
 * \retval None
 */
IFX_EXTERN void IfxEdsadc_configureModulator(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel, IfxEdsadc_ModulatorConfig *config);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE uint16 IfxEdsadc_getMainCombDecimation(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel)
{
    return (uint16)(1U + edsadc->CH[channel].FCFGC.B.CFMDF);
}


IFX_INLINE sint16 IfxEdsadc_getMainResult(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel)
{
    return edsadc->CH[channel].RESM.B.RESULTLO;
}


IFX_INLINE sint32 IfxEdsadc_getSubsequentResult(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel)
{
    return (sint32)(edsadc->CH[channel].RESM.U);
}


IFX_INLINE void IfxEdsadc_initCgPwmPin(const IfxEdsadc_Cgpwm_Out *cgPwm, IfxPort_OutputMode pinMode, IfxPort_PadDriver padDriver)
{
    if (cgPwm->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeOutput(cgPwm->pin.port, cgPwm->pin.pinIndex, pinMode, cgPwm->select);
        IfxPort_setPinPadDriver(cgPwm->pin.port, cgPwm->pin.pinIndex, padDriver);
    }
}


IFX_INLINE void IfxEdsadc_initCinPin(const IfxEdsadc_Cin_In *cIn, IfxPort_InputMode cInMode, IfxPort_PadDriver padDriver)
{
    if (cIn->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeInput(cIn->pin.port, cIn->pin.pinIndex, cInMode);
        IfxPort_setPinPadDriver(cIn->pin.port, cIn->pin.pinIndex, padDriver);
    }
}


IFX_INLINE void IfxEdsadc_initCoutPin(const IfxEdsadc_Cout_Out *cout, IfxPort_OutputMode pinMode, IfxPort_PadDriver padDriver)
{
    if (cout->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeOutput(cout->pin.port, cout->pin.pinIndex, pinMode, cout->select);
        IfxPort_setPinPadDriver(cout->pin.port, cout->pin.pinIndex, padDriver);
    }
}


IFX_INLINE void IfxEdsadc_initDinPin(const IfxEdsadc_Din_In *dIn, IfxPort_InputMode dInMode, IfxPort_PadDriver padDriver)
{
    if (dIn->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeInput(dIn->pin.port, dIn->pin.pinIndex, dInMode);
        IfxPort_setPinPadDriver(dIn->pin.port, dIn->pin.pinIndex, padDriver);
    }
}


IFX_INLINE void IfxEdsadc_initDsnPin(const IfxEdsadc_Dsn_In *dsn, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver)
{
    if (dsn->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeInput(dsn->pin.port, dsn->pin.pinIndex, pinMode);
        IfxPort_setPinPadDriver(dsn->pin.port, dsn->pin.pinIndex, padDriver);
    }
}


IFX_INLINE void IfxEdsadc_initDspPin(const IfxEdsadc_Dsp_In *dsp, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver)
{
    if (dsp->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeInput(dsp->pin.port, dsp->pin.pinIndex, pinMode);
        IfxPort_setPinPadDriver(dsp->pin.port, dsp->pin.pinIndex, padDriver);
    }
}


IFX_INLINE void IfxEdsadc_initItrPin(const IfxEdsadc_Itr_In *itr, IfxPort_InputMode itrMode, IfxPort_PadDriver padDriver)
{
    if (itr->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeInput(itr->pin.port, itr->pin.pinIndex, itrMode);
        IfxPort_setPinPadDriver(itr->pin.port, itr->pin.pinIndex, padDriver);
    }
}


IFX_INLINE void IfxEdsadc_initSgPin(const IfxEdsadc_Sg_In *sg, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver)
{
    if (sg->pin.port != NULL_PTR)
    {
        IfxPort_setPinModeInput(sg->pin.port, sg->pin.pinIndex, pinMode);
        IfxPort_setPinPadDriver(sg->pin.port, sg->pin.pinIndex, padDriver);
    }
}


IFX_INLINE boolean IfxEdsadc_isModuleEnabled(Ifx_EDSADC *edsadc)
{
    return edsadc->CLC.B.DISS == 0;
}


IFX_INLINE boolean IfxEdsadc_isModuleSuspended(Ifx_EDSADC *edsadc)
{
    boolean status = FALSE;

    if (edsadc->OCS.B.SUSSTA == 1)
    {
        status = TRUE;
    }
    else
    {
        status = FALSE;
    }

    return status;
}


IFX_INLINE void IfxEdsadc_setCarrierMode(Ifx_EDSADC *edsadc, IfxEdsadc_CarrierWaveformMode waveformMode)
{
    edsadc->CGCFG.B.CGMOD = waveformMode;
}


IFX_INLINE void IfxEdsadc_setSleepMode(Ifx_EDSADC *edsadc, IfxEdsadc_SleepMode mode)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(passwd);
    edsadc->CLC.B.EDIS = mode;
    IfxScuWdt_setCpuEndinit(passwd);
}


IFX_INLINE void IfxEdsadc_setSuspendMode(Ifx_EDSADC *edsadc, IfxEdsadc_SuspendMode mode)
{
    Ifx_EDSADC_OCS ocs;

    ocs.U = edsadc->OCS.U;

    /* remove protection and configure the suspend mode. */
    ocs.B.SUS_P   = 1;
    ocs.B.SUS     = mode;
    edsadc->OCS.U = ocs.U;
}


IFX_INLINE void IfxEdsadc_startScan(Ifx_EDSADC *edsadc, uint32 modulatorMask, uint32 channelMask)
{
    edsadc->GLOBRC.U = edsadc->GLOBRC.U | ((modulatorMask << 16) | (channelMask));
}


IFX_INLINE void IfxEdsadc_stopScan(Ifx_EDSADC *edsadc, uint32 modulatorMask)
{
    edsadc->GLOBRC.U &= ~(modulatorMask << 16);
}


IFX_INLINE uint8 IfxEdsadc_getPositiveInputLineConfiguration(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel)
{
    return edsadc->CH[channel].MODCFG.B.INCFGP;
}


IFX_INLINE uint8 IfxEdsadc_getNegativeInputLineConfiguration(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel)
{
    return edsadc->CH[channel].MODCFG.B.INCFGN;
}


IFX_INLINE void IfxEdsadc_setOffsetCompensationValue(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel, uint16 value)
{
    edsadc->CH[channel].OFFCOMP.B.OFFSET = value;
}


IFX_INLINE uint32 *IfxEdsadc_getResultRegisterAddress(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel)
{
    return (uint32 *)&(edsadc->CH[channel].RESM.U);
}


IFX_INLINE uint8 IfxEdsadc_getCalibrationStatus(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel)
{
    return (uint8)(edsadc->CH[channel].FCNTC.B.CAL);
}


IFX_INLINE void IfxEdsadc_flushFifo(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel)
{
	edsadc->CH[channel].RFC.B.FIFL = 1;
}


IFX_INLINE IfxEdsadc_FifoFillLevel IfxEdsadc_getEdsadcFifoFillLevel(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel)
{
	return (IfxEdsadc_FifoFillLevel)(edsadc->CH[channel].RFC.B.FILL);
}


IFX_INLINE void Ifx_Edsadc_ClearReadErrorFlag(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel)
{
	edsadc->CH[channel].RFC.B.RDEC = 1;     /* Clear Read Error Flag  (RDERR) */
}


IFX_INLINE void Ifx_Edsadc_ClearWriteErrorFlag(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel)
{
	edsadc->CH[channel].RFC.B.WREC = 1;		/* Clear Write Error Flag (WRERR) */
}


IFX_INLINE uint16 IfxEdsadc_getAuxResult(Ifx_EDSADC *edsadc, IfxEdsadc_ChannelId channel)
{
	return (uint16)edsadc->CH[channel].RESA.B.RESULT;
}


#endif /* IFXEDSADC_H */
