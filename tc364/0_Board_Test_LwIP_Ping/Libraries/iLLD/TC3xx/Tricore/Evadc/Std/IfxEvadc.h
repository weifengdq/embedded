/**
 * \file IfxEvadc.h
 * \brief EVADC  basic functionality
 * \ingroup IfxLld_Evadc
 *
 * \version iLLD_1_20_0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Evadc_Std_Enum Enumerations
 * \ingroup IfxLld_Evadc_Std
 * \defgroup IfxLld_Evadc_Std_Global Global Functions
 * \ingroup IfxLld_Evadc_Std
 * \defgroup IfxLld_Evadc_Std_QueueRequest Queue Request Functions
 * \ingroup IfxLld_Evadc_Std
 * \defgroup IfxLld_Evadc_Std_IO IO Pin Configuration Functions
 * \ingroup IfxLld_Evadc_Std
 * \defgroup IfxLld_Evadc_Std_Frequency Frequency Calculation
 * \ingroup IfxLld_Evadc_Std
 * \defgroup IfxLld_Evadc_Std_Group Group Functions
 * \ingroup IfxLld_Evadc_Std
 * \defgroup IfxLld_Evadc_Std_Module Module Functions
 * \ingroup IfxLld_Evadc_Std
 * \defgroup IfxLld_Evadc_Std_Channel Channel Functions
 * \ingroup IfxLld_Evadc_Std
 * \defgroup IfxLld_Evadc_Std_Emux Emux Functions
 * \ingroup IfxLld_Evadc_Std
 * \defgroup IfxLld_Evadc_Std_FastCompare Fast Compare functions
 * \ingroup IfxLld_Evadc_Std
 */

#ifndef IFXEVADC_H
#define IFXEVADC_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxEvadc_cfg.h"
#include "_PinMap/IfxEvadc_PinMap.h"
#include "IfxEvadc_bf.h"
#include "Cpu/Std/IfxCpu_Intrinsics.h"
#include "Scu/Std/IfxScuCcu.h"
#include "Scu/Std/IfxScuWdt.h"
#include "IfxCbs_reg.h"

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Evadc_Std_Enum
 * \{ */
/** \brief Defined in MODULE_EVADC.G[x].ARBCFG.B.ANONS and ANONC
 */
typedef enum
{
    IfxEvadc_AnalogConverterMode_off             = 0, /**< \brief Analog Converter off */
    IfxEvadc_AnalogConverterMode_slowStandby     = 1, /**< \brief Slow Standby Mode */
    IfxEvadc_AnalogConverterMode_fastStandby     = 2, /**< \brief Fast Standby Mode */
    IfxEvadc_AnalogConverterMode_normalOperation = 3  /**< \brief Normal operation mode */
} IfxEvadc_AnalogConverterMode;

/** \brief Arbitration round length defined in MODULE_EVADC.G[x].ARBCFG.ARBRND(x=0,1,..,11)
 */
typedef enum
{
    IfxEvadc_ArbitrationRounds_4_slots  = 0,  /**< \brief An arbitration round contains 4 arbitration slots. */
    IfxEvadc_ArbitrationRounds_8_slots  = 1,  /**< \brief An arbitration round contains 8 arbitration slots. */
    IfxEvadc_ArbitrationRounds_16_slots = 2,  /**< \brief An arbitration round contains 16 arbitration slots. */
    IfxEvadc_ArbitrationRounds_20_slots = 3   /**< \brief An arbitration round contains 20 arbitration slots. */
} IfxEvadc_ArbitrationRounds;

/** \brief Boundary Extension defined in MODULE_EVADC.G[x].CHCTR[y].B.BNDSELX(x=0,1,...,11;y=0,1....,16)
 */
typedef enum
{
    IfxEvadc_BoundaryExtension_standard            = 0,   /**< \brief Boundary Standard mode. BNDSELU/BNDSELL as Boundaries */
    IfxEvadc_BoundaryExtension_fastCompareResult1  = 1,   /**< \brief Fast compare mode use as upper boundary  Channel result   1 */
    IfxEvadc_BoundaryExtension_fastCompareResult2  = 2,   /**< \brief Fast compare mode use as upper boundary  Channel result   2 */
    IfxEvadc_BoundaryExtension_fastCompareResult3  = 3,   /**< \brief Fast compare mode use as upper boundary  Channel result   3 */
    IfxEvadc_BoundaryExtension_fastCompareResult4  = 4,   /**< \brief Fast compare mode use as upper boundary  Channel result   4 */
    IfxEvadc_BoundaryExtension_fastCompareResult5  = 5,   /**< \brief Fast compare mode use as upper boundary  Channel result   5 */
    IfxEvadc_BoundaryExtension_fastCompareResult6  = 6,   /**< \brief Fast compare mode use as upper boundary  Channel result   6 */
    IfxEvadc_BoundaryExtension_fastCompareResult7  = 7,   /**< \brief Fast compare mode use as upper boundary  Channel result   7 */
    IfxEvadc_BoundaryExtension_fastCompareResult8  = 8,   /**< \brief Fast compare mode use as upper boundary  Channel result   8 */
    IfxEvadc_BoundaryExtension_fastCompareResult9  = 9,   /**< \brief Fast compare mode use as upper boundary  Channel result   9 */
    IfxEvadc_BoundaryExtension_fastCompareResult10 = 10,  /**< \brief Fast compare mode use as upper boundary  Channel result  10 */
    IfxEvadc_BoundaryExtension_fastCompareResult11 = 11,  /**< \brief Fast compare mode use as upper boundary  Channel result  11 */
    IfxEvadc_BoundaryExtension_fastCompareResult12 = 12,  /**< \brief Fast compare mode use as upper boundary  Channel result  12 */
    IfxEvadc_BoundaryExtension_fastCompareResult13 = 13,  /**< \brief Fast compare mode use as upper boundary  Channel result  13 */
    IfxEvadc_BoundaryExtension_fastCompareResult14 = 14,  /**< \brief Fast compare mode use as upper boundary  Channel result  14 */
    IfxEvadc_BoundaryExtension_fastCompareResult15 = 15   /**< \brief Fast compare mode use as upper boundary  Channel result  15 */
} IfxEvadc_BoundaryExtension;

/** \brief BoundarySel defined in MODULE_EVADC.G[x].CHCTR[y].B.BNDSELL(x=0,1,...,11;y=0,1....,16)
 */
typedef enum
{
    IfxEvadc_BoundarySelection_group0  = 0,  /**< \brief Use group class 0 */
    IfxEvadc_BoundarySelection_group1  = 1,  /**< \brief Use group class 1 */
    IfxEvadc_BoundarySelection_global0 = 2,  /**< \brief Use global class 0 */
    IfxEvadc_BoundarySelection_global1 = 3   /**< \brief Use global class 1 */
} IfxEvadc_BoundarySelection;

/** \brief EVADC Channels
 */
typedef enum
{
    IfxEvadc_ChannelId_none = -1,  /**< \brief None of EVADC channels */
    IfxEvadc_ChannelId_0    = 0,   /**< \brief Channel 0 */
    IfxEvadc_ChannelId_1    = 1,   /**< \brief Channel 1 */
    IfxEvadc_ChannelId_2    = 2,   /**< \brief Channel 2 */
    IfxEvadc_ChannelId_3    = 3,   /**< \brief Channel 3 */
    IfxEvadc_ChannelId_4    = 4,   /**< \brief Channel 4 */
    IfxEvadc_ChannelId_5    = 5,   /**< \brief Channel 5 */
    IfxEvadc_ChannelId_6    = 6,   /**< \brief Channel 6 */
    IfxEvadc_ChannelId_7    = 7,   /**< \brief Channel 7 */
    IfxEvadc_ChannelId_8    = 8,   /**< \brief Channel 8 */
    IfxEvadc_ChannelId_9    = 9,   /**< \brief Channel 9 */
    IfxEvadc_ChannelId_10   = 10,  /**< \brief Channel 10 */
    IfxEvadc_ChannelId_11   = 11,  /**< \brief Channel 11 */
    IfxEvadc_ChannelId_12   = 12,  /**< \brief Channel 12 */
    IfxEvadc_ChannelId_13   = 13,  /**< \brief Channel 13 */
    IfxEvadc_ChannelId_14   = 14,  /**< \brief Channel 14 */
    IfxEvadc_ChannelId_15   = 15   /**< \brief Channel 15 */
} IfxEvadc_ChannelId;

/** \brief ADC channel reference defined in MODULE_EVADC.G[x].CHCTR[y].B.REFSEL(x=0,1,...,11;y=0,1....,16)
 */
typedef enum
{
    IfxEvadc_ChannelReference_standard = 0,  /**< \brief use Varef as reference */
    IfxEvadc_ChannelReference_channel0 = 1   /**< \brief use CH0 as reference */
} IfxEvadc_ChannelReference;

/** \brief Channel Result defined in MODULE_EVADC.G[x].CHCTR[y].B.RESREG(x=0,1,...,11;y=0,1....,16)
 */
typedef enum
{
    IfxEvadc_ChannelResult_0 = 0,      /**< \brief Use Channel result 0  */
    IfxEvadc_ChannelResult_1,          /**< \brief Use Channel result 1  */
    IfxEvadc_ChannelResult_2,          /**< \brief Use Channel result 2  */
    IfxEvadc_ChannelResult_3,          /**< \brief Use Channel result 3  */
    IfxEvadc_ChannelResult_4,          /**< \brief Use Channel result 4  */
    IfxEvadc_ChannelResult_5,          /**< \brief Use Channel result 5  */
    IfxEvadc_ChannelResult_6,          /**< \brief Use Channel result 6  */
    IfxEvadc_ChannelResult_7,          /**< \brief Use Channel result 7  */
    IfxEvadc_ChannelResult_8,          /**< \brief Use Channel result 8  */
    IfxEvadc_ChannelResult_9,          /**< \brief Use Channel result 9  */
    IfxEvadc_ChannelResult_10,         /**< \brief Use Channel result 10  */
    IfxEvadc_ChannelResult_11,         /**< \brief Use Channel result 11  */
    IfxEvadc_ChannelResult_12,         /**< \brief Use Channel result 12  */
    IfxEvadc_ChannelResult_13,         /**< \brief Use Channel result 13  */
    IfxEvadc_ChannelResult_14,         /**< \brief Use Channel result 14  */
    IfxEvadc_ChannelResult_15          /**< \brief Use Channel result 15  */
} IfxEvadc_ChannelResult;

/** \brief External Multiplexer Channel Selection Style as defined in
 * Ifx_EVADC.G[x].EMUXCTR.B.EMXCSS
 */
typedef enum
{
    IfxEvadc_ChannelSelectionStyle_channelNumber = 0,  /**< \brief selects an arbitrary channel */
    IfxEvadc_ChannelSelectionStyle_binary        = 1   /**< \brief Each bit of bitfield EMUXCH selects the
                                                        * associated channel for EMUX control */
} IfxEvadc_ChannelSelectionStyle;

/** \brief Specifies the External Coding scheme(binary/gray)
 * defined in Ifx_EVADC.G[x].EMUXCTR.B.EMXCOD
 */
typedef enum
{
    IfxEvadc_EmuxCodingScheme_binary = 0,  /**< \brief Output the Channel Number in Binary code */
    IfxEvadc_EmuxCodingScheme_gray   = 1   /**< \brief Output the channel number in gray code */
} IfxEvadc_EmuxCodingScheme;

/** \brief Specifies the Emux interface
 */
typedef enum
{
    IfxEvadc_EmuxInterface_0 = 0,  /**< \brief Emux Interface 0 */
    IfxEvadc_EmuxInterface_1 = 1   /**< \brief Emux Interface 1 */
} IfxEvadc_EmuxInterface;

/** \brief External Multiplexer sample time control
 * defined in Ifx_EVADC.G[x].EMUXCTR.B.EMXST
 */
typedef enum
{
    IfxEvadc_EmuxSampleTimeControl_settingChanges = 0,  /**< \brief Use STCE Whenever Setting Changes */
    IfxEvadc_EmuxSampleTimeControl_always         = 1   /**< \brief Use STCE for each conversion of an external channel */
} IfxEvadc_EmuxSampleTimeControl;

/** \brief specifies the External Channel Start select value
 * defined in Ifx_EVADC.G[x].EMUXCTR.B.EMUXSET
 */
typedef enum
{
    IfxEvadc_EmuxSelectValue_0 = 0,      /**< \brief Start Selection Value 0  */
    IfxEvadc_EmuxSelectValue_1,          /**< \brief Start Selection Value 1  */
    IfxEvadc_EmuxSelectValue_2,          /**< \brief Start Selection Value 2  */
    IfxEvadc_EmuxSelectValue_3,          /**< \brief Start Selection Value 3  */
    IfxEvadc_EmuxSelectValue_4,          /**< \brief Start Selection Value 4  */
    IfxEvadc_EmuxSelectValue_5,          /**< \brief Start Selection Value 5  */
    IfxEvadc_EmuxSelectValue_6,          /**< \brief Start Selection Value 6  */
    IfxEvadc_EmuxSelectValue_7           /**< \brief Start Selection Value 7  */
} IfxEvadc_EmuxSelectValue;

/** \brief Specifies External Multiplexer Mode
 * define in Ifx_EVADC.G[x].EMUXCTR.B.EMUXMODE
 */
typedef enum
{
    IfxEvadc_ExternalMultiplexerMode_softwareControl = 0,  /**< \brief Disable The Emux Control */
    IfxEvadc_ExternalMultiplexerMode_steady          = 1,  /**< \brief select steady mode */
    IfxEvadc_ExternalMultiplexerMode_singleStep      = 2,  /**< \brief Select single step mode */
    IfxEvadc_ExternalMultiplexerMode_sequence        = 3   /**< \brief Select Sequence Mode */
} IfxEvadc_ExternalMultiplexerMode;

/** \brief FIFO mode enable
 */
typedef enum
{
    IfxEvadc_FifoMode_seperateResultRegister = 0,  /**< \brief seperate Result Register */
    IfxEvadc_FifoMode_fifoStructure          = 1,  /**< \brief Part of FIFO structure: copy each new valid result */
    IfxEvadc_FifoMode_maximumMode            = 2,  /**< \brief copy new result if bigger */
    IfxEvadc_FifoMode_minimumMode            = 3   /**< \brief copy new result if it is smaller */
} IfxEvadc_FifoMode;

/** \brief gating mode defined in MODULE_EVADC.QMR0.ENGT
 */
typedef enum
{
    IfxEvadc_GatingMode_disabled   = 0,  /**< \brief Gating is disabled, no conversion request are issued */
    IfxEvadc_GatingMode_always     = 1,  /**< \brief Conversion request is issued if at least 1 conversion pending bit is set */
    IfxEvadc_GatingMode_gatingHigh = 2,  /**< \brief Conversion request is issued if at least 1 conversion pending bit is set and the gating signal is high */
    IfxEvadc_GatingMode_gatingLow  = 3   /**< \brief Conversion request is issued if at least 1 conversion pending bit is set and the gating signal is low */
} IfxEvadc_GatingMode;

/** \brief External trigger gating defined in MODULE_EVADC.G[x].QCTRLy.GTSEL(x=0,1,..,11;y=0,1,..,7)
 */
typedef enum
{
    IfxEvadc_GatingSource_0 = 0,      /**< \brief Input signal REQGTx_0  */
    IfxEvadc_GatingSource_1,          /**< \brief Input signal REQGTx_1  */
    IfxEvadc_GatingSource_2,          /**< \brief Input signal REQGTx_2  */
    IfxEvadc_GatingSource_3,          /**< \brief Input signal REQGTx_3  */
    IfxEvadc_GatingSource_4,          /**< \brief Input signal REQGTx_4  */
    IfxEvadc_GatingSource_5,          /**< \brief Input signal REQGTx_5  */
    IfxEvadc_GatingSource_6,          /**< \brief Input signal REQGTx_6  */
    IfxEvadc_GatingSource_7,          /**< \brief Input signal REQGTx_7  */
    IfxEvadc_GatingSource_8,          /**< \brief Input signal REQGTx_8  */
    IfxEvadc_GatingSource_9,          /**< \brief Input signal REQGTx_9  */
    IfxEvadc_GatingSource_10,         /**< \brief Input signal REQGTx_10  */
    IfxEvadc_GatingSource_11,         /**< \brief Input signal REQGTx_11  */
    IfxEvadc_GatingSource_12,         /**< \brief Input signal REQGTx_12  */
    IfxEvadc_GatingSource_13,         /**< \brief Input signal REQGTx_13  */
    IfxEvadc_GatingSource_14,         /**< \brief Input signal REQGTx_14  */
    IfxEvadc_GatingSource_15          /**< \brief Input signal REQGTx_15  */
} IfxEvadc_GatingSource;

/** \brief inputClass defined in MODULE_EVADC.G[x].CHCTR[y].B.ICLSEL(x=0,1,...,11;y=0,1....,16)
 */
typedef enum
{
    IfxEvadc_InputClasses_group0  = 0,  /**< \brief Use group class 0 */
    IfxEvadc_InputClasses_group1  = 1,  /**< \brief Use group class 1 */
    IfxEvadc_InputClasses_global0 = 2,  /**< \brief Use global class 0 */
    IfxEvadc_InputClasses_global1 = 3   /**< \brief Use global class 1 */
} IfxEvadc_InputClasses;

/** \brief ADC channel limit check defined in MODULE_EVADC.G[x].CHCTR[y].B.CHEVMODE(x=0,1,...,11;y=0,1....,16)
 */
typedef enum
{
    IfxEvadc_LimitCheck_noCheck            = 0,  /**< \brief Normal compare mode Event Never Fast Compare mode Event Never */
    IfxEvadc_LimitCheck_eventIfInArea      = 1,  /**< \brief Normal compare mode Event If result is inside the boundary band    Fast Compare mode Event If result switches to high (above comp. value) */
    IfxEvadc_LimitCheck_eventIfOutsideArea = 2,  /**< \brief Normal compare mode Event If result is outside the boundary band   Fast Compare mode Event If result switches to low (below comp. value) */
    IfxEvadc_LimitCheck_always             = 3   /**< \brief Normal compare mode Event Always   Fast Compare mode Event Always */
} IfxEvadc_LimitCheck;

/** \brief Access protection for Group registers defined in MODULE_EVADC.ACCPROT0.U
 */
typedef enum
{
    IfxEvadc_Protection_channelControl0         = 0,   /**< \brief Access control for GxCHCTR0 */
    IfxEvadc_Protection_channelControl1         = 1,   /**< \brief Access control for GxCHCTR1 */
    IfxEvadc_Protection_channelControl2         = 2,   /**< \brief Access control for GxCHCTR2 */
    IfxEvadc_Protection_channelControl3         = 3,   /**< \brief Access control for GxCHCTR3 */
    IfxEvadc_Protection_channelControl4         = 4,   /**< \brief Access control for GxCHCTR4 */
    IfxEvadc_Protection_channelControl5         = 5,   /**< \brief Access control for GxCHCTR5 */
    IfxEvadc_Protection_channelControl6         = 6,   /**< \brief Access control for GxCHCTR6 */
    IfxEvadc_Protection_channelControl7         = 7,   /**< \brief Access control for GxCHCTR7 */
    IfxEvadc_Protection_channelControl8         = 8,   /**< \brief Access control for GxCHCTR8 */
    IfxEvadc_Protection_channelControl9         = 9,   /**< \brief Access control for GxCHCTR9 */
    IfxEvadc_Protection_channelControl10        = 10,  /**< \brief Access control for GxCHCTR10 */
    IfxEvadc_Protection_channelControl11        = 11,  /**< \brief Access control for GxCHCTR11 */
    IfxEvadc_Protection_channelControl12        = 12,  /**< \brief Access control for GxCHCTR12 */
    IfxEvadc_Protection_channelControl13        = 13,  /**< \brief Access control for GxCHCTR13 */
    IfxEvadc_Protection_channelControl14        = 14,  /**< \brief Access control for GxCHCTR14 */
    IfxEvadc_Protection_initGroup0              = 16,  /**< \brief Access control for GxARBCFG, GxARBPR, GxCHASS, GxRRASS, GxICLASS0/1, GxSYNCTR */
    IfxEvadc_Protection_initGroup1              = 17,  /**< \brief Access control for GxARBCFG, GxARBPR, GxCHASS, GxRRASS, GxICLASS0/1, GxSYNCTR */
    IfxEvadc_Protection_initGroup2              = 18,  /**< \brief Access control for GxARBCFG, GxARBPR, GxCHASS, GxRRASS, GxICLASS0/1, GxSYNCTR */
    IfxEvadc_Protection_initGroup3              = 19,  /**< \brief Access control for GxARBCFG, GxARBPR, GxCHASS, GxRRASS, GxICLASS0/1, GxSYNCTR */
    IfxEvadc_Protection_initGroup4              = 20,  /**< \brief Access control for GxARBCFG, GxARBPR, GxCHASS, GxRRASS, GxICLASS0/1, GxSYNCTR */
    IfxEvadc_Protection_initGroup5              = 21,  /**< \brief Access control for GxARBCFG, GxARBPR, GxCHASS, GxRRASS, GxICLASS0/1, GxSYNCTR */
    IfxEvadc_Protection_initGroup6              = 22,  /**< \brief Access control for GxARBCFG, GxARBPR, GxCHASS, GxRRASS, GxICLASS0/1, GxSYNCTR */
    IfxEvadc_Protection_initGroup7              = 23,  /**< \brief Access control for GxARBCFG, GxARBPR, GxCHASS, GxRRASS, GxICLASS0/1, GxSYNCTR */
    IfxEvadc_Protection_initGroup8              = 24,  /**< \brief Access control for GxARBCFG, GxARBPR, GxCHASS, GxRRASS, GxICLASS0/1, GxSYNCTR */
    IfxEvadc_Protection_initGroup9              = 25,  /**< \brief Access control for GxARBCFG, GxARBPR, GxCHASS, GxRRASS, GxICLASS0/1, GxSYNCTR */
    IfxEvadc_Protection_initGroup10             = 26,  /**< \brief Access control for GxARBCFG, GxARBPR, GxCHASS, GxRRASS, GxICLASS0/1, GxSYNCTR */
    IfxEvadc_Protection_initGroup11             = 27,  /**< \brief Access control for GxARBCFG, GxARBPR, GxCHASS, GxRRASS, GxICLASS0/1, GxSYNCTR */
    IfxEvadc_Protection_initGroup12             = 28,  /**< \brief Access control for GxARBCFG, GxARBPR, GxCHASS, GxRRASS, GxICLASS0/1, GxSYNCTR */
    IfxEvadc_Protection_initGroup13             = 29,  /**< \brief Access control for GxARBCFG, GxARBPR, GxCHASS, GxRRASS, GxICLASS0/1, GxSYNCTR */
    IfxEvadc_Protection_initGroup14             = 30,  /**< \brief Access control for GxARBCFG, GxARBPR, GxCHASS, GxRRASS, GxICLASS0/1, GxSYNCTR */
    IfxEvadc_Protection_serviceGroup0           = 32,  /**< \brief Access control for GxSEFLAG, GxSEVNP, GxCEFLAG, GxCEVNP0/1/2, GxREFLAG, GxREVNP0/1, GxSRACT */
    IfxEvadc_Protection_serviceGroup1           = 33,  /**< \brief Access control for GxSEFLAG, GxSEVNP, GxCEFLAG, GxCEVNP0/1/2, GxREFLAG, GxREVNP0/1, GxSRACT */
    IfxEvadc_Protection_serviceGroup2           = 34,  /**< \brief Access control for GxSEFLAG, GxSEVNP, GxCEFLAG, GxCEVNP0/1/2, GxREFLAG, GxREVNP0/1, GxSRACT */
    IfxEvadc_Protection_serviceGroup3           = 35,  /**< \brief Access control for GxSEFLAG, GxSEVNP, GxCEFLAG, GxCEVNP0/1/2, GxREFLAG, GxREVNP0/1, GxSRACT */
    IfxEvadc_Protection_serviceGroup4           = 36,  /**< \brief Access control for GxSEFLAG, GxSEVNP, GxCEFLAG, GxCEVNP0/1/2, GxREFLAG, GxREVNP0/1, GxSRACT */
    IfxEvadc_Protection_serviceGroup5           = 37,  /**< \brief Access control for GxSEFLAG, GxSEVNP, GxCEFLAG, GxCEVNP0/1/2, GxREFLAG, GxREVNP0/1, GxSRACT */
    IfxEvadc_Protection_serviceGroup6           = 38,  /**< \brief Access control for GxSEFLAG, GxSEVNP, GxCEFLAG, GxCEVNP0/1/2, GxREFLAG, GxREVNP0/1, GxSRACT */
    IfxEvadc_Protection_serviceGroup7           = 39,  /**< \brief Access control for GxSEFLAG, GxSEVNP, GxCEFLAG, GxCEVNP0/1/2, GxREFLAG, GxREVNP0/1, GxSRACT */
    IfxEvadc_Protection_serviceGroup8           = 40,  /**< \brief Access control for GxSEFLAG, GxSEVNP, GxCEFLAG, GxCEVNP0/1/2, GxREFLAG, GxREVNP0/1, GxSRACT */
    IfxEvadc_Protection_serviceGroup9           = 41,  /**< \brief Access control for GxSEFLAG, GxSEVNP, GxCEFLAG, GxCEVNP0/1/2, GxREFLAG, GxREVNP0/1, GxSRACT */
    IfxEvadc_Protection_serviceGroup10          = 42,  /**< \brief Access control for GxSEFLAG, GxSEVNP, GxCEFLAG, GxCEVNP0/1/2, GxREFLAG, GxREVNP0/1, GxSRACT */
    IfxEvadc_Protection_serviceGroup11          = 43,  /**< \brief Access control for GxSEFLAG, GxSEVNP, GxCEFLAG, GxCEVNP0/1/2, GxREFLAG, GxREVNP0/1, GxSRACT */
    IfxEvadc_Protection_serviceGroup12          = 44,  /**< \brief Access control for GxSEFLAG, GxSEVNP, GxCEFLAG, GxCEVNP0/1/2, GxREFLAG, GxREVNP0/1, GxSRACT */
    IfxEvadc_Protection_serviceGroup13          = 45,  /**< \brief Access control for GxSEFLAG, GxSEVNP, GxCEFLAG, GxCEVNP0/1/2, GxREFLAG, GxREVNP0/1, GxSRACT */
    IfxEvadc_Protection_serviceGroup14          = 46,  /**< \brief Access control for GxSEFLAG, GxSEVNP, GxCEFLAG, GxCEVNP0/1/2, GxREFLAG, GxREVNP0/1, GxSRACT */
    IfxEvadc_Protection_resultRegisterGroup0    = 48,  /**< \brief Access control for GxRCRx(x=0,1,..,15), GxBOUND, GxRESx(x=0 .. 15) */
    IfxEvadc_Protection_resultRegisterGroup1    = 49,  /**< \brief Access control for GxRCRx(x=0,1,..,15), GxBOUND, GxRESx(x=0 .. 15) */
    IfxEvadc_Protection_resultRegisterGroup2    = 50,  /**< \brief Access control for GxRCRx(x=0,1,..,15), GxBOUND, GxRESx(x=0 .. 15) */
    IfxEvadc_Protection_resultRegisterGroup3    = 51,  /**< \brief Access control for GxRCRx(x=0,1,..,15), GxBOUND, GxRESx(x=0 .. 15) */
    IfxEvadc_Protection_resultRegisterGroup4    = 52,  /**< \brief Access control for GxRCRx(x=0,1,..,15), GxBOUND, GxRESx(x=0 .. 15) */
    IfxEvadc_Protection_resultRegisterGroup5    = 53,  /**< \brief Access control for GxRCRx(x=0,1,..,15), GxBOUND, GxRESx(x=0 .. 15) */
    IfxEvadc_Protection_resultRegisterGroup6    = 54,  /**< \brief Access control for GxRCRx(x=0,1,..,15), GxBOUND, GxRESx(x=0 .. 15) */
    IfxEvadc_Protection_resultRegisterGroup7    = 55,  /**< \brief Access control for GxRCRx(x=0,1,..,15), GxBOUND, GxRESx(x=0 .. 15) */
    IfxEvadc_Protection_resultRegisterGroup8    = 56,  /**< \brief Access control for GxRCRx(x=0,1,..,15), GxBOUND, GxRESx(x=0 .. 15) */
    IfxEvadc_Protection_resultRegisterGroup9    = 57,  /**< \brief Access control for GxRCRx(x=0,1,..,15), GxBOUND, GxRESx(x=0 .. 15) */
    IfxEvadc_Protection_resultRegisterGroup10   = 58,  /**< \brief Access control for GxRCRx(x=0,1,..,15), GxBOUND, GxRESx(x=0 .. 15) */
    IfxEvadc_Protection_resultRegisterGroup11   = 59,  /**< \brief Access control for GxRCRx(x=0,1,..,15), GxBOUND, GxRESx(x=0 .. 15) */
    IfxEvadc_Protection_resultRegisterGroup12   = 60,  /**< \brief Access control for GxRCRx(x=0,1,..,15), GxBOUND, GxRESx(x=0 .. 15) */
    IfxEvadc_Protection_resultRegisterGroup13   = 61,  /**< \brief Access control for GxRCRx(x=0,1,..,15), GxBOUND, GxRESx(x=0 .. 15) */
    IfxEvadc_Protection_resultRegisterGroup14   = 62,  /**< \brief Access control for GxRCRx(x=0,1,..,15), GxBOUND, GxRESx(x=0 .. 15) */
    IfxEvadc_Protection_initFastCompareChannel0 = 64,  /**< \brief Access control for GyFCBFL, GyFCHYST, GyFCCTR, GyFCM,
                                                        * GyFCRAMP */
    IfxEvadc_Protection_initFastCompareChannel1 = 65,  /**< \brief Access control for GyFCBFL, GyFCHYST, GyFCCTR, GyFCM,
                                                        * GyFCRAMP */
    IfxEvadc_Protection_initFastCompareChannel2 = 66,  /**< \brief Access control for GyFCBFL, GyFCHYST, GyFCCTR, GyFCM,
                                                        * GyFCRAMP */
    IfxEvadc_Protection_initFastCompareChannel3 = 67,  /**< \brief Access control for GyFCBFL, GyFCHYST, GyFCCTR, GyFCM,
                                                        * GyFCRAMP */
    IfxEvadc_Protection_initFastCompareChannel4 = 68,  /**< \brief Access control for GyFCBFL, GyFCHYST, GyFCCTR, GyFCM,
                                                        * GyFCRAMP */
    IfxEvadc_Protection_initFastCompareChannel5 = 69,  /**< \brief Access control for GyFCBFL, GyFCHYST, GyFCCTR, GyFCM,
                                                        * GyFCRAMP */
    IfxEvadc_Protection_initFastCompareChannel6 = 70,  /**< \brief Access control for GyFCBFL, GyFCHYST, GyFCCTR, GyFCM,
                                                        * GyFCRAMP */
    IfxEvadc_Protection_initFastCompareChannel7 = 71,  /**< \brief Access control for GyFCBFL, GyFCHYST, GyFCCTR, GyFCM,
                                                        * GyFCRAMP */
    IfxEvadc_Protection_globalConfig            = 80,  /**< \brief Access control for GLOBCFG */
    IfxEvadc_Protection_externalMultiplexer     = 81,  /**< \brief Access control for EMUXSEL, GxEMUXCTR */
    IfxEvadc_Protection_testFunction            = 82   /**< \brief Access control for GLOBTF */
} IfxEvadc_Protection;

/** \brief Arbitration priority, Group x,defined in MODULE_EVADC.G[x].ARBPR.PRIOy(x=0,1,...,11;y=0,1,2)
 */
typedef enum
{
    IfxEvadc_RequestSlotPriority_lowest  = 0, /**< \brief Lowest priority */
    IfxEvadc_RequestSlotPriority_low     = 1, /**< \brief Lowpriority */
    IfxEvadc_RequestSlotPriority_high    = 2, /**< \brief High priority */
    IfxEvadc_RequestSlotPriority_highest = 3  /**< \brief Highest priority */
} IfxEvadc_RequestSlotPriority;

/** \brief Request source start mode defined in MODULE_EVADC.G[x].ARBPR.CSMy(x=0,1,...,11;y=0,1,2)
 */
typedef enum
{
    IfxEvadc_RequestSlotStartMode_waitForStart       = 0, /**< \brief Wait for start */
    IfxEvadc_RequestSlotStartMode_cancelInjectRepeat = 1  /**< \brief Cancel-Inject-Repeat */
} IfxEvadc_RequestSlotStartMode;

/** \brief Request sources
 */
typedef enum
{
    IfxEvadc_RequestSource_queue0 = 0,  /**< \brief 8 stage Queue0 request */
    IfxEvadc_RequestSource_queue1 = 1,  /**< \brief 8 stage Queue1 request */
    IfxEvadc_RequestSource_queue2 = 2   /**< \brief 8 stage Queue2 request */
} IfxEvadc_RequestSource;

/** \brief Enable/disable the sensitivity of the module to sleep signal\n
 * Definition in Ifx_EVADC.CLC.B.EDIS
 */
typedef enum
{
    IfxEvadc_SleepMode_enable  = 0, /**< \brief enables sleep mode */
    IfxEvadc_SleepMode_disable = 1  /**< \brief disables sleep mode */
} IfxEvadc_SleepMode;

/** \brief Service Node defined in MODULE_EVADC.G[x].SRACT.U(x= 0,1,..,11)
 */
typedef enum
{
    IfxEvadc_SrcNr_group0  = 0,  /**< \brief service request line 0 of group */
    IfxEvadc_SrcNr_group1  = 1,  /**< \brief service request line 1 of group */
    IfxEvadc_SrcNr_group2  = 2,  /**< \brief service request line 2 of group */
    IfxEvadc_SrcNr_group3  = 3,  /**< \brief service request line 3 of group */
    IfxEvadc_SrcNr_shared0 = 4,  /**< \brief Select shared service request line 0 */
    IfxEvadc_SrcNr_shared1 = 5,  /**< \brief Select shared service request line 1 */
    IfxEvadc_SrcNr_shared2 = 6,  /**< \brief Select shared service request line 2 */
    IfxEvadc_SrcNr_shared3 = 7   /**< \brief Select shared service request line 3 */
} IfxEvadc_SrcNr;

/** \brief API return values defined in
 * MODULE_EVADC.G[x].QSR0.U,MODULE_EVADC.G[x].QSR1.U,MODULE_EVADC.G[x].QSR2.U(x=0,1,...,11)
 */
typedef enum
{
    IfxEvadc_Status_noError              = 0, /**< \brief No error during api execution */
    IfxEvadc_Status_notInitialised       = 1, /**< \brief Appropriate initialisation not done */
    IfxEvadc_Status_invalidGroup         = 2, /**< \brief Invalid group number */
    IfxEvadc_Status_invalidChannel       = 3, /**< \brief Invalid channel number */
    IfxEvadc_Status_queueFull            = 4, /**< \brief Queue is full */
    IfxEvadc_Status_noAccess             = 5, /**< \brief Access to the group/channel is disabled */
    IfxEvadc_Status_channelsStillPending = 6  /**< \brief Conversion for some of the channels are still pending */
} IfxEvadc_Status;

/** \brief OCDS Suspend Control (OCDS.SUS)
 */
typedef enum
{
    IfxEvadc_SuspendMode_none = 0,  /**< \brief No suspend */
    IfxEvadc_SuspendMode_hard = 1,  /**< \brief Hard Suspend */
    IfxEvadc_SuspendMode_soft = 2   /**< \brief Soft Suspend */
} IfxEvadc_SuspendMode;

/** \brief trigger definition defined in MODULE_EVADC.G[x].QCTRL0.XTMODE(x=0,1,..,11)
 */
typedef enum
{
    IfxEvadc_TriggerMode_noExternalTrigger = 0,  /**< \brief No external trigger */
    IfxEvadc_TriggerMode_uponFallingEdge   = 1,  /**< \brief Trigger event upon a falling edge */
    IfxEvadc_TriggerMode_uponRisingEdge    = 2,  /**< \brief Trigger event upon a rising edge */
    IfxEvadc_TriggerMode_uponAnyEdge       = 3   /**< \brief Trigger event upon any edge */
} IfxEvadc_TriggerMode;

/** \brief Trigger request source defined in MODULE_EVADC.G[x].QCTRLy.XTSEL(x=0,1,..,11;y=0,1,..,7)
 */
typedef enum
{
    IfxEvadc_TriggerSource_0 = 0,      /**< \brief Input signal REQTRx_0  */
    IfxEvadc_TriggerSource_1,          /**< \brief Input signal REQTRx_1  */
    IfxEvadc_TriggerSource_2,          /**< \brief Input signal REQTRx_2  */
    IfxEvadc_TriggerSource_3,          /**< \brief Input signal REQTRx_3  */
    IfxEvadc_TriggerSource_4,          /**< \brief Input signal REQTRx_4  */
    IfxEvadc_TriggerSource_5,          /**< \brief Input signal REQTRx_5  */
    IfxEvadc_TriggerSource_6,          /**< \brief Input signal REQTRx_6  */
    IfxEvadc_TriggerSource_7,          /**< \brief Input signal REQTRx_7  */
    IfxEvadc_TriggerSource_8,          /**< \brief Input signal REQTRx_8  */
    IfxEvadc_TriggerSource_9,          /**< \brief Input signal REQTRx_9  */
    IfxEvadc_TriggerSource_10,         /**< \brief Input signal REQTRx_10  */
    IfxEvadc_TriggerSource_11,         /**< \brief Input signal REQTRx_11  */
    IfxEvadc_TriggerSource_12,         /**< \brief Input signal REQTRx_12  */
    IfxEvadc_TriggerSource_13,         /**< \brief Input signal REQTRx_13  */
    IfxEvadc_TriggerSource_14,         /**< \brief Input signal REQTRx_14  */
    IfxEvadc_TriggerSource_15          /**< \brief Input signal REQTRx_15  */
} IfxEvadc_TriggerSource;

/** \} */

/** \addtogroup IfxLld_Evadc_Std_FastCompare
 * \{ */
/** \brief Selects the behaviour of BoundaryFlag in FCBFL.B.BFA
 */
typedef enum
{
    IfxEvadc_BoundaryFlagActivationMode_0 = 0,  /**< \brief Set boundary flag BFL if result FCR = 1 (input above the defined
                                                 * band or compare value), clear if FCR = 0 (input below) */
    IfxEvadc_BoundaryFlagActivationMode_1 = 1   /**< \brief Set boundary flag BFL if result FCR = 0 (input below the defined
                                                 * band or compare value), clear if FCR = 1 (input above) */
} IfxEvadc_BoundaryFlagActivationMode;

/** \brief Controls in in FCBFL.B.BFI options for whether to use Boundary Flag(FCM.B.BFL) directly or in a inverted format.
 */
typedef enum
{
    IfxEvadc_BoundaryFlagInversionControl_direct = 0,  /**< \brief Use BFL directly */
    IfxEvadc_BoundaryFlagInversionControl_invert = 1   /**< \brief Use inverted BFL */
} IfxEvadc_BoundaryFlagInversionControl;

/** \brief Options for FCBFL.B.BFLNP to select Boundary Flag Node Pointer
 */
typedef enum
{
    IfxEvadc_BoundaryFlagNodePointer_commonBoundaryFlagOutput0 = 0,  /**< \brief Select common boundary flag output 0 */
    IfxEvadc_BoundaryFlagNodePointer_commonBoundaryFlagOutput1 = 1,  /**< \brief Select common boundary flag output 1 */
    IfxEvadc_BoundaryFlagNodePointer_commonBoundaryFlagOutput2 = 2,  /**< \brief Select common boundary flag output 2 */
    IfxEvadc_BoundaryFlagNodePointer_commonBoundaryFlagOutput3 = 3,  /**< \brief Select common boundary flag output 3 */
    IfxEvadc_BoundaryFlagNodePointer_sharedServiceRequestLine0 = 4,  /**< \brief Select shared service request line 0 */
    IfxEvadc_BoundaryFlagNodePointer_sharedServiceRequestLine1 = 5,  /**< \brief Select shared service request line 1 */
    IfxEvadc_BoundaryFlagNodePointer_sharedServiceRequestLine2 = 6,  /**< \brief Select shared service request line 2 */
    IfxEvadc_BoundaryFlagNodePointer_sharedServiceRequestLine3 = 7,  /**< \brief Select shared service request line 3 */
    IfxEvadc_BoundaryFlagNodePointer_disabled                  = 15  /**< \brief Disabled, no common output signal */
} IfxEvadc_BoundaryFlagNodePointer;

/** \brief Options for FCBFL.B.BFS to modify the Boundary Flag(FCM.B.BFL)
 */
typedef enum
{
    IfxEvadc_BoundaryFlagSwControl_noAction = 0,  /**< \brief No Action */
    IfxEvadc_BoundaryFlagSwControl_clear    = 1,  /**< \brief Clear BFL */
    IfxEvadc_BoundaryFlagSwControl_set      = 2,  /**< \brief Set BFL */
    IfxEvadc_BoundaryFlagSwControl_toggle   = 3   /**< \brief Toggle BFL */
} IfxEvadc_BoundaryFlagSwControl;

/** \brief Channel Event Mode for configuring generation of events for Fast Compare channels in FCCTRL.B.CHEVMODE
 */
typedef enum
{
    IfxEvadc_ChannelEventMode_never                    = 0, /**< \brief Never generate a service request */
    IfxEvadc_ChannelEventMode_aboveCompareValue        = 1, /**< \brief Generate a service request in case the result is above compare value */
    IfxEvadc_ChannelEventMode_belowCompareValue        = 2, /**< \brief Generate a service request in case the result is below compare value */
    IfxEvadc_ChannelEventMode_aboveOrBelowCompareValue = 3  /**< \brief Generate a service request in case the result switches to either level(above or below the compare value) */
} IfxEvadc_ChannelEventMode;

/** \brief Defines the frequency of the analog converter clock f_ADCI (base clock for
 * conversion steps), derived from the peripheral clock: f_ADCI = fADC / CP.
 * To be filled in FCCTRL.B.DIVA for Fast Compare channels & ANCFG.B.DIVA for other groups
 */
typedef enum
{
    IfxEvadc_ClockDividerFactor_maxFrequency = 0,  /**< \brief Max. frequency */
    IfxEvadc_ClockDividerFactor_2            = 1,  /**< \brief Frequency Divided by 2  */
    IfxEvadc_ClockDividerFactor_3,                 /**< \brief Frequency Divided by 3  */
    IfxEvadc_ClockDividerFactor_4,                 /**< \brief Frequency Divided by 4  */
    IfxEvadc_ClockDividerFactor_5,                 /**< \brief Frequency Divided by 5  */
    IfxEvadc_ClockDividerFactor_6,                 /**< \brief Frequency Divided by 6  */
    IfxEvadc_ClockDividerFactor_7,                 /**< \brief Frequency Divided by 7  */
    IfxEvadc_ClockDividerFactor_8,                 /**< \brief Frequency Divided by 8  */
    IfxEvadc_ClockDividerFactor_9,                 /**< \brief Frequency Divided by 9  */
    IfxEvadc_ClockDividerFactor_10,                /**< \brief Frequency Divided by 10  */
    IfxEvadc_ClockDividerFactor_11,                /**< \brief Frequency Divided by 11  */
    IfxEvadc_ClockDividerFactor_12,                /**< \brief Frequency Divided by 12  */
    IfxEvadc_ClockDividerFactor_13,                /**< \brief Frequency Divided by 13  */
    IfxEvadc_ClockDividerFactor_14,                /**< \brief Frequency Divided by 14  */
    IfxEvadc_ClockDividerFactor_15,                /**< \brief Frequency Divided by 15  */
    IfxEvadc_ClockDividerFactor_16,                /**< \brief Frequency Divided by 16  */
    IfxEvadc_ClockDividerFactor_17,                /**< \brief Frequency Divided by 17  */
    IfxEvadc_ClockDividerFactor_18,                /**< \brief Frequency Divided by 18  */
    IfxEvadc_ClockDividerFactor_19,                /**< \brief Frequency Divided by 19  */
    IfxEvadc_ClockDividerFactor_20,                /**< \brief Frequency Divided by 20  */
    IfxEvadc_ClockDividerFactor_21,                /**< \brief Frequency Divided by 21  */
    IfxEvadc_ClockDividerFactor_22,                /**< \brief Frequency Divided by 22  */
    IfxEvadc_ClockDividerFactor_23,                /**< \brief Frequency Divided by 23  */
    IfxEvadc_ClockDividerFactor_24,                /**< \brief Frequency Divided by 24  */
    IfxEvadc_ClockDividerFactor_25,                /**< \brief Frequency Divided by 25  */
    IfxEvadc_ClockDividerFactor_26,                /**< \brief Frequency Divided by 26  */
    IfxEvadc_ClockDividerFactor_27,                /**< \brief Frequency Divided by 27  */
    IfxEvadc_ClockDividerFactor_28,                /**< \brief Frequency Divided by 28  */
    IfxEvadc_ClockDividerFactor_29,                /**< \brief Frequency Divided by 29  */
    IfxEvadc_ClockDividerFactor_30,                /**< \brief Frequency Divided by 30  */
    IfxEvadc_ClockDividerFactor_31,                /**< \brief Frequency Divided by 31  */
    IfxEvadc_ClockDividerFactor_32                 /**< \brief Frequency Divided by 32  */
} IfxEvadc_ClockDividerFactor;

/** \brief External Trigger Polarity to be set in FCCTRL.B.XTPOL
 */
typedef enum
{
    IfxEvadc_ExternalTriggerPolarity_direct   = 0, /**< \brief Use selected input signal directly */
    IfxEvadc_ExternalTriggerPolarity_inverted = 1  /**< \brief Invert selected input signal */
} IfxEvadc_ExternalTriggerPolarity;

typedef enum
{
    IfxEvadc_FastCompareAnalogClockSynchronizationDelay_0 = 0,  /**< \brief No delay */
    IfxEvadc_FastCompareAnalogClockSynchronizationDelay_1 = 1,  /**< \brief 1 clock cycle delay */
    IfxEvadc_FastCompareAnalogClockSynchronizationDelay_2 = 2,  /**< \brief 2 clock cycles delay */
    IfxEvadc_FastCompareAnalogClockSynchronizationDelay_3 = 3   /**< \brief 3 clock cycles delay */
} IfxEvadc_FastCompareAnalogClockSynchronizationDelay;

/** \brief Settings for Analog Coverter Controller to be done in FCM.B.ANON
 */
typedef enum
{
    IfxEvadc_FastCompareAnalogConverterControl_off    = 0, /**< \brief Analog converter off */
    IfxEvadc_FastCompareAnalogConverterControl_normal = 1  /**< \brief Normal operation */
} IfxEvadc_FastCompareAnalogConverterControl;

/** \brief Defines the source of the value(s) in bitfield FCM.B.FCREF
 *
 * Note: Software can only write to bitfield FCM.B.FCREF, while AUE = 00B.
 */
typedef enum
{
    IfxEvadc_FastCompareAutomaticUpdate_sw             = 0,  /**< \brief No automatic update.Value(s) written by software. */
    IfxEvadc_FastCompareAutomaticUpdate_alternateValue = 1,  /**< \brief While gate is active (high), value is copied from bitfield FCM.B.FCRCOMPA and while gate is inactive (low), value is copied from bitfield FCM.B.FCRCOMPB */
    IfxEvadc_FastCompareAutomaticUpdate_rampCounter    = 2,  /**< \brief Value(s) copied from ramp counter on ramp start or counter
                                                              * update. */
    IfxEvadc_FastCompareAutomaticUpdate_analogSource   = 3   /**< \brief Value(s) written by the associated converter */
} IfxEvadc_FastCompareAutomaticUpdate;

/** \brief Defines the basic run conditions of the fast compare channel in FCM.B.RUNCOMP
 */
typedef enum
{
    IfxEvadc_FastCompareRunControl_stop      = 0, /**< \brief Stop, no operation */
    IfxEvadc_FastCompareRunControl_alwaysRun = 1  /**< \brief Always run */
} IfxEvadc_FastCompareRunControl;

/** \brief Criteria/mode settings for service request generation in FCM.B.SRG
 */
typedef enum
{
    IfxEvadc_FastCompareServiceRequestGeneration_off       = 0, /**< \brief No service requests are generated */
    IfxEvadc_FastCompareServiceRequestGeneration_rampEnd   = 1, /**< \brief Issue service request when the ramp counter stops */
    IfxEvadc_FastCompareServiceRequestGeneration_newValue  = 2, /**< \brief Issue service request when a value is written to FCREF */
    IfxEvadc_FastCompareServiceRequestGeneration_newResult = 3  /**< \brief Issue service request when a new result available */
} IfxEvadc_FastCompareServiceRequestGeneration;

/** \brief Gate Operating Mode to be filled in FCCTRL.B.GTMODE
 */
typedef enum
{
    IfxEvadc_GateOperatingMode_noGateFunction     = 0,  /**< \brief No gate function */
    IfxEvadc_GateOperatingMode_alternateValueMode = 1,  /**< \brief Alternate value mode */
    IfxEvadc_GateOperatingMode_lockBoundaryFlag   = 2   /**< \brief Lock boundary flag */
} IfxEvadc_GateOperatingMode;

/** \brief Ramp direction setting in FCM.B.FCRDIR
 */
typedef enum
{
    IfxEvadc_RampDirection_down = 0,  /**< \brief Decrement ramp counter and stop when counter <= FCRCOMPB */
    IfxEvadc_RampDirection_up   = 1   /**< \brief Increment ramp counter and stop when counter >= FCRCOMPB */
} IfxEvadc_RampDirection;

/** \brief Defines the run conditions for the ramp generation in FCM.B.RUNRAMP
 */
typedef enum
{
    IfxEvadc_RampRunControl_stop = 0,  /**< \brief Stop, no operation */
    IfxEvadc_RampRunControl_1    = 1,  /**< \brief Start immediately when GxFCRAMP0/1 is written */
    IfxEvadc_RampRunControl_2    = 2,  /**< \brief Start upon the selected trigger event of signal REQTRx */
    IfxEvadc_RampRunControl_3    = 3   /**< \brief Start immediately when GxFCRAMP0/1 is written and
                                        * stop upon the selected trigger event of signal REQTRx */
} IfxEvadc_RampRunControl;

/** \brief Sample timing sync settings for FCM.B.SSE
 */
typedef enum
{
    IfxEvadc_SampleSynchronization_off                     = 0, /**< \brief No synchronization */
    IfxEvadc_SampleSynchronization_synchronizeSampleTiming = 1  /**< \brief Sample timing is synchronized.This is recommended for operation of several ADCs. */
} IfxEvadc_SampleSynchronization;

/** \brief Trigger operating mode in Fast Compare channels, to be entered in FCCTRL.B.XTMODE
 */
typedef enum
{
    IfxEvadc_TriggerOperatingMode_noExternalTrigger = 0,  /**< \brief No external trigger */
    IfxEvadc_TriggerOperatingMode_fallingEdge       = 1,  /**< \brief Trigger event upon a falling edge */
    IfxEvadc_TriggerOperatingMode_risingEdge        = 2,  /**< \brief Trigger event upon a rising edge */
    IfxEvadc_TriggerOperatingMode_anyEdge           = 3   /**< \brief Trigger event upon any edge */
} IfxEvadc_TriggerOperatingMode;

/** \} */

/** \brief Defines the way the analog clock is generated.
 */
typedef enum
{
    IfxEvadc_AnalogClockGenerationMode_synchronized   = 0, /**< \brief Synchronized mode: Initial clock pulse is defined by the phase synchronizer */
    IfxEvadc_AnalogClockGenerationMode_unsynchronized = 1  /**< \brief Unsynchronized mode: The analog clock is generated independently. */
} IfxEvadc_AnalogClockGenerationMode;

typedef enum
{
    IfxEvadc_AnalogClockSynchronizationDelay_0 = 0,  /**< \brief No Delay */
    IfxEvadc_AnalogClockSynchronizationDelay_1 = 1,  /**< \brief 1 clock cycle delay */
    IfxEvadc_AnalogClockSynchronizationDelay_2 = 2,  /**< \brief 2 clock cycles delay */
    IfxEvadc_AnalogClockSynchronizationDelay_3 = 3,  /**< \brief 3 clock cycles delay */
    IfxEvadc_AnalogClockSynchronizationDelay_4 = 4,  /**< \brief 4 clock cycles delay */
    IfxEvadc_AnalogClockSynchronizationDelay_5 = 5,  /**< \brief 5 clock cycles delay */
    IfxEvadc_AnalogClockSynchronizationDelay_6 = 6,  /**< \brief 6 clock cycles delay */
    IfxEvadc_AnalogClockSynchronizationDelay_7 = 7   /**< \brief 7 clock cycles delay */
} IfxEvadc_AnalogClockSynchronizationDelay;

/** \brief Analog Input Precharge Control for Standard Conversions
 */
typedef enum
{
    IfxEvadc_AnalogInputPrechargeControl_noPrecharge = 0,  /**< \brief No Precharge */
    IfxEvadc_AnalogInputPrechargeControl_8Cycles     = 1,  /**< \brief Precharge for 8 clock cycles */
    IfxEvadc_AnalogInputPrechargeControl_16Cycles    = 2,  /**< \brief Precharge for 16 clock cycles */
    IfxEvadc_AnalogInputPrechargeControl_32cycles    = 3   /**< \brief Precharge for 32 clock cycles */
} IfxEvadc_AnalogInputPrechargeControl;

typedef enum
{
    IfxEvadc_ArbitrationMode_0 = 0,
    IfxEvadc_ArbitrationMode_1 = 1
} IfxEvadc_ArbitrationMode;

typedef enum
{
    IfxEvadc_CalibrationSampleTimeControl_2 = 0,  /**< \brief 2*t_ADCI */
    IfxEvadc_CalibrationSampleTimeControl_4 = 1,  /**< \brief 4*t_ADCI */
    IfxEvadc_CalibrationSampleTimeControl_6 = 2,  /**< \brief 6*t_ADCI */
    IfxEvadc_CalibrationSampleTimeControl_8 = 3   /**< \brief 8*t_ADCI */
} IfxEvadc_CalibrationSampleTimeControl;

/** \brief Conversion Mode for standard Conversion
 *  channel precision defined in MODULE_EVADC.G[x].CHCTR[y].B.ICLASS[y].B.CMS(x=0,1,...,11;y=0,1)
 */
typedef enum
{
    IfxEvadc_ChannelNoiseReduction_standardConversion = 0,  /**< \brief Standard Conversions mode */
    IfxEvadc_ChannelNoiseReduction_level1             = 1,  /**< \brief Noise reduction conversion level 1 */
    IfxEvadc_ChannelNoiseReduction_level2             = 2,  /**< \brief Noise reduction conversion level 2 */
    IfxEvadc_ChannelNoiseReduction_level3             = 3   /**< \brief Noise reduction conversion level 3 */
} IfxEvadc_ChannelNoiseReduction;

/** \brief Conversion Mode for EMUX Conversions
 */
typedef enum
{
    IfxEvadc_ChannelNoiseReductionEMUX_standardConversion = 0,  /**< \brief Standard conversion */
    IfxEvadc_ChannelNoiseReductionEMUX_level1             = 1,  /**< \brief Noise reduction conversion level 1, 1 additional conversion step */
    IfxEvadc_ChannelNoiseReductionEMUX_level2             = 2,  /**< \brief Noise reduction conversion level 2, 3 additional conversion steps */
    IfxEvadc_ChannelNoiseReductionEMUX_level3             = 3   /**< \brief Noise reduction conversion level 3, 7 additional conversion steps */
} IfxEvadc_ChannelNoiseReductionEMUX;

/** \brief Data Modification Mode
 */
typedef enum
{
    IfxEvadc_DataModificationMode_standardDataReduction = 0,  /**< \brief Standard Data Reduction */
    IfxEvadc_DataModificationMode_resultFilteringMode   = 1,  /**< \brief Result Filtering Mode */
    IfxEvadc_DataModificationMode_differenceMode        = 2   /**< \brief Difference Mode */
} IfxEvadc_DataModificationMode;

typedef enum
{
    IfxEvadc_DataReductionControlMode_0  = 0,   /**< \brief If DMM=0b00, Data reduction disabled,if DMM=0b01, FIR:a=2,b=1,c=0 */
    IfxEvadc_DataReductionControlMode_1  = 1,   /**< \brief If DMM=0b00, Accumulate 2 result values,if DMM=0b01, FIR:a=1,b=2,c=0 */
    IfxEvadc_DataReductionControlMode_2  = 2,   /**< \brief If DMM=0b00, Accumulate 3 result values,if DMM=0b01, FIR:a=2,b=0,c=1 */
    IfxEvadc_DataReductionControlMode_3  = 3,   /**< \brief If DMM=0b00, Accumulate 4 result values,if DMM=0b01, FIR:a=1,b=1,c=1 */
    IfxEvadc_DataReductionControlMode_4  = 4,   /**< \brief If DMM=0b00, Accumulate 5 result values,if DMM=0b01, FIR:a=1,b=0,c=2 */
    IfxEvadc_DataReductionControlMode_5  = 5,   /**< \brief If DMM=0b00, Accumulate 6 result values,if DMM=0b01, FIR:a=3,b=1,c=0 */
    IfxEvadc_DataReductionControlMode_6  = 6,   /**< \brief If DMM=0b00, Accumulate 7 result values,if DMM=0b01, FIR:a=2,b=2,c=0 */
    IfxEvadc_DataReductionControlMode_7  = 7,   /**< \brief If DMM=0b00, Accumulate 8 result values,if DMM=0b01, FIR:a=1,b=3,c=0 */
    IfxEvadc_DataReductionControlMode_8  = 8,   /**< \brief If DMM=0b00, Accumulate 9 result values,if DMM=0b01, FIR:a=3,b=0,c=1 */
    IfxEvadc_DataReductionControlMode_9  = 9,   /**< \brief If DMM=0b00, Accumulate 10 result values,if DMM=0b01, FIR:a=2,b=1,c=1 */
    IfxEvadc_DataReductionControlMode_10 = 10,  /**< \brief If DMM=0b00, Accumulate 11 result values,if DMM=0b01, FIR:a=1,b=2,c=1 */
    IfxEvadc_DataReductionControlMode_11 = 11,  /**< \brief If DMM=0b00, Accumulate 12 result values,if DMM=0b01, FIR:a=2,b=0,c=2 */
    IfxEvadc_DataReductionControlMode_12 = 12,  /**< \brief If DMM=0b00, Accumulate 13 result values,if DMM=0b01, FIR:a=1,b=1,c=2 */
    IfxEvadc_DataReductionControlMode_13 = 13,  /**< \brief If DMM=0b00, Accumulate 14 result values,if DMM=0b01, FIR:a=1,b=0,c=3 */
    IfxEvadc_DataReductionControlMode_14 = 14,  /**< \brief If DMM=0b00, Accumulate 15 result values,if DMM=0b01, IIR:a=2,b=2 */
    IfxEvadc_DataReductionControlMode_15 = 15   /**< \brief If DMM=0b00, Accumulate 16 result values,if DMM=0b01, IIR:a=3,b=4 */
} IfxEvadc_DataReductionControlMode;

/** \brief Contains options for Idle Precharge levels
 */
typedef enum
{
    IfxEvadc_IdlePrecharge_currentLevel = 0,  /**< \brief The sampling capacitor keeps the current charge */
    IfxEvadc_IdlePrecharge_referenceBy2 = 1   /**< \brief ThSampling capacitor is precharged to approx. half the reference when idle */
} IfxEvadc_IdlePrecharge;

/** \brief Selects the MSB conversion time(in terms of t_ADC)
 */
typedef enum
{
    IfxEvadc_MsbConversionTime_singleClockCycle = 0,  /**< \brief 1 clock cycle for the MSB (standard) */
    IfxEvadc_MsbConversionTime_doubleClockCycle = 1   /**< \brief 2 clock cycle for the MSB */
} IfxEvadc_MsbConversionTime;

/** \brief Reference Precharge Control
 */
typedef enum
{
    IfxEvadc_ReferencePrechargeControl_singleClockPhase  = 0, /**< \brief Precharge the reference input for 1 clock phase */
    IfxEvadc_ReferencePrechargeControl_singleClockPeriod = 1  /**< \brief Precharge the reference input for 1 clock period */
} IfxEvadc_ReferencePrechargeControl;

typedef enum
{
    IfxEvadc_SpreadEarlySamplePointEMUXConversionsMode_nominal = 0,  /**< \brief Nominal sample timing */
    IfxEvadc_SpreadEarlySamplePointEMUXConversionsMode_spread  = 1   /**< \brief Spread sample timing, end of sample phase is varied */
} IfxEvadc_SpreadEarlySamplePointEMUXConversionsMode;

/** \brief Spread Early Sample Point for Standard Conversions
 */
typedef enum
{
    IfxEvadc_SpreadEarlySamplePointStandardConversionsMode_nominal = 0,  /**< \brief Nominal sample timing */
    IfxEvadc_SpreadEarlySamplePointStandardConversionsMode_spread  = 1   /**< \brief Spread sample timing, end of sample phase is varied */
} IfxEvadc_SpreadEarlySamplePointStandardConversionsMode;

/** \brief The 0-1 transition of bit SUCAL initiates the start-up calibrationphase of
 * all analog converters (except for the fast compare channels).
 * Note: The start-up calibration will abort any running conversion
 * and cannot be stopped before it is complete.
 */
typedef enum
{
    IfxEvadc_StartupCalibration_noAction = 0,  /**< \brief No action */
    IfxEvadc_StartupCalibration_initiate = 1   /**< \brief Initiate the start-up calibration phase
                                                * (indication in bit GxARBCFG.CAL) */
} IfxEvadc_StartupCalibration;

/** \brief Adjusts the analog circuitry to the supply voltage used in the application
 * system. Make sure to keep SUPLEV = 0b00 or 0b01 in the case of a 5 V supply.
 */
typedef enum
{
    IfxEvadc_SupplyVoltageLevelControl_automaticControl = 0,  /**< \brief Automatic control: voltage range is controlled by the power supply */
    IfxEvadc_SupplyVoltageLevelControl_upperVoltage     = 1,  /**< \brief Upper voltage range: assume a 5 V power supply is connected */
    IfxEvadc_SupplyVoltageLevelControl_lowerVoltage     = 2   /**< \brief Lower voltage range: assume a 3.3 V power supply is connected */
} IfxEvadc_SupplyVoltageLevelControl;

/** \brief Wait-for-Read Mode Enable
 */
typedef enum
{
    IfxEvadc_WaitForRead_overwriteMode = 0,  /**< \brief Overwrite Mode */
    IfxEvadc_WaitForRead_enabled       = 1   /**< \brief Wait-for-read mode enabled for this register */
} IfxEvadc_WaitForRead;

/** \addtogroup IfxLld_Evadc_Std_Global
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Configures the wait-for-read mode for the specified result register of the EVADC group.
 *
 * \param[inout] group      Pointer to the EVADC group structure.
 * \param[in]    resultIdx  The index of the result register to configure.
 *                          Range" \ref 0 to 15
 * \param[in]    enabled    Boolean flag to enable (TRUE) or disable (FALSE) the wait-for-read mode for the specified result register.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_configureWaitForReadMode(Ifx_EVADC_G *group, uint32 resultIdx, boolean enabled);

/**
 * \brief Configures the wait for read mode for the global result register.
 *
 * \param[inout] evadc    Pointer to the EVADC module instance.
 * \param[in]    enabled  Boolean flag to enable (true) or disable (false) the wait for read mode.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_configureWaitForReadModeForGlobalResultRegister(Ifx_EVADC *evadc, boolean enabled);

/**
 * \brief Retrieves the global conversion mode for the specified ADC input class, indicating the noise reduction level.
 *
 * \param[in] evadc          Pointer to the EVADC module instance.
 * \param[in] inputClassNum  The input class number for which to retrieve the noise reduction level.
 *                           Range: 0 and 1
 *
 * \retval IfxEvadc_ChannelNoiseReduction, The noise reduction level for the specified ADC input class.
 *         Range: \ref IfxEvadc_ChannelNoiseReduction.
 */
IFX_INLINE IfxEvadc_ChannelNoiseReduction IfxEvadc_getGlobalConversionMode(Ifx_EVADC *evadc, uint8 inputClassNum);

/**
 * \brief Retrieves the conversion result stored in the Global Result Register of the EVADC module.
 *
 * \param[in] evadc  Pointer to the EVADC module instance.
 *
 * \retval Ifx_EVADC_GLOB_RES, A structure containing the global result register data.
 *
 * \code
 * Ifx_EVADC* evadc = &MODULE_EVADC; // module pointer
 * IfxEvadc_GroupId groupId = IfxEvadc_GroupId0; // for group 0
 * uint32 channels = (1 << 5) | (1 << 2); // enable channel #5 and #2
 * uint32 mask = (1 << 7) | (1 << 5) | (1 << 2); // modify the selection for channel #7, #5 and #2; channel #7 will be disabled
 *
 * //confiure wait for read mode for global result register
 * IfxEvadc_configureWaitForReadModeForGlobalResultRegister(evadc, TRUE);
 *
 * // enable all arbiter request sources
 * adcGroupConfig.arbiter.requestSlotQueue0Enabled           = TRUE; // enable Queue0 mode
 * // enable all gates in "always" mode (no edge detection)
 * adcGroupConfig.queueRequest[0].triggerConfig.gatingMode = IfxEvadc_GatingMode_always;
 *
 * // Add channel to queue with refill enabled
 *  IfxEvadc_Adc_addToQueue(&adcChannel, IFXEVADC_QUEUE_REFILL, IfxEvadc_RequestSource_queue0);
 *
 *  // start the Queue
 *  IfxEvadc_Adc_startQueue(&adcGroup, IfxEvadc_RequestSource_queue0);
 *
 * Ifx_EVADC_GLOB.RES result;
 * result = IfxVadc_getGlobalResult (evadc);
 *
 * \endcode
 *
 */
IFX_INLINE Ifx_EVADC_GLOB_RES IfxEvadc_getGlobalResult(Ifx_EVADC *evadc);

/**
 * \brief Get the global sample time of an ADC input class in seconds.
 *
 * \param[in] evadc           Pointer to the EVADC module instance.
 * \param[in] inputClassNum   The input class number for which to retrieve the noise reduction level.
 *                            Range: 0 and 1
 * \param[in] analogFrequency ADC module analog frequency in Hz.
 *
 * \retval float32 Sample time of the ADC input class in seconds.
 */
IFX_INLINE float32 IfxEvadc_getGlobalSampleTime(Ifx_EVADC *evadc, uint8 inputClassNum, float32 analogFrequency);


/**
 * \brief Retrieves the scaled conversion result from the specified result register of the EVADC group.
 *
 * \param[in] group     Pointer to the EVADC group structure.
 * \param[in] resultIdx The index of the result register to fetch the conversion result from.
 *                      Range: 0 to 15
 *
 * \retval Ifx_EVADC_G_RES The scaled conversion result stored in the specified result register.
 *
 *  * \code
 * Ifx_EVADC_G* group = &MODULE_EVADC.G[0]; // for group 0
 * uint32 channels = (1 << 5) | (1 << 2); // enable channel #5 and #2
 * uint32 mask = (1 << 7) | (1 << 5) | (1 << 2); // modify the selection for channel #7, #5 and #2; channel #7 will be disabled
 *
 * //confiure wait for read mode for global result register
 * IfxEvadc_configureWaitForReadMode(group,IfxEvadc_ChannelResult0, TRUE);
 * IfxEvadc_configureWaitForReadMode(group,IfxEvadc_ChannelResult1, TRUE);
 *
 *
 * // Add channel to queue with refill enabled
 *  IfxEvadc_Adc_addToQueue(&adcChannel, IfxEvadc_RequestSource_queue0, IFXEVADC_QUEUE_REFILL);
 *
 * // start the Queue
 *  IfxEvadc_Adc_startQueue(&adcGroup, IfxEvadc_RequestSource_queue0);
 *
 *
 * // wait for conversion to finish
 *
 * // fetch the result of conversion from result register 0 for group 0
 * Ifx_EVADC_G_RES result;
 * result = IfxEvadc_getResult(group, IfxEvadc_ChannelResult0);
 * \endcode
 */
IFX_INLINE Ifx_EVADC_G_RES IfxEvadc_getResult(Ifx_EVADC_G *group, uint32 resultIdx);

/**
 * \brief Sets the sample time in seconds for a specific ADC global input class.
 *
 * \param[inout] evadc              Pointer to the EVADC module registers.
 * \param[in]    groupInputClassNum Group input class number.
 *                                  Range: 0 to 0x7DF07DF
 * \param[in]    analogFrequency    ADC analog frequency in Hz.
 * \param[in]    sampleTime         Requested sample time in seconds for the input class.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setGlobalSampleTime(Ifx_EVADC *evadc, uint8 groupInputClassNum, float32 analogFrequency, float32 sampleTime);

/**
 * \brief Sets global boundary value.
 *
 * \param[inout] evadc  Pointer to the EVADC module instance.
 * \param[in]    bound0 Boundary 0 value
 *               Range: 0 to 0xFFF
 * \param[in]    bound1 Boundary 1 value
 *               Range: 0 to 0xFFF
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setGlobalBoundary(Ifx_EVADC *evadc, uint16 bound0, uint16 bound1);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Retrieves the conversion result for a specific channel based on the request source.
 *
 * \param[in] evadc       Pointer to the EVADC module.
 * \param[in] group       Pointer to the EVADC group.
 * \param[in] channel     The channel ID to retrieve the result for.
 *                        Range: \ref IfxEvadc_ChannelId
 * \param[in] sourceType  The type of request source.
 *                        Range: \ref IfxEvadc_RequestSource
 *
 * \retval Ifx_EVADC_G_RES The scaled conversion result.
 *
 * \code
 * Ifx_EVADC evadc;
 * evadc.evadc = &MODULE_EVADC;
 * Ifx_EVADC_G* group = &MODULE_EVADC.G[0]; // for group 0
 * uint32 channels = (1 << 5) | (1 << 2); // enable channel #5 and #2
 * uint32 mask = (1 << 7) | (1 << 5) | (1 << 2); // modify the selection for channel #7, #5 and #2; channel #7 will be disabled
 *
 * //confiure wait for read mode for global result register
 * IfxEvadc_configureWaitForReadMode(group,IfxEvadc_ChannelResult0, TRUE);
 * IfxEvadc_configureWaitForReadMode(group,IfxEvadc_ChannelResult1, TRUE);
 *
 * // Add channel to queue with refill enabled
 *  IfxEvadc_Adc_addToQueue(&adcChannel, IfxEvadc_RequestSource_queue0, IFXEVADC_QUEUE_REFILL);
 *
 * // start the Queue
 *  IfxEvadc_Adc_startQueue(&adcGroup, IfxEvadc_RequestSource_queue0);
 *
 * // fetch the result of conversion for channel 2 of group 0
 * Ifx_EVADC_G_RESresult2;
 * result = IfxEvadc_getResultBasedOnRequestSource(&evadc, group, IfxVadc_ChannelId2,IfxEvadc_RequestSource_queue0 );
 * Ifx_EVADC_G_RESresult5;
 * result = IfxEvadc_getResultBasedOnRequestSource(&evadc, group, IfxEvadc_ChannelId5,IfxEvadc_RequestSource_queue0 );
 * \endcode
 *
 */
IFX_EXTERN Ifx_EVADC_G_RES IfxEvadc_getResultBasedOnRequestSource(Ifx_EVADC *evadc, Ifx_EVADC_G *group, IfxEvadc_ChannelId channel, IfxEvadc_RequestSource sourceType);

/** \} */

/** \addtogroup IfxLld_Evadc_Std_QueueRequest
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Clears all the queue entries, including the backup stage, for the specified request source.
 *
 * \param[inout] evadcG     Pointer to the EVADC group registers structure.
 * \param[in]    flushQueue Boolean flag to determine whether the queue should be cleared.
 *                          Range: TRUE - Clears the queue.
 *                                 FALSE- Does not clear the queue.
 * \param[in]    sourceType The request source type specifying which queue to clear.
 *                          Range: \ref IfxEvadc_RequestSource.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_clearQueue(Ifx_EVADC_G *evadcG, boolean flushQueue, IfxEvadc_RequestSource sourceType);

/**
 * \brief Starts a queue of a group by generating a trigger event through software.
 *
 * This function initiates the specified queue within the EVADC group, enabling it to
 * process requests based on the selected source type.
 *
 * \param[inout] group      Pointer to the EVADC group.
 * \param[in]    sourceType Request source type specifying which queue to start.
 *                          Range: \ref IfxEvadc_RequestSource.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_startQueue(Ifx_EVADC_G *group, IfxEvadc_RequestSource sourceType);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * brief Add an entry to the queue of a group for the specified channel with the following options set:
 * refill incase of aborted conversion
 * source interrupt enable/disable
 * external trigger control of the aborted conversion
 *
 * \param[inout] group      Pointer to the EVADC group structure.
 * \param[in]    channel    Specifies the channel ID to be added to the queue.
 *                          Range: \ref IfxEvadc_ChannelId
 * \param[in]    sourceType Specifies the request source queue.
 *                          Range: \ref IfxEvadc_RequestSource
 * \param[in]    options    Bitmask specifying the configuration options
 *                          Range: 0 to 0x7EFF
 *
 * \retval None
 */
IFX_EXTERN void IfxEvadc_addToQueue(Ifx_EVADC_G *group, IfxEvadc_ChannelId channel, IfxEvadc_RequestSource sourceType, uint32 options);

/**
 * \brief Disables the external trigger for a specific queue slot in the EVADC group.
 *
 * \param[inout] evadcG     Pointer to the EVADC group registers structure.
 * \param[in]    sourceType Specifies the request source queue.
 *                          Range: \ref IfxEvadc_RequestSource
 *
 * \retval None
 */
IFX_EXTERN void IfxEvadc_disableQueueSlotExternalTrigger(Ifx_EVADC_G *evadcG, IfxEvadc_RequestSource sourceType);

/**
 * \brief Enables the external trigger for a specific queue slot.
 *
 * \param[inout] evadcG      Pointer to the EVADC group registers structure.
 * \param[in]    sourceType  Specifies the request source queue.
 *                           Range: \ref IfxEvadc_RequestSource
 *
 *
 * \retval None
 */
IFX_EXTERN void IfxEvadc_enableQueueSlotExternalTrigger(Ifx_EVADC_G *evadcG, IfxEvadc_RequestSource sourceType);

/**
 * \brief Gets the requested queue slot gating mode.
 *
 * \param[in] evadcG     Pointer to the EVADC group registers.
 * \param[in] sourceType Specifies the request source queue.
 *                       Range: \ref IfxEvadc_RequestSource
 *
 * \retval IfxEvadc_GatingMode The gating mode of the specified queue slot.
 *         Range: \ref IfxEvadc_GatingMode.
 */
IFX_EXTERN IfxEvadc_GatingMode IfxEvadc_getQueueSlotGatingMode(Ifx_EVADC_G *evadcG, IfxEvadc_RequestSource sourceType);

/**
 * \brief Retrieves the gating source for a specified request queue slot in the EVADC group.
 *
 * \param[in] evadcG     Pointer to the EVADC group registers.
 * \param[in] sourceType Specifies the request source queue.
 *                       Range: \ref IfxEvadc_RequestSource
 *
 * \retval IfxEvadc_GatingSource The gating source configured for the specified queue slot.
 *         Range: \ref IfxEvadc_GatingSource.
 */
IFX_EXTERN IfxEvadc_GatingSource IfxEvadc_getQueueSlotGatingSource(Ifx_EVADC_G *evadcG, IfxEvadc_RequestSource sourceType);

/**
 * \brief Retrieves the current priority level of a specific request source queue slot.
 *
 * \param[in] evadcG     Pointer to the EVADC group registers structure.
 * \param[in] sourceType Specifies the request source queue.
 *                       Range: \ref IfxEvadc_RequestSource
 *
 * \retval IfxEvadc_RequestSlotPriority The priority level of the specified queue slot.
 *         Range: \ref IfxEvadc_RequestSlotPriority.
 */
IFX_EXTERN IfxEvadc_RequestSlotPriority IfxEvadc_getQueueSlotPriority(Ifx_EVADC_G *evadcG, IfxEvadc_RequestSource sourceType);

/**
 * \brief Retrieves the requested queue slot start mode for the specified source type.
 *
 * \param[in] evadcG     Pointer to the EVADC group registers.
 * \param[in] sourceType Specifies the request source queue.
 *                       Range: \ref IfxEvadc_RequestSource
 *
 * \retval IfxEvadc_RequestSlotStartMode The configured start mode for the specified queue slot.
 *         Range: \ref IfxEvadc_RequestSlotStartMode.
 */
IFX_EXTERN IfxEvadc_RequestSlotStartMode IfxEvadc_getQueueSlotStartMode(Ifx_EVADC_G *evadcG, IfxEvadc_RequestSource sourceType);

/**
 * \brief Retrieves the trigger input for a specified queue slot request source.
 *
 * \param[in] evadcG     Pointer to the EVADC group registers.
 * \param[in] sourceType Specifies the request source queue.
 *                       Range: \ref IfxEvadc_RequestSource
 *
 * \retval IfxEvadc_TriggerSource The trigger input corresponding to the specified queue slot.
 *         Range: \ref IfxEvadc_TriggerSource.
 */
IFX_EXTERN IfxEvadc_TriggerSource IfxEvadc_getQueueSlotTriggerInput(Ifx_EVADC_G *evadcG, IfxEvadc_RequestSource sourceType);

/**
 * \brief Retrieves the trigger mode configuration for a specified request queue slot in the EVADC group.
 *
 * This function allows the user to query the trigger mode that has been configured for a specific request queue slot.
 * The trigger mode determines how the conversion in the specified queue slot is triggered.
 *
 * \param[in] evadcG      Pointer to the EVADC group registers.
 * \param[in] sourceType  Specifies the request source queue.
 *                        Range: \ref IfxEvadc_RequestSource
 *
 * \retval IfxEvadc_TriggerMode The trigger mode configuration for the specified queue slot.
 *         Range: \ref IfxEvadc_TriggerMode.
 */
IFX_EXTERN IfxEvadc_TriggerMode IfxEvadc_getQueueSlotTriggerMode(Ifx_EVADC_G *evadcG, IfxEvadc_RequestSource sourceType);

/**
 * \brief Gives the status of the Queue of a group by returning non zero value if the Queue is full
 *
 * \param[in] group      Pointer to the EVADC group structure.
 * \param[in] sourceType Specifies the request source queue.
 *                       Range: \ref IfxEvadc_RequestSource
 *
 * \retval IfxEvadc_Status, status of the Queue
 *         Range: \ref IfxEvadc_Status
 *
 * \code
 * Ifx_EVADC_G* group = &MODULE_EVADC.G[0]; // for group 0
 * boolean queueFull = (IfxEvadc_getQueueStatus(group)==IfxEvadc_Status_queueFull)?TRUE:FALSE; // get Queue status for group 0
 * \endcode
 *
 */
IFX_EXTERN IfxEvadc_Status IfxEvadc_getQueueStatus(Ifx_EVADC_G *group, IfxEvadc_RequestSource sourceType);

/**
 * \brief Returns the queue slot requested status.
 *
 * \param[in] evadcG     Pointer to the EVADC group registers.
 * \param[in] sourceType Specifies the request source queue.
 *                       Range: \ref IfxEvadc_RequestSource
 *
 * \retval TRUE  If the specified queue slot request is enabled.
 *         FALSE If the specified queue slot request is disabled.
 */
IFX_EXTERN boolean IfxEvadc_isRequestQueueSlotEnabled(Ifx_EVADC_G *evadcG, IfxEvadc_RequestSource sourceType);

/**
 * \brief Configures the gating settings for a specific queue slot.
 *
 * \param[inout] evadcG       Pointer to the EVADC group registers.
 * \param[in]    gatingSource Gate input selection for the group.
 *                            Range: \ref IfxEvadc_GatingSource
 * \param[in]    gatingMode   Gating mode selection.
 *                            Range: \ref IfxEvadc_GatingMode
 * \param[in]    sourceType   Specifies the request source queue.
 *                            Range: \ref IfxEvadc_RequestSource
 *
 * \retval None
 */
IFX_EXTERN void IfxEvadc_setQueueSlotGatingConfig(Ifx_EVADC_G *evadcG, IfxEvadc_GatingSource gatingSource, IfxEvadc_GatingMode gatingMode, IfxEvadc_RequestSource sourceType);

/**
 * \brief Sets the trigger operating configurations for the EVADC group.
 *
 * This function configures the trigger mode, trigger source, and request source type
 * for the specified EVADC group. It allows setting up the trigger events based on
 * rising, falling, or any edge, and selects the appropriate trigger source and
 * request source type for the queue slot.
 *
 * \param[inout] evadcG         Pointer to the EVADC group registers.
 * \param[in]    triggerMode    Trigger mode selection.
 *                              Range: \ref IfxEvadc_TriggerMode
 * \param[in]    triggerSource  Trigger input source selection.
 *                              Range: \ref IfxEvadc_TriggerSource
 * \param[in]    sourceType     Specifies the request source queue.
 *                              Range: \ref IfxEvadc_RequestSource
 *
 * \retval None
 */
IFX_EXTERN void IfxEvadc_setQueueSlotTriggerOperatingConfig(Ifx_EVADC_G *evadcG, IfxEvadc_TriggerMode triggerMode, IfxEvadc_TriggerSource triggerSource, IfxEvadc_RequestSource sourceType);

/** \} */

/** \addtogroup IfxLld_Evadc_Std_IO
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Initializes and configures an EMUX output pin with specified mode settings.
 *
 * \param[inout] emux        Pointer to the EMUX pin configuration to be initialized.
 * \param[in]    outputMode  The output mode to be configured for the EMUX pin.
 *                           Range: \ref IfxPort_OutputMode
 * \param[in]    padDriver   The pad driver mode to be configured for the EMUX pin.
 *                           Range: \ref IfxPort_PadDriver
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_initEmuxPin(const IfxEvadc_Emux_Out *emux, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver);

/**
 * \brief Initializes a GxBFL output pin with the specified output mode and pad driver settings.
 *
 * \param[inout] gxBfl The   GxBFL pin to be configured.
 * \param[in]    outputMode  The output mode to be configured for the EMUX pin.
 *                           Range: \ref IfxPort_OutputMode
 * \param[in]    padDriver   The pad driver mode to be configured for the EMUX pin.
 *                           Range: \ref IfxPort_PadDriver
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_initGxBflPin(const IfxEvadc_GxBfl_Out *gxBfl, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver);

/** \} */

/** \addtogroup IfxLld_Evadc_Std_Frequency
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Calculates the sample time based on the given analog frequency and sample time.
 *
 * \param[in] analogFrequency  The analog frequency in Hz.
 * \param[in] sampleTime       The sample time in seconds.
 *
 * \retval uint32 The calculated sample time in seconds as an unsigned 32-bit integer.
 *         Range: 0 to 0xFFFF FFFF
 */
IFX_INLINE uint32 IfxEvadc_calculateSampleTime(float32 analogFrequency, float32 sampleTime);

/**
 * \brief Retrieves the configured Fadci EVADC analog clock frequency in Hz.
 *
 * \param[in] group Pointer to the EVADC group structure.
 *
 * \retval The configured Fadci EVADC analog clock frequency in Hz.
 */
IFX_INLINE float32 IfxEvadc_getAdcAnalogFrequency(Ifx_EVADC_G *group);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Gets the configured Fadcd EVADC digital clock frequency in Hz.
 *
 * \param[in] evadc Pointer to the base of EVADC registers.
 *
 * \retval float32 The configured Fadcd EVADC digital clock frequency in Hz.
 */
IFX_EXTERN float32 IfxEvadc_getAdcDigitalFrequency(Ifx_EVADC *evadc);

/** \} */

/** \addtogroup IfxLld_Evadc_Std_Group
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief sets the analog clock synchronization delay for a specific group of the EVADC module
 *
 * \param[inout]  evadcG  Pointer to the EVADC group registers.
 * \param[in]     group   Group No.
 *                        Range: \ref IfxEvadc_GroupId
 * \param[in]     delay   Selects an additional clock cycle for the conversion step of the MSB
 *                        Range: \ref IfxEvadc_AnalogClockSynchronizationDelay
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setAnalogClockSynchronizationDelay(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group, IfxEvadc_AnalogClockSynchronizationDelay delay);

/**
 * \brief Configures the calibration sample time for the specified EVADC group.
 *
 * \param[inout] evadcG Pointer to EVADC SFRs of a particular group.
 * \param[in]    group  Group number to configure.
 *                      Range: \ref IfxEvadc_GroupId
 * \param[in]    mode   Calibration sample time control.
 *                      Range: \ref IfxEvadc_CalibrationSampleTimeControl
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setCalibrationSampleTime(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group, IfxEvadc_CalibrationSampleTimeControl mode);

/**
 * \brief Clears all pending result requests for the specified EVADC group.
 *
 * \param[inout] evadcG  Pointer to the EVADC group registers.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_clearAllResultRequests(Ifx_EVADC_G *evadcG);

/**
 * \brief Retrieves the noise reduction mode configured for the specified EVADC input class group.
 *
 * \param[in] evadcG        Pointer to the EVADC group registers.
 * \param[in] inputClassNum The input class number for which to retrieve the noise reduction level.
 *                           Range: 0 and 1
 *
 * \retval IfxEvadc_ChannelNoiseReduction The noise reduction mode configured for the input class group.
 *         Range: \ref IfxEvadc_ChannelNoiseReduction.
 */
IFX_INLINE IfxEvadc_ChannelNoiseReduction IfxEvadc_getGroupConversionMode(Ifx_EVADC_G *evadcG, uint8 inputClassNum);

 /**
 * \brief Retrieves conversion results for a specific EVADC group.
 *
 * This function fetches the conversion results for a specified number of channels
 * in the EVADC group and stores them in the provided results array starting from
 * the given offset.
 *
 * \param[in]    group        Pointer to the EVADC group structure containing the configuration
 * \param[inout] results      Pointer to the array where the conversion results will be stored.
 * \param[in]    resultOffset Offset in the results array where the first result will be stored.
 *                            Range: 0 to 0xFF
 * \param[in]    numResults   Number of results to retrieve from the group.
 *                            Range: 0 to 0xFF
 *
 * \retval None
 *
 * \code
 * Here,Three channels are used for queued transfers
 * \code
 *
 * unsigned savedGate = adcGroup.module.evadc->G[adcGroup.groupId].Queue0.QMR0.B.ENGT;
 *
 * // IMPORTANT: for deterministic results we have to disable the queue gate
 * // while filling the queue, otherwise results could be output in the wrong order
 * adcGroup.module.evadc->G[adcGroup.groupId].Queue0.QMR0.B.ENGT = 0;
 *
 * // create channel config
 * IfxEvadc_Adc_ChannelConfig adcChannelConfig[3];
 * IfxEvadc_Adc_Channel adcChannel[3];
 *
 * for(int chnIx=0; chnIx<3; ++chnIx) {
 * IfxEvadc_Adc_initChannelConfig(&adcChannelConfig[chnIx], &adcGroup);
 *
 * adcChannelConfig[chnIx].channelId = (IfxEvadc_ChannelId)(chnIx);
 * adcChannelConfig[chnIx].resultRegister = IfxEvadc_ChannelResult_1; // use result register #1 for all channels
 *
 * // initialize the channel
 * IfxEvadc_Adc_initChannel(&adcChannel[chnIx], &adcChannelConfig[chnIx]);
 *
 * // Add channel to queue with refill enabled
 * IfxEvadc_Adc_addToQueue(&adcChannel[chnIx], IfxEvadc_RequestSource_queue0, IFXEVADC_QUEUE_REFILL);
 *
 * // restore previous gate config
 * adcGroup.module.evadc->G[adcGroup.groupId].Queue0.QMR0.B.ENGT = savedGate;
 *
 * // start the Queue
 * IfxEvadc_Adc_startQueue(&adcGroup,IfxEvadc_RequestSource_queue0); // just for the case that somebody copy&pastes the code - the queue has already been started in previous test
 *
 * Ifx_EVADC_G_RES results[10];
 * result = IfxEvadc_getGroupResult(group, results, 0, 2);
 * \endcode
 *
 */
IFX_INLINE void IfxEvadc_getGroupResult(Ifx_EVADC_G *group, Ifx_EVADC_G_RES *results, uint32 resultOffset, uint32 numResults);

/**
 * \brief Gets the EVADC input class channel sample time.
 *
 * This function calculates the sample time for a specific ADC input class channel based on the provided parameters.
 *
 * \param[in] evadcG          Pointer to the EVADC group registers.
 * \param[in] inputClassNum   The input class number for which to retrieve the noise reduction level.
 *                           Range: 0 and 1
 * \param[in] analogFrequency ADC module analog frequency in Hz.
 *
 * \retval float32 ADC input class channel sample time in seconds.
 */
IFX_INLINE float32 IfxEvadc_getGroupSampleTime(Ifx_EVADC_G *evadcG, uint8 inputClassNum, float32 analogFrequency);

/**
 * \brief Retrieves the configured master index for the EVADC group.
 *
 * \param[in] evadcG Pointer to the EVADC group registers.
 *
 * \retval uint8 The configured master kernel index.
 *         Range: 0 to 3
 */
IFX_INLINE uint8 IfxEvadc_getMasterIndex(Ifx_EVADC_G *evadcG);

/**
 * \brief Selects the idle precharge level for the EVADC group.
 *
 * \param[inout] evadcG  Pointer to the EVADC group registers.
 * \param[in]    group   Group identifier for the EVADC instance to configure.
 *                       Range: \ref IfxEvadc_GroupId
 * \param[in]    mode    Idle precharge mode
 *                       Range: \ref IfxEvadc_IdlePrecharge
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_selectIdlePrechargeLevel(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group, IfxEvadc_IdlePrecharge mode);

/**
 * \brief Enables the input buffer for the specified EVADC group.
 *
 * \param[inout] evadcG  Pointer to the EVADC group registers.
 * \param[in]    group   Group identifier for the EVADC instance to configure.
 *                       Range: \ref IfxEvadc_GroupId
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_enableInputBuffer(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group);

/**
 * \brief Configures the reference precharge duration for the specified EVADC group.
 *
 * \param[inout] evadcG   Pointer to EVADC SFRs of a particular group
 * \param[in]    group    Group identifier for the EVADC instance to configure.
 *                        Range: \ref IfxEvadc_GroupId
 * \param[in]    duration Selects the amount of time for reference input precharging
 *                        Group identifier for the EVADC instance to configure.
 *                       Range: \ref IfxEvadc_ReferencePrechargeControl
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setReferencePrechargeDuration(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group, IfxEvadc_ReferencePrechargeControl duration);

/**
 * \brief Enables the reference precharge for the specified EVADC group.
 *
 * \param[inout] evadcG Pointer to EVADC SFRs of a particular group.
 * \param[in]    group  Group identifier for the EVADC instance to configure.
 *                      Range: \ref IfxEvadc_GroupId
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_enableReferencePrecharge(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group);

/**
 * \brief Resets the ADC group to its initial state.
 *
 * \param[inout] evadcG Pointer to EVADC SFRs of a particular group.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_resetGroup(Ifx_EVADC_G *evadcG);

/**
 * \brief Configures the sample synchronization mode for the specified EVADC group.
 * 
 * \param[inout] evadcG Pointer to EVADC SFRs of a particular group.
 * \param[in]    group  Group identifier for the EVADC instance to configure.
 *                      Range: \ref IfxEvadc_GroupId
 * \param[in]    mode   The sample synchronization mode to be configured.
 *                      Range: \ref IfxEvadc_SampleSynchronization
 * 
 * \retval None
 */
IFX_INLINE void IfxEvadc_setSampleSynchronizationMode(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group, IfxEvadc_SampleSynchronization mode);

/**
 * \brief Selects an additional clock cycle for the conversion step of the MSB.
 *
 * \param[inout] evadcG Pointer to EVADC SFRs of a particular group.
 * \param[in]    group  Group identifier for the EVADC instance to configure.
 *                      Range: \ref IfxEvadc_GroupId
 * \param[in]    mode   Selects the MSB conversion time in terms of t_ADC.
 *                      Range: \ref IfxEvadc_MsbConversionTime
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_selectDoubleClockForMSBConversion(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group, IfxEvadc_MsbConversionTime mode);

/**
 * \brief Sets the analog converter mode for the specified EVADC group.
 *
 * \param[inout] evadcG               Pointer to the EVADC group registers.
 * \param[in]    analogConverterMode  The mode to be set for the analog converter.
 *                                    Range: \ref IfxEvadc_AnalogConverterMode
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setAnalogConvertControl(Ifx_EVADC_G *evadcG, IfxEvadc_AnalogConverterMode analogConverterMode);

/**
 * \brief Configures the precharge control for the analog input EMUX of the EVADC group.
 *
 * \param[inout] evadcG        Pointer to the EVADC group registers.
 * \param[in]    inputClassNum The input class number for which to retrieve the noise reduction level.
 *                             Range: 0 and 1
 * \param[in]    mode          Precharge control mode to be set.
 *                             Range: \ref IfxEvadc_AnalogInputPrechargeControl
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setAnalogInputPrechargeControlEMUX(Ifx_EVADC_G *evadcG, uint8 inputClassNum, IfxEvadc_AnalogInputPrechargeControl mode);

/**
 * \brief Configures the analog input precharge control for standard conversions.
 *
 * \param[inout] evadcG        Pointer to the EVADC group's SFR structure.
 * \param[in]    inputClassNum The input class number for which to retrieve the noise reduction level.
 *                             Range: 0 and 1
 * \param[in]    mode          Precharge control mode to be set.
 *                             Range: \ref IfxEvadc_AnalogInputPrechargeControl
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setAnalogInputPrechargeControlStandard(Ifx_EVADC_G *evadcG, uint8 inputClassNum, IfxEvadc_AnalogInputPrechargeControl mode);

/**
 * \brief Sets the conversion mode for the specified ADC input class channel group.
 * 
 * \param[inout] evadcG         Pointer to the EVADC group registers.
 * \param[in]    inputClassNum  The input class number for which to retrieve the noise reduction level.
 *                              Range: 0 and 1
 * \param[in]    conversionMode Conversion mode to be set for the input class channel.
 *                              Range: \ref IfxEvadc_ChannelNoiseReduction
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setGroupConversionMode(Ifx_EVADC_G *evadcG, uint8 inputClassNum, IfxEvadc_ChannelNoiseReduction conversionMode);

/**
 * \brief Sets the conversion mode for EMUX conversions in the specified EVADC group.
 *
 * \param[inout] evadcG         Pointer to the EVADC group's Special Function Registers (SFRs).
 * \param[in]    inputClassNum  The input class number for which to retrieve the noise reduction level.
 *                              Range: 0 and 1
 * \param[in]    conversionMode The desired conversion mode for noise reduction.
 *                              Range: \ref IfxEvadc_ChannelNoiseReductionEMUX
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setGroupConversionModeEMUX(Ifx_EVADC_G *evadcG, uint8 inputClassNum, IfxEvadc_ChannelNoiseReductionEMUX conversionMode);

/**
 * \brief Configures the sample time for a specific ADC input class group.
 *
 * \param[inout] evadcG           Pointer to the EVADC group registers.
 * \param[in]    inputClassNum    The input class number for which to retrieve the noise reduction level.
 *                                Range: 0 and 1
 * \param[in]    analogFrequency  ADC analog frequency in Hz.
 * \param[in]    sampleTime       Requested sample time in seconds
 * 
 * \retval None
 */
IFX_INLINE void IfxEvadc_setGroupSampleTime(Ifx_EVADC_G *evadcG, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime);

/**
 * \brief Sets the additional number of cycles (in addition to 2) in the sample time for the EVADC group.
 *
 * \param[inout] evadcG          Pointer to the EVADC group's Special Function Registers (SFRs).
 * \param[in]    inputClassNum   The input class number for which to retrieve the noise reduction level.
 *                               Range: 0 and 1
 * \param[in]    analogFrequency ADC analog frequency in Hz.
 * \param[in]    sampleTime      Requested sample time in seconds for the input class.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setGroupSampleTimeEMUX(Ifx_EVADC_G *evadcG, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime);

/**
 * \brief Configures the master index for the EVADC group.
 *
 * \param[inout] evadcG      Pointer to the EVADC group registers.
 * \param[in]    masterIndex Master index value to be set.
 *                           Range:  0 to 3
 *
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setMasterIndex(Ifx_EVADC_G *evadcG, uint8 masterIndex);

/**
 * \brief Configures the spread early sample point and EMUX conversions for a specific input class.
 *
 * \param[inout] evadcG        Pointer to the EVADC group registers.
 * \param[in]    inputClassNum The input class number for which to retrieve the noise reduction level.
 *                             Range: 0 and 1
 * \param[in]    mode          Mode of operation for spread early sample point and EMUX conversions.
 *                             Range: \ref IfxEvadc_SpreadEarlySamplePointEMUXConversionsMode
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_spreadEarlySamplePointEMUXConversions(Ifx_EVADC_G *evadcG, uint8 inputClassNum, IfxEvadc_SpreadEarlySamplePointEMUXConversionsMode mode);

/**
 * \brief Configures the spread early sample point standard conversions for the EVADC group.
 *
 * \param[inout] evadcG        Pointer to the EVADC group registers.
 * \param[in]    inputClassNum The input class number for which to retrieve the noise reduction level.
 *                             Range: 0 and 1
 * \param[in]    mode          Mode of spread early sample point standard conversions.
 *                             Range: \ref IfxEvadc_SpreadEarlySamplePointStandardConversionsMode
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_spreadEarlySamplePointStandardConversions(Ifx_EVADC_G *evadcG, uint8 inputClassNum, IfxEvadc_SpreadEarlySamplePointStandardConversionsMode mode);

/**
 * \brief Sets group-specific boundary values for the EVADC group.
 *
 * \param[inout] evadcG Pointer to the EVADC group registers.
 * \param[in]    bound0 Boundary 0 value
 *                      Range: 0 to 0xFFF
 * \param[in]    bound1 Boundary 1 value
 *                      Range: 0 to 0xFFF
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setGroupBoundary(Ifx_EVADC_G *evadcG, uint16 bound0, uint16 bound1);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Sets the Arbiter slot configurations for the EVADC group.
 *
 * \param[inout] evadcG     Pointer to the EVADC group registers.
 * \param[in]    slotEnable Enable or disable the slot.
 *                          Range: TRUE: Enable the slot.
 *                                 FALSE: Disable the slot.
 * \param[in]    prio       The priority level of the request slot.
 *                          Range: \ref IfxEvadc_RequestSlotPriority
 * \param[in]    mode       The start mode of the request slot.
 *                          Range: \ref IfxEvadc_RequestSlotStartMode
 * \param[in]    slot       The request source slot to configure.
 *                          Range: \ref IfxEvadc_RequestSource
 *
 * \retval None
 */
IFX_EXTERN void IfxEvadc_setArbiterPriority(Ifx_EVADC_G *evadcG, boolean slotEnable, IfxEvadc_RequestSlotPriority prio, IfxEvadc_RequestSlotStartMode mode, IfxEvadc_RequestSource slot);

/** \} */

/** \addtogroup IfxLld_Evadc_Std_Module
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Disables the EVADC module by resetting it and stopping conversions.
 *
 * \param[inout] evadc  Pointer to the base of EVADC module.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_disableModule(Ifx_EVADC *evadc);

/**
 * \brief Disables or enables the post calibration for the specified EVADC group.
 *
 * \param[inout] evadcG  Pointer to the base of EVADC group registers.
 * \param[in]    group   Group identifier for the EVADC instance to configure.
 *                       Range: \ref IfxEvadc_GroupId
 * \param[in]    enabled Boolean flag to disable (FALSE) or enable (TRUE) the post calibration.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_disablePostCalibration(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group, boolean enabled);

/**
 * \brief Enables the EVADC kernel module.
 *
 * \param[inout] evadc Pointer to the base of EVADC module.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_enableModule(Ifx_EVADC *evadc);

/**
 * \brief Gets the active state of the ADC calibration for a specified calibration group.
 *
 * \param[in] evadc          Pointer to the base of EVADC module.
 * \param[in] adcCalGroupNum ADC CAL group number to query.
 *                           Range: 0 to 11
 *
 * \retval uint8 CAL group status. The value indicates whether the calibration is active (1) or inactive (0).
 *         Range: 0 - calibration is inactive.
 *                1 - calibration is active.
 */
IFX_INLINE uint8 IfxEvadc_getAdcCalibrationActiveState(Ifx_EVADC *evadc, uint8 adcCalGroupNum);

/**
 * \brief Retrieves the current global configuration value of the EVADC module.
 *
 * \param[in] evadc  Pointer to the base of EVADC module.
 *
 * \retval Ifx_EVADC_GLOBCFG The global control configuration value.
 */
IFX_INLINE Ifx_EVADC_GLOBCFG IfxEvadc_getGlobalConfigValue(Ifx_EVADC *evadc);

/**
 * \brief Retrieves the SRC source address for the specified group and source number.
 *
 * \param[in] group  Group identifier for the EVADC instance to configure.
 *                   Range: \ref IfxEvadc_GroupId
 * \param[in] index  SRC number.
 *                   Range: \ref IfxEvadc_SrcNr
 *
 * \retval Ifx_SRC_SRCR* Pointer to the SRC source register for the specified group and source number.
 */
IFX_INLINE volatile Ifx_SRC_SRCR *IfxEvadc_getSrcAddress(IfxEvadc_GroupId group, IfxEvadc_SrcNr index);

/**
 * \brief Checks the status of the startup calibration for the EVADC module.
 *
 * \param[in] evadc Pointer to the base of EVADC module.
 *
 * \retval TRUE  If startup calibration is enabled.
 *         FALSE If startup calibration is disabled.
 */
IFX_INLINE boolean IfxEvadc_getStartupCalibrationStatus(Ifx_EVADC *evadc);

/**
 * \brief Initialises the ADC converter clock.
 *
 * \param[in]    evadc                  Pointer to the base of EVADC module.
 * \param[inout] evadcG                 Pointer to the base of EVADC group registers.
 * \param[in]    converterClockDivider  The clock divider factor for the ADC converter clock.
 *                                      Range: \ref IfxEvadc_ClockDividerFactor
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_initialiseAdcConverterClock(Ifx_EVADC *evadc, Ifx_EVADC_G *evadcG, IfxEvadc_ClockDividerFactor converterClockDivider);

/**
 * \brief Initiates the startup calibration process for the EVADC module.
 *
 * \param[inout] evadc Pointer to the base of EVADC module.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_initiateStartupCalibration(Ifx_EVADC *evadc);

/**
 * \brief Checks if the EVADC module is currently in a suspended state.
 *
 * \param[in] evadc Pointer to the base of EVADC module.
 *
 * \retval TRUE  Module is suspended.
 *         FALSE Module is not suspended.
 */
IFX_INLINE boolean IfxEvadc_isModuleSuspended(Ifx_EVADC *evadc);

/**
 * \brief Sets the global conversion mode for the specified input class.
 *
 * \param[inout] evadc          Pointer to the base of EVADC module.
 * \param[in]    InputClassNum  The input class number for which to retrieve the noise reduction level.
 *                              Range: 0 to 0x11
 * \param[in]    conversionMode ADC conversion mode.
 *                              Range: \ref IfxEvadc_ChannelNoiseReduction
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setGlobalConversionMode(Ifx_EVADC *evadc, uint8 InputClassNum, IfxEvadc_ChannelNoiseReduction conversionMode);

/**
 * \brief Sets the sensitivity of the module to the sleep signal.
 *
 * \param[inout] evadc Pointer to the base of EVADC module.
 * \param[in]    mode  The mode of operation for sleep signal sensitivity.
 *                     Range: \ref IfxEvadc_SleepMode
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setSleepMode(Ifx_EVADC *evadc, IfxEvadc_SleepMode mode);

/** \brief Configure the Module to Hard/Soft suspend mode.
 *
 * Note: The api works only when the OCDS is enabled and in Supervisor Mode. When OCDS is disabled the OCS suspend control is ineffective.
 *
 * \param[inout] evadc Pointer to the base of EVADC module.
 * \param[in]    mode  Module suspend mode
 *                     Range: \ref IfxEvadc_SuspendMode
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setSuspendMode(Ifx_EVADC *evadc, IfxEvadc_SuspendMode mode);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Disables write access to the specified EVADC configuration/control registers.
 *
 * \param[inout] evadc         Pointer to the base of EVADC module.
 * \param[in]    protectionSet Index of the bit in the ACCPROTx {x=0/1} for which write access is to be enabled.
 *                             Range: \ref IfxEvadc_Protection
 *
 * \retval None
 */
IFX_EXTERN void IfxEvadc_disableAccess(Ifx_EVADC *evadc, IfxEvadc_Protection protectionSet);

/**
 * \brief Enables write access to the EVADC configuration and control registers.
 *
 * \param[inout] evadc         Pointer to the base of EVADC module.
 * \param[in]    protectionSet Index of the bit in the ACCPROTx {x=0/1} for which write access is to be enabled.
 *                             Range: \ref IfxEvadc_Protection
 *
 * \retval None
 */
IFX_EXTERN void IfxEvadc_enableAccess(Ifx_EVADC *evadc, IfxEvadc_Protection protectionSet);

/**
 * \brief Gets the ADC module frequency in Hz.
 *
 * \param[in] evadc  Pointer to the base of EVADC module.
 *
 * \retval float32 The ADC module frequency in Hz.
 */
IFX_EXTERN float32 IfxEvadc_getAdcModuleFrequency(Ifx_EVADC *evadc);

/**
 * \brief Initializes and configures the ADC analog clock with a specified frequency.
 *
 * \param[in]    evadc  Pointer to the base of EVADC module.
 * \param[in]    fAdcI  ADC analog clock frequency in Hz.
 *                      Range: 0 to 0xFFFF FFFF
 * \param[inout] group  Pointer to the base of EVADC group registers.
 *
 * \retval uint32 The configured ADC analog clock frequency in Hz.
 *         Range: 0 to 0xFFFF FFFF.
 */
IFX_EXTERN uint32 IfxEvadc_initializeFAdcI(Ifx_EVADC *evadc, uint32 fAdcI, Ifx_EVADC_G *group);

/**
 * \brief Resets the EVADC module to its initial state.
 *
 * \param[inout] evadc Pointer to the base of EVADC module.
 *
 * \retval None
 */
IFX_EXTERN void IfxEvadc_resetModule(Ifx_EVADC *evadc);

/**
 * \brief Starts ADC calibration and waits for the end of the calibration process.
 *
 * \param[inout] evadc Pointer to the base of EVADC module.
 *
 * \retval None
 */
IFX_EXTERN void IfxEvadc_startupCalibration(Ifx_EVADC *evadc);

/**
 * \brief SW workaround for EVADC Master/Slave conversion jitter issue (MCMETILLD-910).
 *
 * \param[inout] evadc Pointer to the base of EVADC module.
 *
 * \retval TRUE  No failure detected in the activation states.
 *         FALSE Failure detected in either or both activation states.
 */
IFX_EXTERN boolean IfxEvadc_syncConvWorkAround(Ifx_EVADC *evadc);

/** \} */

/** \addtogroup IfxLld_Evadc_Std_Channel
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Clears the request for the specified EVADC channel.
 *
 * \param[inout] evadcG    Pointer to the base of EVADC group registers.
 * \param[in]    channelId Specifies the channel ID to be added to the queue.
 *                         Range: \ref IfxEvadc_ChannelId
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_clearChannelRequest(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelId);

/**
 * \brief Enables the FIFO mode for the specified channel result register of the EVADC group.
 *
 * \param[inout] evadcG         Pointer to the base of EVADC group registers.
 * \param[in]    resultRegister Channel result register to configure.
 *                              Range: \ref IfxEvadc_ChannelResult
 * \param[in]    fifoMode       FIFO mode to enable.
 *                              Range: \ref IfxEvadc_FifoMode
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_enableFifoMode(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelResult resultRegister, IfxEvadc_FifoMode fifoMode);

/**
 * \brief Enables a service request for the specified channel result register in the EVADC group.
 *
 * \param[inout] evadcG         Pointer to the base of EVADC group registers.
 * \param[in]    resultRegister Channel result register to configure.
 *                              Range: \ref IfxEvadc_ChannelResult
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_enableServiceRequest(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelResult resultRegister);

/**
 * \brief Disables the service request for the specified channel result register in the EVADC module.
 *
 * \param[inout] evadcG         Pointer to the base of EVADC group registers.
 * \param[in]    resultRegister Channel result register to configure.
 *                              Range: \ref IfxEvadc_ChannelResult
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_disableServiceRequest(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelResult resultRegister);

/**
 * \brief Retrieves the current control configuration for a specified EVADC channel.
 *
 * \param[in] evadcG        Pointer to the base of EVADC group registers.
 * \param[in] channelIndex  Specifies the channel ID to be added to the queue.
 *                          Range: \ref IfxEvadc_ChannelId
 *
 * \retval Ifx_EVADC_G_CHCTR The current control configuration of the specified EVADC channel.
 */
IFX_INLINE Ifx_EVADC_G_CHCTR IfxEvadc_getChannelControlConfig(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex);

/**
 * \brief Retrieves the input class configuration for the specified EVADC channel.
 *
 * \param[in] evadcG       Pointer to the base of EVADC group registers.
 * \param[in] channelIndex Specifies the channel ID to be added to the queue.
 *                         Range: \ref IfxEvadc_ChannelId
 *
 * \retval IfxEvadc_InputClasses The input class of the specified channel.
 */
IFX_INLINE IfxEvadc_InputClasses IfxEvadc_getChannelInputclass(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex);

/**
 * \brief Provides a pointer to the channel result service request node 0.
 *
 * \param[in] evadcG Pointer to the base of EVADC group registers.
 *
 * \retval Ifx_EVADC_G_REVNP0 Pointer to the channel result service request node 0.
 */
IFX_INLINE Ifx_EVADC_G_REVNP0 IfxEvadc_getChannelResultServiceRequestNodePointer0(Ifx_EVADC_G *evadcG);

/**
 * \brief Retrieves the channel result service request node pointer 1 for the EVADC group.
 *
 * \param[in] evadcG Pointer to the base of EVADC group registers.
 *
 * \retval The channel result service request node pointer 1
 */
IFX_INLINE Ifx_EVADC_G_REVNP1 IfxEvadc_getChannelResultServiceRequestNodePointer1(Ifx_EVADC_G *evadcG);

/**
 * \brief Retrieves the channel service request node pointer for channel 0.
 *
 * \param[in] evadcG Pointer to the base of EVADC group registers.
 *
 * \retval Ifx_EVADC_G_CEVNP0 Pointer to the service request node for channel 0.
 */
IFX_INLINE Ifx_EVADC_G_CEVNP0 IfxEvadc_getChannelServiceRequestNodePointer0(Ifx_EVADC_G *evadcG);

#if !defined(DEVICE_TC33XED) && !defined (DEVICE_TC35X)
/**
 * \brief Retrieves the channel service request node pointer for channels CH8 to CH15.
 *
 * \param[in] evadcG Pointer to the base of EVADC group registers.
 *
 * \retval Ifx_EVADC_G_CEVNP1 Channel service request node pointer for CH8 to CH15.
 */
IFX_INLINE Ifx_EVADC_G_CEVNP1 IfxEvadc_getChannelServiceRequestNodePointer1(Ifx_EVADC_G *evadcG);
#endif

/**
 * \brief Configures the boundary extension mode for the specified EVADC channel.
 *
 * \param[inout] evadcG       Pointer to the EVADC group registers.
 * \param[in]    channelIndex Specifies the channel ID to be added to the queue.
 *                            Range: \ref IfxEvadc_ChannelId
 * \param[in]    boundaryMode Specifies the boundary extension mode to be applied to the channel.
 *                            Range: \ref IfxEvadc_BoundaryExtension
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setBoundaryMode(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, IfxEvadc_BoundaryExtension boundaryMode);

/**
 * \brief Sets the channel event service request line for the specified EVADC group and channel.
 *
 * \param[inout] evadcG       Pointer to the EVADC group registers.
 * \param[in]    channelSrcNr Service request node number to be assigned to the channel.
 *                            Range: \ref IfxEvadc_SrcNr
 * \param[in]    channel      Specifies the channel ID to be added to the queue.
 *                            Range: \ref IfxEvadc_ChannelId
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setChannelEventNodePointer0(Ifx_EVADC_G *evadcG, IfxEvadc_SrcNr channelSrcNr, IfxEvadc_ChannelId channel);

#if !defined(DEVICE_TC33XED) && !defined (DEVICE_TC35X)
/**
 * \brief Sets the channel event node pointer for channels 8 to 15.
 *
 * This function configures the specified channel to use a specific service request node.
 *
 * \param[inout] evadcG       Pointer to the EVADC group registers.
 * \param[in]    channelSrcNr Service request node number to be assigned to the channel.
 *                            Range: \ref IfxEvadc_SrcNr
 * \param[in]    channel      Specifies the channel ID to be added to the queue.
 *                            Range: \ref IfxEvadc_ChannelId
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setChannelEventNodePointer1(Ifx_EVADC_G *evadcG, IfxEvadc_SrcNr channelSrcNr, IfxEvadc_ChannelId channel);
#endif

/**
 * \brief Configures the input class for a specified EVADC channel.
 *
 * \param[inout] evadcG       Pointer to the EVADC group registers.
 * \param[in]    channelIndex Specifies the channel ID to be added to the queue.
 *                            Range: \ref IfxEvadc_ChannelId
 * \param[in]    inputClass   The input class to be assigned to the channel.
 *                            Range: \ref IfxEvadc_InputClasses
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setChannelInputClass(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, IfxEvadc_InputClasses inputClass);

/**
 * \brief Configures the limit check mode for a specific EVADC channel.
 *
 * \param[inout] evadcG       Pointer to the EVADC group registers.
 * \param[in]    channelIndex Specifies the channel ID to be added to the queue.
 *                            Range: \ref IfxEvadc_ChannelId
 * \param[in]    limitCheck   The limit check mode to set.
 *                            Range: \ref IfxEvadc_LimitCheck
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setChannelLimitCheckMode(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, IfxEvadc_LimitCheck limitCheck);

/**
 * \brief Configures the data modification mode for a specific result register of an EVADC group.
 *
 * \param[inout] evadcG          Pointer to the EVADC group registers.
 * \param[in]    resultRegister  The result register to configure.
 *                               Range: \ref  IfxEvadc_ChannelResult
 * \param[in]    mode            The data modification mode to set.
 *                               Range: \ref  IfxEvadc_DataModificationMode
 * 0b01 Result filtering mode.
 * 0b10 Difference mode
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setDataModificationMode(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelResult resultRegister, IfxEvadc_DataModificationMode mode);

/**
 * \brief Sets the data reduction control mode for a specific result register in an EVADC group.
 *
 * \param[inout] evadcG          Pointer to the EVADC group registers.
 * \param[in]    resultRegister  The result register to configure.
 *                               Range: \ref  IfxEvadc_ChannelResult
 * \param[in]    mode            The data modification mode to set.
 *                               Range: 0 to F
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setDataReductionControlMode(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelResult resultRegister, uint32 mode);

/**
 * \brief Configures the FIFO mode for the specified result register of the EVADC group.
 *
 * \param[inout] evadcG         Pointer to the EVADC group registers.
 * \param[in]    resultRegister The result register to configure.
 *                              Range: \ref  IfxEvadc_ChannelResult
 * \param[in]    mode           FIFO mode configuration
 *                              Range: \ref  IfxEvadc_FifoMode
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFifoMode(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelResult resultRegister, IfxEvadc_FifoMode mode);

/**
 * \brief Configures the lower boundary for a specific channel within an EVADC group.
 *
 * \param[inout] evadcG        Pointer to the EVADC group registers.
 * \param[in]    channelIndex  Specifies the channel ID to be added to the queue.
 *                             Range: \ref IfxEvadc_ChannelId
 * \param[in]    lowerBoundary The boundary selection for the lower boundary.
 *                             Range: \ref IfxEvadc_BoundarySelection
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setLowerBoundary(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, IfxEvadc_BoundarySelection lowerBoundary);

/**
 * \brief Selects the reference input for the specified EVADC channel.
 *
 * \param[inout] evadcG       Pointer to the EVADC group registers.
 * \param[in]    channelIndex Specifies the channel ID to be added to the queue.
 *                            Range: \ref IfxEvadc_ChannelId
 * \param[in]    reference    The reference input to be selected for the channel.
 *                            Range: \ref IfxEvadc_ChannelReference
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setReferenceInput(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, IfxEvadc_ChannelReference reference);

/**
 * \brief Sets the result event node pointer 0 for the specified EVADC group.
 *
 * \param[inout] evadcG         Pointer to the EVADC group registers.
 * \param[in]    resultSrcNr    Service request node number to be assigned to the channel.
 *                              Range: \ref IfxEvadc_SrcNr
 * \param[in]    resultRegister The result register to configure.
 *                              Range: \ref  IfxEvadc_ChannelResult
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setResultNodeEventPointer0(Ifx_EVADC_G *evadcG, IfxEvadc_SrcNr resultSrcNr, IfxEvadc_ChannelResult resultRegister);

/**
 * \brief Configures the result event node pointer 1 for the specified EVADC group.
 *
 * \param[inout] evadcG         Pointer to the EVADC group registers.
 * \param[in]    resultSrcNr    Service request node number to be assigned to the channel.
 *                              Range: \ref IfxEvadc_SrcNr
 * \param[in]    resultRegister The result register to configure.
 *                              Range: \ref  IfxEvadc_ChannelResult
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setResultNodeEventPointer1(Ifx_EVADC_G *evadcG, IfxEvadc_SrcNr resultSrcNr, IfxEvadc_ChannelResult resultRegister);

/**
 * \brief Configures the result storage position alignment for the specified EVADC channel.
 *
 * \param[inout] evadcG              Pointer to the EVADC group registers.
 * \param[in]    channelIndex        Specifies the channel ID to be added to the queue.
 *                                   Range: \ref IfxEvadc_ChannelId
 * \param[in]    rightAlignedStorage Boolean flag to enable right-aligned storage.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setResultPosition(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, boolean rightAlignedStorage);

/**
 * \brief Configures the synchronization request for a specific channel within the EVADC group.
 *
 * \param[inout] evadcG        Pointer to the EVADC group registers.
 * \param[in]    channelIndex  Specifies the channel ID to be added to the queue.
 *                             Range: \ref IfxEvadc_ChannelId
 * \param[in]    synchonize    Boolean flag to enable or disable synchronization:
 *                             TRUE : Enable synchronization for the channel.
 *                             FALSE: Disable synchronization.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setSyncRequest(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, boolean synchonize);

/**
 * \brief Sets the upper boundary for a specific channel within an EVADC group.
 *
 * \param[inout] evadcG        Pointer to the EVADC group registers.
 * \param[in]    channelIndex  Specifies the channel ID to be added to the queue.
 *                             Range: \ref IfxEvadc_ChannelId
 * \param[in]    upperBoundary The selection for the upper boundary.
 *                             Range: \ref IfxEvadc_BoundarySelection
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setUpperBoundary(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, IfxEvadc_BoundarySelection upperBoundary);

/**
 * \brief Stores the result of a specific channel within the EVADC group.
 *
 * \param[inout] evadcG         Pointer to EVADC group registers.
 * \param[in]    channelIndex   Specifies the channel ID to be added to the queue.
 *                              Range: \ref IfxEvadc_ChannelId
 * \param[in]    resultRegister The result register to configure.
 *                              Range: \ref  IfxEvadc_ChannelResult
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_storeGroupResult(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, IfxEvadc_ChannelResult resultRegister);

/** \} */

/** \addtogroup IfxLld_Evadc_Std_Emux
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Gets the global conversion mode for the specified input class.
 *
 * \param[in] evadc         Pointer to the base of EVADC module.
 * \param[in] inputClassNum The input class number for which to retrieve the noise reduction level.
 *                          Range: 0 and 1
 *
 * \retval IfxEvadc_ChannelNoiseReduction The noise reduction mode configured for the specified input class.
 *         Range: \ref IfxEvadc_ChannelNoiseReduction.
 */
IFX_INLINE IfxEvadc_ChannelNoiseReduction IfxEvadc_getEmuxGlobalConversionMode(Ifx_EVADC *evadc, uint8 inputClassNum);

/**
 * \brief Retrieves the external conversion mode for the specified ADC input class.
 *
 * \param[in] evadcG        Pointer to EVADC group registers.
 * \param[in] inputClassNum The input class number for which to retrieve the noise reduction level.
 *                          Range: 0 and 1
 *
 * \retval IfxEvadc_ChannelNoiseReduction The noise reduction mode configured for the specified input class.
 */
IFX_INLINE IfxEvadc_ChannelNoiseReduction IfxEvadc_getEmuxGroupConversionMode(Ifx_EVADC_G *evadcG, uint8 inputClassNum);

/**
 * \brief Gets the ADC input class sample time of an external channel.
 *
 * \param[in] evadcG          Pointer to EVADC group registers.
 * \param[in] inputClassNum   The input class number for which to retrieve the noise reduction level.
 *                            Range: 0 and 1
 * \param[in] analogFrequency ADC module analog frequency in Hz.
 *
 * \retval float32 ADC input class external channel sample time in seconds.
 */
IFX_INLINE float32 IfxEvadc_getEmuxGroupSampleTime(Ifx_EVADC_G *evadcG, uint8 inputClassNum, float32 analogFrequency);

/**
 * \brief Configures the external conversion mode for the specified Global Input Class.
 *
 * \param[inout] evadc           Pointer to the base of EVADC module.
 * \param[in]    inputClassNum   The input class number for which to retrieve the noise reduction level.
 *                               Range: 0 and 1
 * \param[in]    conversionMode  ADC conversion mode.
 *                               Range: \ref IfxEvadc_ChannelNoiseReduction
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setEmuxGlobalConversionMode(Ifx_EVADC *evadc, uint8 inputClassNum, IfxEvadc_ChannelNoiseReduction conversionMode);

/**
 * \brief Configures the sample time for the ADC global class for an external channel.
 *
 * \param[inout] evadc           Pointer to the base of EVADC module.
 * \param[in]    inputClassNum   The input class number for which to retrieve the noise reduction level.
 *                               Range: 0 and 1
 * \param[in]    analogFrequency The ADC analog frequency in Hz.
 * \param[in]    sampleTime      The requested sample time for the input class in seconds.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setEmuxGlobalSampleTime(Ifx_EVADC *evadc, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime);

/**
 * \brief Configures the conversion mode for external channel conversion of the specified ADC input class.
 *
 * \param[inout] evadcG         Pointer to EVADC group registers.
 * \param[in]    inputClassNum  The input class number for which to retrieve the noise reduction level.
 *                              Range: 0 and 1
 * \param[in]    conversionMode ADC conversion mode.
 *                              Range: \ref IfxEvadc_ChannelNoiseReduction
 *
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setEmuxGroupConversionMode(Ifx_EVADC_G *evadcG, uint8 inputClassNum, IfxEvadc_ChannelNoiseReduction conversionMode);

/**
 * \brief Sets the ADC input class sample time for external channel.
 * This function calculates and configures the necessary sample time for the specified ADC input class.
 *
 * \param[inout] evadcG          Pointer to EVADC group registers.
 * \param[in]    inputClassNum   The input class number for which to retrieve the noise reduction level.
 *                               Range: 0 and 1
 * \param[in]    analogFrequency The ADC analog frequency in Hz.
 * \param[in]    sampleTime      The requested sample time for the input class in seconds.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setEmuxGroupSampletime(Ifx_EVADC_G *evadcG, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Configures the external multiplexer mode for the EVADC module.
 *
 * \param[inout] evadc                 Pointer to the base of EVADC module.
 * \param[inout] evadcG                Pointer to EVADC group registers.
 * \param[in]    mode                  External Multiplexer mode to be configured.
 *                                     Range: \ref IfxEvadc_ExternalMultiplexerMode
 * \param[in]    channels              Specifies the channel ID.
 *                                     Range: 0 to 15
 * \param[in]    startChannel          Specifies the external channel value from which conversion is to be carried out.
 *                                     Range: \ref IfxEvadc_EmuxSelectValue
 * \param[in]    code                  Specifies the output channel number coding scheme.
 *                                     Range: \ref IfxEvadc_EmuxCodingScheme
 * \param[in]    sampleTimeControl     Specifies when to use a sample time for the external channel.
 *                                     Range: \ref IfxEvadc_EmuxSampleTimeControl
 * \param[in]    channelSelectionStyle Specifies the external multiplexer channel selection style.
 *                                     Range: \ref IfxEvadc_ChannelSelectionStyle
 *
 * \retval None
 */
IFX_EXTERN void IfxEvadc_configExternalMultiplexerMode(Ifx_EVADC *evadc, Ifx_EVADC_G *evadcG, IfxEvadc_ExternalMultiplexerMode mode, uint8 channels, IfxEvadc_EmuxSelectValue startChannel, IfxEvadc_EmuxCodingScheme code, IfxEvadc_EmuxSampleTimeControl sampleTimeControl, IfxEvadc_ChannelSelectionStyle channelSelectionStyle);

/** \} */

#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)
/** \addtogroup IfxLld_Evadc_Std_FastCompare
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Configures the software control for the Boundary Flag in the Fast Compare module.
 *
 * \param[inout] evadcFC Pointer to the EVADC register set for Fast Compare operations.
 * \param[in]    control Action to be taken on the Boundary Flag (FCM.B.BFL).
 *                       Range: \ref IfxEvadc_BoundaryFlagSwControl
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareBoundaryFlagSwControl(Ifx_EVADC_FC *evadcFC, IfxEvadc_BoundaryFlagSwControl control);

/**
 * \brief Configures the Boundary Flag inversion setting for the Fast Compare module.
 *
 * \param[inout] evadcFC Pointer to the EVADC register set for Fast Compare operations.
 * \param[in]    mode    Controls the inversion of the Boundary Flag.
 *                       Range: \ref IfxEvadc_BoundaryFlagInversionControl
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareBoundaryFlagInversion(Ifx_EVADC_FC *evadcFC, IfxEvadc_BoundaryFlagInversionControl mode);

/**
 * \brief Disables the Fast Compare boundary flag for the specified EVADC instance.
 *
 * \param[inout] evadcFC Pointer to the EVADC register set for Fast Compare operation.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_disableFastCompareBoundaryFlag(Ifx_EVADC_FC *evadcFC);

/**
 * \brief Enables the Fast Compare Boundary Flag for the specified EVADC Fast Compare instance.
 *
 * \param[inout] evadcFC Pointer to the EVADC register set for Fast Compare operation.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_enableFastCompareBoundaryFlag(Ifx_EVADC_FC *evadcFC);

/**
 * \brief Enable or disable sample timing synchronization for Fast Compare operations
 *
 * \param[inout] evadcFC Pointer to the EVADC register set for Fast Compare operations
 * \param[in]    mode    Sample synchronization mode to be configured
 *                       Range: \ref IfxEvadc_SampleSynchronization
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_enableFastCompareSampleSynchronization(Ifx_EVADC_FC *evadcFC, IfxEvadc_SampleSynchronization mode);

/**
 * \brief Sets the reference precharge duration for the Fast Compare reference input FCCTRL.B.RPC.
 *
 * \param[inout] evadcFC  Pointer to the EVADC register set for Fast Compare operations.
 * \param[in]    duration Reference precharge control mode
 *                        Range: \ref IfxEvadc_ReferencePrechargeControl
 *
 * 0 - Precharge the reference input for 1 clock phase
 * 1 - Precharge the reference input for 1 clock period (2 phases)
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareReferencePrechargeDuration(Ifx_EVADC_FC *evadcFC, IfxEvadc_ReferencePrechargeControl duration);

/**
 * \brief Gets the status of the Fast Compare boundary flag.
 *
 * \param[in] evadcFC Pointer to the EVADC register set for Fast Compare operations.
 *
 * \retval 0 (FALSE) Passive state : Result has not yet crossed the activation boundary, or selected gate signal is inactive, or this boundary flag is disabled.
 *         1 (TRUE)  Active state  : Result has crossed the activation boundary.
 */
IFX_INLINE boolean IfxEvadc_getFastCompareBoundaryFlagStatus(Ifx_EVADC_FC *evadcFC);

/**
 * \brief Returns the current level status of the external trigger input for the Fast Compare module.
 *
 * \param[in] evadcFC Pointer to the EVADC register set for Fast Compare operations.
 *
 * \retval TRUE  The external trigger level is high.
 *         FALSE The external trigger level is low.
 */
IFX_INLINE boolean IfxEvadc_getFastCompareExternalTriggerLevelStatus(Ifx_EVADC_FC *evadcFC);

/**
 * \brief Checks the status of the Fast Compare operation result
 *
 * \param[in] evadcFC  Pointer to the EVADC register set for Fast Compare operations.
 *
 * \retval TRUE  Fast Compare condition has been met.
 *         FALSE Fast Compare condition has not been met.
 */
IFX_INLINE boolean IfxEvadc_getFastCompareResultStatus(Ifx_EVADC_FC *evadcFC);

/**
 * \brief Checks if a new result is available in the Fast Compare Module (FCM) of the EVADC.
 *
 * \param[in] evadcFC Pointer to the EVADC register set for Fast Compare operations.
 *
 * \retval TRUE   A new result is available in the FCM.B.FCR bit.
 *         FALSE  No new result is available in the FCM.B.FCR bit.
 */
IFX_INLINE boolean IfxEvadc_isFastCompareNewResultAvailable(Ifx_EVADC_FC *evadcFC);

/**
 * \brief Selects the behavior of the Boundary Flag (BFL) with respect to the value of FCR.
 *
 * \param[inout] evadcFC Pointer to the EVADC register set for Fast Compare operations.
 * \param[in]    mode    The mode of Boundary Flag activation
 *                       Range: \ref IfxEvadc_BoundaryFlagActivationMode
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_selectFastCompareBoundaryFlagActivationMode(Ifx_EVADC_FC *evadcFC, IfxEvadc_BoundaryFlagActivationMode mode);

/**
 * \brief Selects the boundary flag node pointer for fast compare operations in the EVADC module.
 *
 * \param[inout] evadcFC     Pointer to the EVADC register set for Fast Compare operations.
 * \param[in]    nodePointer Boundary flag node pointer to be selected for the fast compare operation.
 *                           Range: \ref IfxEvadc_BoundaryFlagNodePointer
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_selectFastCompareBoundaryFlagNodePointer(Ifx_EVADC_FC *evadcFC, IfxEvadc_BoundaryFlagNodePointer nodePointer);

/**
 * \brief Sets the delay of the analog clock (in clock cycles) after the synchronization signal.
 *
 * \param[inout] evadcFC Pointer to the EVADC register set for Fast Compare operation.
 * \param[in]    delay   Defines the delay of the analog clock in clock cycles after the synchronization signal.
 *                       Range: \ref IfxEvadc_FastCompareAnalogClockSynchronizationDelay
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareAnalogClockSynchronizationDelay(Ifx_EVADC_FC *evadcFC, IfxEvadc_FastCompareAnalogClockSynchronizationDelay delay);

/**
 * \brief Set Analog Converter Control modes
 *
 * \param[inout] evadcFC  Pointer to the EVADC register set for Fast Compare operation.
 * \param[ino]   mode     Analog Converter Control modes
 *                        Range: \ref IfxEvadc_FastCompareAnalogConverterControl
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareAnalogConverter(Ifx_EVADC_FC *evadcFC, IfxEvadc_FastCompareAnalogConverterControl mode);

/**
 * \brief Configures the analog input precharge control for Fast Compare operations.
 *
 * \param[inout] evadcFC Pointer to the EVADC register set for Fast Compare operations.
 * \param[in]    mode    Analog Input Precharge Control mode for Fast Compare operations.
 *                       Range: \ref IfxEvadc_AnalogInputPrechargeControl
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareAnalogInputPrechargeControl(Ifx_EVADC_FC *evadcFC, IfxEvadc_AnalogInputPrechargeControl mode);

/**
 * \brief Sets the Fast Compare Analog Internal Clock Divider to control the frequency of the analog converter clock.
 *
 * This function configures the divider factor for the Fast Compare Analog Internal Clock (fADCI),
 * which is derived from the peripheral clock (fADC) using the formula: fADCI = fADC / divider.
 *
 * \param[inout] evadcFC Pointer to the EVADC register set for Fast Compare operations.
 * \param[in]    divider Fast Compare Analog Internal Clock Divider factor. The divider can be set to values from 0 (max frequency) to 31 (fADC / 32).
 *                       Range: \ref IfxEvadc_ClockDividerFactor
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareAnalogInternalClockDivider(Ifx_EVADC_FC *evadcFC, IfxEvadc_ClockDividerFactor divider);

/**
 * \brief Sets the source of the value(s) in bitfield FCREF.
 *
 * \param[inout] evadcFC Pointer to EVADC register set for Fast Compare operation.
 * \param[in]    mode    Defines the source of the value(s) in bitfield FCREF.
 *                       Range: \ref IfxEvadc_FastCompareAutomaticUpdate
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareAutomaticUpdateMode(Ifx_EVADC_FC *evadcFC, IfxEvadc_FastCompareAutomaticUpdate mode);

/**
 * \brief Configures the event mode for the Fast Compare channel in the EVADC module.
 *
 * \param[inout] evadcFC Pointer to the EVADC register set for Fast Compare operations.
 * \param[in]    mode    Mode/criteria for generating service requests.
 *                       Range: \ref IfxEvadc_ChannelEventMode
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareChannelEventMode(Ifx_EVADC_FC *evadcFC, IfxEvadc_ChannelEventMode mode);

/**
 * \brief Configures the external trigger polarity for the Fast Compare operation.
 *
 * \param[inout] evadcFC Pointer to the EVADC register set for Fast Compare operations.
 * \param[in]    mode    The external trigger polarity mode to be set.
 *                       Range: \ref IfxEvadc_ExternalTriggerPolarity
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareExternalTriggerPolarity(Ifx_EVADC_FC *evadcFC, IfxEvadc_ExternalTriggerPolarity mode);

/**
 * \brief Configures the Fast Compare Gate operating mode for the specified EVADC instance.
 *
 * \param[inout] evadcFC Pointer to the EVADC register set for Fast Compare operations.
 * \param[in]    mode    Operating mode for the Fast Compare Gate.
 *                       Range: \ref IfxEvadc_ExternalTriggerPolarity
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareGateOperatingMode(Ifx_EVADC_FC *evadcFC, IfxEvadc_GateOperatingMode mode);

/**
 * \brief Configures the ramp direction for the Fast Compare module.
 *
 * \param[inout] evadcFC       Pointer to EVADC register set for Fast Compare operation.
 * \param[in]    rampDirection Ramp direction setting.
 *                             Range: \ref IfxEvadc_ExternalTriggerPolarity
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareRampDirection(Ifx_EVADC_FC *evadcFC, IfxEvadc_RampDirection rampDirection);

/**
 * \brief Sets the reference value for fast comparison in the EVADC module.
 *
 * \param[inout] evadcFC        Pointer to EVADC register set for Fast Compare operation.
 * \param[in]    referenceValue The reference value to be used for comparison. The input signal level is compared against this value during fast compare operations.
 *                              Range: 0 to 0x3FF
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareReferenceValue(Ifx_EVADC_FC *evadcFC, uint16 referenceValue);

/**
 * \brief Configures the run mode of the fast compare channel.
 *
 * \param[inout] evadcFC Pointer to the EVADC register set for Fast Compare operation.
 * \param[in]    mode    Run mode of the fast compare channel.
 *                       Range: \ref IfxEvadc_FastCompareRunControl
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareRunControl(Ifx_EVADC_FC *evadcFC, IfxEvadc_FastCompareRunControl mode);

/**
 * \brief Set the fast compare run ramp control for channel.
 *
 * \param[inout] evadcFC       Pointer to EVADC register set for Fast Compare operation
 * \param[in]    rampStartMode Defines the run conditions for the ramp generation
 *                             Range: \ref IfxEvadc_RampRunControl
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareRunRampControl(Ifx_EVADC_FC *evadcFC, IfxEvadc_RampRunControl rampStartMode);

/**
 * \brief Configures the additional sample time for the Fast Compare operation by setting the STCF field in the FCCTRL register.
 *
 * \param[inout] evadcFC          Pointer to the EVADC register set for Fast Compare operations.
 * \param[in]    additionalCycles Number of additional clock cycles to be added to the minimum sample phase of 2 analog clock cycles.
 *                                Range: 0 to 255.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareSampleTimeControl(Ifx_EVADC_FC *evadcFC, uint8 additionalCycles);

/**
 * \brief Sets the criteria for generating service requests in the Fast Compare module.
 *
 * \param[inout] evadcFC Pointer to the EVADC register set for Fast Compare operations.
 * \param[in]    mode    Defines the mode for service request generation.
 *                       Range: \ref IfxEvadc_FastCompareServiceRequestGeneration
 * 
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareServiceRequestGeneration(Ifx_EVADC_FC *evadcFC, IfxEvadc_FastCompareServiceRequestGeneration mode);

/**
 * \brief Sets the interval at which fast compare operations are triggered in steps of 16 * 1/f_ADC
 *
 * \param[inout] evadcFC  Pointer to EVADC register set for Fast Compare operation
 * \param[in]    interval Defines the interval at which fast compare operations are triggered in steps of 16 * 1/f_ADC.
 *                        Range: 0 to 0xFF
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareTriggerInterval(Ifx_EVADC_FC *evadcFC, uint8 interval);

/**
 * \brief Sets the trigger operating mode for the Fast Compare channel in the EVADC module.
 *
 * \param[inout] evadcFC Pointer to the EVADC register set for Fast Compare operations.
 * \param[in]    mode    Trigger operating mode to be configured.
 *                       Range: \ref IfxEvadc_TriggerOperatingMode
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setFastCompareTriggerOperatingMode(Ifx_EVADC_FC *evadcFC, IfxEvadc_TriggerOperatingMode mode);

/** \} */
#endif /*#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)*/

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \brief Retrieves the analog function configuration of the specified EVADC group.
 *
 * \param[in] evadcG  Pointer to EVADC group registers.
 *
 * \retval Ifx_EVADC_G_ANCFG The analog function configuration value of the EVADC group.
 */
IFX_INLINE Ifx_EVADC_G_ANCFG IfxEvadc_getAnalogFunctionConfiguration(Ifx_EVADC_G *evadcG);

/**
 * \brief Calculates the sample time of ADC global class for an external channel.
 *
 * \param[in] evadc           Pointer to the base of EVADC module.
 * \param[in] inputClassNum   The input class number for which to retrieve the noise reduction level.
 *                             Range: 0 and 1
 * \param[in] analogFrequency The analog frequency of the ADC module in Hz.
 *
 * \retval float32 The sample time of the ADC input class external channel in seconds.
 */
IFX_INLINE float32 IfxEvadc_getEmuxGlobalSampleTime(Ifx_EVADC *evadc, uint8 inputClassNum, float32 analogFrequency);

/**
 * \brief Configures the Emux Interface for a specific group in the EVADC module.
 *
 * \param[inout] evadc         Pointer to the base of EVADC module.
 * \param[in]    emuxInterface Specifies the Emux interface to be configured.
 *                             Range: \ref IfxEvadc_EmuxInterface
 * \param[in]    group         Group identifier for the EVADC instance to configure.
 *                             Range: \ref IfxEvadc_GroupId
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setEmuxInterfaceForGroup(Ifx_EVADC *evadc, IfxEvadc_EmuxInterface emuxInterface, IfxEvadc_GroupId group);

/**
 * \brief Disables the reference precharge for the specified EVADC group.
 *
 * \param[inout] evadcG Pointer to EVADC group registers.
 * \param[in]    group  Group identifier for the EVADC instance to configure.
 *                      Range: \ref IfxEvadc_GroupId
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_disableReferencePrecharge(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group);

/**
 * \brief Disables the input buffer for the specified EVADC group.
 *
 * \param[inout] evadcG Pointer to EVADC group registers.
 * \param[in]    group  Group identifier for the EVADC instance to configure.
 *                      Range: \ref IfxEvadc_GroupId
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_disableInputBuffer(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group);

/**
 * \brief Checks if the clock for the EVADC module is enabled.
 *
 * \param[in] evadc Pointer to the base of EVADC module.
 *
 * \retval TRUE   If the EVADC module's clock is enabled.
 *          FALSE If the EVADC module's clock is disabled.
 */
IFX_INLINE boolean IfxEvadc_isModuleEnabled(Ifx_EVADC *evadc);

/**
 * \brief Enables the startup calibration phase for the EVADC module.
 *
 * \param[inout] evadc Pointer to the base of EVADC module.
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_enableStartupCalibration(Ifx_EVADC *evadc);

/**
 * \brief Configures the gating mode for a specific request queue in the EVADC group.
 *
 * \param[inout] evadcG     Pointer to EVADC group registers.
 * \param[in]    queue      The request source queue to configure.
 *                          Range: \ref IfxEvadc_RequestSource
 * \param[in]    gatingMode The gating mode to apply to the specified queue.
 *                          Range: \ref IfxEvadc_GatingMode
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_selectQueueGatingMode(Ifx_EVADC_G *evadcG, IfxEvadc_RequestSource queue, IfxEvadc_GatingMode gatingMode);

/**
 * \brief Sets the channel number to be converted for the specified request queue.
 *
 * \param[inout] evadcG   Pointer to EVADC group registers.
 * \param[in]    queue    The request source queue to configure.
 *                        Range: \ref IfxEvadc_RequestSource
 * \param[in]    channel  Specifies the channel ID to be added to the queue.
 *                        Range: \ref IfxEvadc_ChannelId
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_setChannelRequest(Ifx_EVADC_G *evadcG, IfxEvadc_RequestSource queue, IfxEvadc_ChannelId channel);

/**
 * \brief Configures the global input class registers for the EVADC group, defining the sample time and data conversion mode.
 *
 * \param[inout] evadcG        Pointer to EVADC group registers.
 * \param[in]    inputClassNum The input class number for which to retrieve the noise reduction level.
 *                             Range: 0 and 1
 * \param[in]    value         Value to be written to the input class register.
 *                             Range: 0 to 0x7DF07DF
 *
 * \retval None
 */
IFX_INLINE void IfxEvadc_configureIclass(Ifx_EVADC_G *evadcG, uint8 inputClassNum, uint32 value);

/**
 * \brief Returns the pointer to the result register for the specified channel.
 *
 * \param[in] evadcG  Pointer to EVADC group registers.
 * \param[in] channel Specifies the channel ID to be added to the queue.
 *                    Range: \ref IfxEvadc_ChannelId
 *
 * \retval uint32 The address of the result register for the specified channel.
 */
IFX_INLINE volatile uint32 *IfxEvadc_getResultRegisterAddress(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channel);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxEvadc_setAnalogClockSynchronizationDelay(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group, IfxEvadc_AnalogClockSynchronizationDelay delay)
{
    IFX_UNUSED_PARAMETER(group);
#if defined(DEVICE_TC38EVOX) || defined(DEVICE_TC38X) || defined(DEVICE_TC39XB)
    evadcG->ANCFG.B.ACSD = delay;
#elif defined(DEVICE_TC33XED) || defined(DEVICE_TC35X)
    if (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)
	{
		evadcG->ANCFG.B.ACSD = delay;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)); /*Settings are only for Primary & Secondary groups*/
	}
#else
	if (((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || ((group > 7) && (group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))))
	{
		evadcG->ANCFG.B.ACSD = delay;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, ((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || (group > 7 && group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))); /*Settings are only for Primary & Secondary groups*/
	}
#endif
}


IFX_INLINE uint32 IfxEvadc_calculateSampleTime(float32 analogFrequency, float32 sampleTime)
{
    uint32 ticks = 0;

    ticks = (uint32)(sampleTime * analogFrequency) - 2;

    if (ticks > 31)
    {
        ticks = (ticks / 16) + 15;
    }

    ticks = __minu(ticks, 0xFFu);

    return ticks;
}


IFX_INLINE void IfxEvadc_setCalibrationSampleTime(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group, IfxEvadc_CalibrationSampleTimeControl mode)
{
    IFX_UNUSED_PARAMETER(group);
#if defined(DEVICE_TC38EVOX) || defined(DEVICE_TC38X) || defined(DEVICE_TC39XB)
    evadcG->ANCFG.B.CALSTC = mode;
#elif defined(DEVICE_TC33XED) || defined(DEVICE_TC35X)
    if (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)
	{
		evadcG->ANCFG.B.CALSTC = mode;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)); /*Settings are only for Primary & Secondary groups*/
	}
#else
	if (((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || ((group > 7) && (group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))))
	{
		evadcG->ANCFG.B.CALSTC = mode;
	}

	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, ((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || (group > 7 && group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))); /*Settings are only for Primary & Secondary groups*/
	}
#endif
}


IFX_INLINE void IfxEvadc_clearAllResultRequests(Ifx_EVADC_G *evadcG)
{
    evadcG->REFCLR.U = 0x0000FFFFu;
}


IFX_INLINE void IfxEvadc_clearChannelRequest(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelId)
{
    evadcG->CEFCLR.U = 1 << channelId;
}


IFX_INLINE void IfxEvadc_clearQueue(Ifx_EVADC_G *evadcG, boolean flushQueue, IfxEvadc_RequestSource sourceType)
{
    switch (sourceType)
    {
    case IfxEvadc_RequestSource_queue0:
        evadcG->Q[0].QMR.B.FLUSH = flushQueue;
        break;
    case IfxEvadc_RequestSource_queue1:
        evadcG->Q[1].QMR.B.FLUSH = flushQueue;
        break;
    case IfxEvadc_RequestSource_queue2:
        evadcG->Q[2].QMR.B.FLUSH = flushQueue;
        break;
    }
}


IFX_INLINE void IfxEvadc_configureWaitForReadMode(Ifx_EVADC_G *group, uint32 resultIdx, boolean enabled)
{
    group->RCR[resultIdx].B.WFR = enabled;
}


IFX_INLINE void IfxEvadc_configureWaitForReadModeForGlobalResultRegister(Ifx_EVADC *evadc, boolean enabled)
{
    evadc->GLOB.RCR.B.WFR = enabled;
}

#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)
IFX_INLINE void IfxEvadc_setFastCompareBoundaryFlagSwControl(Ifx_EVADC_FC *evadcFC, IfxEvadc_BoundaryFlagSwControl control)
{
    evadcFC->FCBFL.B.BFS = control;
}


IFX_INLINE void IfxEvadc_setFastCompareBoundaryFlagInversion(Ifx_EVADC_FC *evadcFC, IfxEvadc_BoundaryFlagInversionControl mode)
{
    evadcFC->FCBFL.B.BFI = mode;
}


IFX_INLINE void IfxEvadc_disableFastCompareBoundaryFlag(Ifx_EVADC_FC *evadcFC)
{
    evadcFC->FCBFL.B.BFM = 0;
}
#endif /*#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)*/

IFX_INLINE void IfxEvadc_disableModule(Ifx_EVADC *evadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    evadc->CLC.B.DISR = 1;
    IfxScuWdt_setCpuEndinit(passwd);
}


IFX_INLINE void IfxEvadc_disablePostCalibration(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group, boolean enabled)
{
    IFX_UNUSED_PARAMETER(group);
#if defined(DEVICE_TC38EVOX) || defined(DEVICE_TC38X) || defined(DEVICE_TC39XB)
    evadcG->ANCFG.B.DPCAL = enabled;
#elif defined(DEVICE_TC33XED) || defined(DEVICE_TC35X)
    if (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)
	{
		evadcG->ANCFG.B.DPCAL = enabled;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)); /*Settings are only for Primary & Secondary groups*/
	}
#else
	if (((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || ((group > 7) && (group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))))
	{
		evadcG->ANCFG.B.DPCAL = enabled;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, ((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || (group > 7 && group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))); /*Settings are only for Primary & Secondary groups*/
	}
#endif
}

#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)
IFX_INLINE void IfxEvadc_enableFastCompareBoundaryFlag(Ifx_EVADC_FC *evadcFC)
{
    evadcFC->FCBFL.B.BFM = 1;
}


IFX_INLINE void IfxEvadc_enableFastCompareSampleSynchronization(Ifx_EVADC_FC *evadcFC, IfxEvadc_SampleSynchronization mode)
{
    Ifx_EVADC_FC_FCM tempFCM;
    tempFCM.U       = evadcFC->FCM.U;
    tempFCM.B.FCMWC = 1;  /*Enabling write permission to FCM.B.SSE*/
    tempFCM.B.SSE   = mode;
    evadcFC->FCM.U  = tempFCM.U;
}
#endif /*#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)*/

IFX_INLINE void IfxEvadc_enableFifoMode(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelResult resultRegister, IfxEvadc_FifoMode fifoMode)
{
    evadcG->RCR[resultRegister].B.FEN = fifoMode;
}


IFX_INLINE void IfxEvadc_enableModule(Ifx_EVADC *evadc)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();

    IfxScuWdt_clearCpuEndinit(passwd);
    evadc->CLC.U = 0x00000000;
    IfxScuWdt_setCpuEndinit(passwd);
}


IFX_INLINE void IfxEvadc_enableServiceRequest(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelResult resultRegister)
{
    evadcG->RCR[resultRegister].B.SRGEN = 1;
}


IFX_INLINE void IfxEvadc_disableServiceRequest(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelResult resultRegister)
{
    evadcG->RCR[resultRegister].B.SRGEN = 0;
}

#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)
IFX_INLINE void IfxEvadc_setFastCompareReferencePrechargeDuration(Ifx_EVADC_FC *evadcFC, IfxEvadc_ReferencePrechargeControl duration)
{
    Ifx_EVADC_FC_FCCTRL tempFCCTRL;
    tempFCCTRL.U      = evadcFC->FCCTRL.U;
    tempFCCTRL.B.CPWC = 1; /*Enabling write permission to FCCTRL.B.RPC*/
    tempFCCTRL.B.RPE  = duration;
    evadcFC->FCCTRL.U = tempFCCTRL.U;
}
#endif /*#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)*/

IFX_INLINE float32 IfxEvadc_getAdcAnalogFrequency(Ifx_EVADC_G *group)
{
#ifdef IFX_CFG_AURIX_SCUCCU_USED
    return IfxScuCcu_getSpbFrequency() / (1U + group->ANCFG.B.DIVA);
#else
    return IfxScuCcu_getAdcFrequency() / (1U + group->ANCFG.B.DIVA);
#endif
}


IFX_INLINE uint8 IfxEvadc_getAdcCalibrationActiveState(Ifx_EVADC *evadc, uint8 adcCalGroupNum)
{
    uint8 status = 0;
    status = evadc->G[adcCalGroupNum].ARBCFG.B.CAL;
    return status;
}


IFX_INLINE Ifx_EVADC_G_ANCFG IfxEvadc_getAnalogFunctionConfiguration(Ifx_EVADC_G *evadcG)
{
    Ifx_EVADC_G_ANCFG analogCfg;
    analogCfg.U = evadcG->ANCFG.U;
    return analogCfg;
}


IFX_INLINE Ifx_EVADC_G_CHCTR IfxEvadc_getChannelControlConfig(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex)
{
    Ifx_EVADC_G_CHCTR tempChctr;
    tempChctr.U = evadcG->CHCTR[channelIndex].U;
    return tempChctr;
}


IFX_INLINE IfxEvadc_InputClasses IfxEvadc_getChannelInputclass(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex)
{
    return (IfxEvadc_InputClasses)evadcG->CHCTR[channelIndex].B.ICLSEL;
}


IFX_INLINE Ifx_EVADC_G_REVNP0 IfxEvadc_getChannelResultServiceRequestNodePointer0(Ifx_EVADC_G *evadcG)
{
    Ifx_EVADC_G_REVNP0 resultServiceRequestNodePtr0;
    resultServiceRequestNodePtr0.U = evadcG->REVNP0.U;
    return resultServiceRequestNodePtr0;
}


IFX_INLINE Ifx_EVADC_G_REVNP1 IfxEvadc_getChannelResultServiceRequestNodePointer1(Ifx_EVADC_G *evadcG)
{
    Ifx_EVADC_G_REVNP1 resultServiceRequestNodePtr1;
    resultServiceRequestNodePtr1.U = evadcG->REVNP1.U;
    return resultServiceRequestNodePtr1;
}


IFX_INLINE Ifx_EVADC_G_CEVNP0 IfxEvadc_getChannelServiceRequestNodePointer0(Ifx_EVADC_G *evadcG)
{
    Ifx_EVADC_G_CEVNP0 serviceRequestNodePtr;
    serviceRequestNodePtr.U = evadcG->CEVNP0.U;
    return serviceRequestNodePtr;
}

#if !defined(DEVICE_TC33XED) && !defined (DEVICE_TC35X)
IFX_INLINE Ifx_EVADC_G_CEVNP1 IfxEvadc_getChannelServiceRequestNodePointer1(Ifx_EVADC_G *evadcG)
{
    Ifx_EVADC_G_CEVNP1 serviceRequestNodePtr;
    serviceRequestNodePtr.U = evadcG->CEVNP1.U;
    return serviceRequestNodePtr;
}
#endif

IFX_INLINE IfxEvadc_ChannelNoiseReduction IfxEvadc_getEmuxGlobalConversionMode(Ifx_EVADC *evadc, uint8 inputClassNum)
{
    return (IfxEvadc_ChannelNoiseReduction)evadc->GLOB.ICLASS[inputClassNum].B.CME;
}


IFX_INLINE float32 IfxEvadc_getEmuxGlobalSampleTime(Ifx_EVADC *evadc, uint8 inputClassNum, float32 analogFrequency)
{
    return (float32)(IFXEVADC_SAMPLETIME_MIN + evadc->GLOB.ICLASS[inputClassNum].B.STCE) / analogFrequency;
}


IFX_INLINE IfxEvadc_ChannelNoiseReduction IfxEvadc_getEmuxGroupConversionMode(Ifx_EVADC_G *evadcG, uint8 inputClassNum)
{
    return (IfxEvadc_ChannelNoiseReduction)evadcG->ICLASS[inputClassNum].B.CME;
}


IFX_INLINE float32 IfxEvadc_getEmuxGroupSampleTime(Ifx_EVADC_G *evadcG, uint8 inputClassNum, float32 analogFrequency)
{
    return (float32)(IFXEVADC_SAMPLETIME_MIN + evadcG->ICLASS[inputClassNum].B.STCE) / analogFrequency;
}

#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)
IFX_INLINE boolean IfxEvadc_getFastCompareBoundaryFlagStatus(Ifx_EVADC_FC *evadcFC)
{
    boolean status;

    if (evadcFC->FCBFL.B.BFL == 1)
    {
        status = TRUE;
    }
    else
    {
        status = FALSE;
    }

    return status;
}


IFX_INLINE boolean IfxEvadc_getFastCompareExternalTriggerLevelStatus(Ifx_EVADC_FC *evadcFC)
{
    boolean extTrigLevel;

    if (evadcFC->FCCTRL.B.XTLVL == 1)
    {
        extTrigLevel = TRUE;
    }
    else
    {
        extTrigLevel = FALSE;
    }

    return extTrigLevel;
}


IFX_INLINE boolean IfxEvadc_getFastCompareResultStatus(Ifx_EVADC_FC *evadcFC)
{
    boolean result;

    if (evadcFC->FCBFL.B.FCR == 1)
    {
        result = TRUE;
    }
    else
    {
        result = FALSE;
    }

    return result;
}
#endif /*#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)*/

IFX_INLINE Ifx_EVADC_GLOBCFG IfxEvadc_getGlobalConfigValue(Ifx_EVADC *evadc)
{
    Ifx_EVADC_GLOBCFG globCfg;
    globCfg.U = evadc->GLOBCFG.U;
    return globCfg;
}


IFX_INLINE IfxEvadc_ChannelNoiseReduction IfxEvadc_getGlobalConversionMode(Ifx_EVADC *evadc, uint8 inputClassNum)
{
    return (IfxEvadc_ChannelNoiseReduction)evadc->GLOB.ICLASS[inputClassNum].B.CMS;
}


IFX_INLINE Ifx_EVADC_GLOB_RES IfxEvadc_getGlobalResult(Ifx_EVADC *evadc)
{
    Ifx_EVADC_GLOB_RES tmpGlobalResult;

    tmpGlobalResult.U = evadc->GLOB.RES.U;

    return tmpGlobalResult;
}


IFX_INLINE float32 IfxEvadc_getGlobalSampleTime(Ifx_EVADC *evadc, uint8 inputClassNum, float32 analogFrequency)
{
    uint32 sampleTime = evadc->GLOB.ICLASS[inputClassNum].B.STCS;

    if (sampleTime > 16)
    {
        sampleTime = (sampleTime - 15) * 16;
    }

    return (float32)(IFXEVADC_SAMPLETIME_MIN + sampleTime) / analogFrequency;
}


IFX_INLINE IfxEvadc_ChannelNoiseReduction IfxEvadc_getGroupConversionMode(Ifx_EVADC_G *evadcG, uint8 inputClassNum)
{
    return (IfxEvadc_ChannelNoiseReduction)evadcG->ICLASS[inputClassNum].B.CMS;
}


IFX_INLINE void IfxEvadc_getGroupResult(Ifx_EVADC_G *group, Ifx_EVADC_G_RES *results, uint32 resultOffset, uint32 numResults)
{
    uint32 idx = 0;

    for (idx = 0; idx < numResults; idx++)
    {
        results[idx].U = group->RES[resultOffset + idx].U;
    }
}


IFX_INLINE float32 IfxEvadc_getGroupSampleTime(Ifx_EVADC_G *evadcG, uint8 inputClassNum, float32 analogFrequency)
{
    uint32 sampleTime = evadcG->ICLASS[inputClassNum].B.STCS;

    if (sampleTime > 16)
    {
        sampleTime = (sampleTime - 15) * 16;
    }

    return (float32)(IFXEVADC_SAMPLETIME_MIN + sampleTime) / analogFrequency;
}


IFX_INLINE uint8 IfxEvadc_getMasterIndex(Ifx_EVADC_G *evadcG)
{
    uint8 masterIndex = 0;
    masterIndex = evadcG->SYNCTR.B.STSEL;
    return masterIndex;
}


IFX_INLINE Ifx_EVADC_G_RES IfxEvadc_getResult(Ifx_EVADC_G *group, uint32 resultIdx)
{
    Ifx_EVADC_G_RES tmpResult;
    tmpResult.U = group->RES[resultIdx].U;

    return tmpResult;
}


IFX_INLINE volatile Ifx_SRC_SRCR *IfxEvadc_getSrcAddress(IfxEvadc_GroupId group, IfxEvadc_SrcNr index)
{
#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)
    if ((group >= IfxEvadc_GroupId_12) && (group < IfxEvadc_GroupId_global0)) //Condition for Fast Compare groups
    {
        IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, index == 0);                    /* For Fast Compare group, only SR0 is available.So only index = 0 is valid.So asserting warning in case index!=0 */
    }
#endif /*#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)*/

/*This is being done because the enum IfxEvadc_GroupId has count equal to group number and this count may not be continuous for different derivatives whereas IfxEvadc_cfg_srcAddresses[] has continuous positioning according to number of groups of each type available*/
    if ((group > 7) && (group < 12))
    {
        group = (IfxEvadc_GroupId)(group - (8 - IFXEVADC_NUM_ADC_PRIMARY_GROUPS));
    }
    else if ((group > 11) && (group < 20))
    {
        group = (IfxEvadc_GroupId)(group - (12 - IFXEVADC_NUM_ADC_PRIMARY_GROUPS - IFXEVADC_NUM_ADC_SECONDARY_GROUPS));
    }
    else if ((group == 20) || (group == 21))
    {
        group = (IfxEvadc_GroupId)(group - (20 - IFXEVADC_NUM_ADC_PRIMARY_GROUPS - IFXEVADC_NUM_ADC_SECONDARY_GROUPS - IFXEVADC_NUM_FAST_COMPARE_CHANNELS));
    }

    volatile Ifx_SRC_SRCR *base = IfxEvadc_cfg_srcAddresses[(group << 2) + index];

    return base;
}


IFX_INLINE boolean IfxEvadc_getStartupCalibrationStatus(Ifx_EVADC *evadc)
{
    return (boolean)evadc->GLOBCFG.B.SUCAL;
}


IFX_INLINE void IfxEvadc_selectIdlePrechargeLevel(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group, IfxEvadc_IdlePrecharge mode)
{
    IFX_UNUSED_PARAMETER(group);
#if defined(DEVICE_TC38EVOX) || defined(DEVICE_TC38X) || defined(DEVICE_TC39XB)
    evadcG->ANCFG.B.IPE = mode;
#elif defined(DEVICE_TC33XED) || defined(DEVICE_TC35X)
    if (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)
	{
		evadcG->ANCFG.B.IPE = mode;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)); /*Settings are only for Primary & Secondary groups*/
	}
#else
	if (((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || ((group > 7) && (group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))))
	{
		evadcG->ANCFG.B.IPE = mode;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, ((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || (group > 7 && group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))); /*Settings are only for Primary & Secondary groups*/
	}
#endif
}


IFX_INLINE void IfxEvadc_initEmuxPin(const IfxEvadc_Emux_Out *emux, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(emux->pin.port, emux->pin.pinIndex, outputMode, emux->select);
    IfxPort_setPinPadDriver(emux->pin.port, emux->pin.pinIndex, padDriver);
}


IFX_INLINE void IfxEvadc_initGxBflPin(const IfxEvadc_GxBfl_Out *gxBfl, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(gxBfl->pin.port, gxBfl->pin.pinIndex, outputMode, gxBfl->select);
    IfxPort_setPinPadDriver(gxBfl->pin.port, gxBfl->pin.pinIndex, padDriver);
}


IFX_INLINE void IfxEvadc_initialiseAdcConverterClock(Ifx_EVADC *evadc, Ifx_EVADC_G *evadcG, IfxEvadc_ClockDividerFactor converterClockDivider)
{
    IFX_UNUSED_PARAMETER(evadc);
    evadcG->ANCFG.B.DIVA = converterClockDivider;
}


IFX_INLINE void IfxEvadc_initiateStartupCalibration(Ifx_EVADC *evadc)
{
    evadc->GLOBCFG.B.SUCAL = 1;
}


IFX_INLINE void IfxEvadc_enableInputBuffer(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group)
{
    IFX_UNUSED_PARAMETER(group);
#if defined(DEVICE_TC38EVOX) || defined(DEVICE_TC38X) || defined(DEVICE_TC39XB)
    evadcG->ANCFG.B.BE = 1;
#elif defined(DEVICE_TC33XED) || defined(DEVICE_TC35X)
    if (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)
	{
		evadcG->ANCFG.B.BE = 1;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)); /*Settings are only for Primary & Secondary groups*/
	}
#else
	if (((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || ((group > 7) && (group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))))
	{
		evadcG->ANCFG.B.BE = 1;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, ((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || (group > 7 && group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))); /*Settings are only for Primary & Secondary groups*/
	}
#endif
}

#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)
IFX_INLINE boolean IfxEvadc_isFastCompareNewResultAvailable(Ifx_EVADC_FC *evadcFC)
{
    boolean validFlag;

    if (evadcFC->FCBFL.B.VF == 1)
    {
        validFlag = TRUE;
    }
    else
    {
        validFlag = FALSE;
    }

    return validFlag;
}
#endif /*#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)*/

IFX_INLINE boolean IfxEvadc_isModuleSuspended(Ifx_EVADC *evadc)
{
    Ifx_EVADC_OCS ocs;

    // read the status
    ocs.U = evadc->OCS.U;

    // return the status
    return ocs.B.SUSSTA;
}


IFX_INLINE void IfxEvadc_setReferencePrechargeDuration(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group, IfxEvadc_ReferencePrechargeControl duration)
{
    IFX_UNUSED_PARAMETER(group);
#if defined(DEVICE_TC38EVOX) || defined(DEVICE_TC38X) || defined(DEVICE_TC39XB)
    evadcG->ANCFG.B.RPC = duration;
#elif defined(DEVICE_TC33XED) || defined(DEVICE_TC35X)
    if (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)
	{
		evadcG->ANCFG.B.RPC = duration;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)); /*Settings are only for Primary & Secondary groups*/
	}
#else
	if (((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || ((group > 7) && (group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))))
	{
		evadcG->ANCFG.B.RPC = duration;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, ((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || (group > 7 && group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))); /*Settings are only for Primary & Secondary groups*/
	}
#endif
}


IFX_INLINE void IfxEvadc_enableReferencePrecharge(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group)
{
    IFX_UNUSED_PARAMETER(group);
#if defined(DEVICE_TC38EVOX) || defined(DEVICE_TC38X) || defined(DEVICE_TC39XB)
    evadcG->ANCFG.B.RPE = 1;
#elif defined(DEVICE_TC33XED) || defined(DEVICE_TC35X)
    if (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)
	{
		evadcG->ANCFG.B.RPE = 1;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)); /*Settings are only for Primary & Secondary groups*/
	}
#else
	if (((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || ((group > 7) && (group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))))
	{
		evadcG->ANCFG.B.RPE = 1;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, ((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || (group > 7 && group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))); /*Settings are only for Primary & Secondary groups*/
	}
#endif
}


IFX_INLINE void IfxEvadc_resetGroup(Ifx_EVADC_G *evadcG)
{
    evadcG->ARBCFG.B.ANONC = IfxEvadc_AnalogConverterMode_off;   /* turn off group */
}


IFX_INLINE void IfxEvadc_setSampleSynchronizationMode(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group, IfxEvadc_SampleSynchronization mode)
{
    IFX_UNUSED_PARAMETER(group);
#if defined(DEVICE_TC38EVOX) || defined(DEVICE_TC38X) || defined(DEVICE_TC39XB)
    evadcG->ANCFG.B.SSE = mode;
#elif defined(DEVICE_TC33XED) || defined(DEVICE_TC35X)
    if (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)
	{
		evadcG->ANCFG.B.SSE = mode;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)); /*Settings are only for Primary & Secondary groups*/
	}
#else
	if (((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || ((group > 7) && (group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))))
	{
		evadcG->ANCFG.B.SSE = mode;
	}

	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, ((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || (group > 7 && group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))); /*Settings are only for Primary & Secondary groups*/
	}
#endif
}


IFX_INLINE void IfxEvadc_selectDoubleClockForMSBConversion(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group, IfxEvadc_MsbConversionTime mode)
{
    IFX_UNUSED_PARAMETER(group);
#if defined(DEVICE_TC38EVOX) || defined(DEVICE_TC38X) || defined(DEVICE_TC39XB)
    evadcG->ANCFG.B.DCMSB = mode;
#elif defined(DEVICE_TC33XED)  || defined(DEVICE_TC35X)
    if (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)
	{
		evadcG->ANCFG.B.DCMSB = mode;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)); /*Settings are only for Primary & Secondary groups*/
	}
#else
	if (((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || ((group > 7) && (group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))))
	{
		evadcG->ANCFG.B.DCMSB = mode;
	}

	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, ((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || (group > 7 && group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))); /*Settings are only for Primary & Secondary groups*/
	}
#endif
}

#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)
IFX_INLINE void IfxEvadc_selectFastCompareBoundaryFlagActivationMode(Ifx_EVADC_FC *evadcFC, IfxEvadc_BoundaryFlagActivationMode mode)
{
    evadcFC->FCBFL.B.BFA = mode;
}


IFX_INLINE void IfxEvadc_selectFastCompareBoundaryFlagNodePointer(Ifx_EVADC_FC *evadcFC, IfxEvadc_BoundaryFlagNodePointer nodePointer)
{
    evadcFC->FCBFL.B.BFLNP = nodePointer;
}
#endif /*#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)*/

IFX_INLINE void IfxEvadc_setAnalogConvertControl(Ifx_EVADC_G *evadcG, IfxEvadc_AnalogConverterMode analogConverterMode)
{
    evadcG->ARBCFG.B.ANONC = analogConverterMode;
}


IFX_INLINE void IfxEvadc_setAnalogInputPrechargeControlEMUX(Ifx_EVADC_G *evadcG, uint8 inputClassNum, IfxEvadc_AnalogInputPrechargeControl mode)
{
    evadcG->ICLASS[inputClassNum].B.AIPE = mode;
}


IFX_INLINE void IfxEvadc_setAnalogInputPrechargeControlStandard(Ifx_EVADC_G *evadcG, uint8 inputClassNum, IfxEvadc_AnalogInputPrechargeControl mode)
{
    evadcG->ICLASS[inputClassNum].B.AIPS = mode;
}


IFX_INLINE void IfxEvadc_setBoundaryMode(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, IfxEvadc_BoundaryExtension boundaryMode)
{
    evadcG->CHCTR[channelIndex].B.BNDSELX = boundaryMode;
}


IFX_INLINE void IfxEvadc_setChannelEventNodePointer0(Ifx_EVADC_G *evadcG, IfxEvadc_SrcNr channelSrcNr, IfxEvadc_ChannelId channel)
{
    evadcG->CEVNP0.U &= ~(IFX_EVADC_G_CEVNP0_CEV0NP_MSK << (channel * 4));
    evadcG->CEVNP0.U |= (channelSrcNr << (channel * 4));
}

#if !defined(DEVICE_TC33XED) && !defined (DEVICE_TC35X)
IFX_INLINE void IfxEvadc_setChannelEventNodePointer1(Ifx_EVADC_G *evadcG, IfxEvadc_SrcNr channelSrcNr, IfxEvadc_ChannelId channel)
{
    evadcG->CEVNP1.U &= ~(IFX_EVADC_G_CEVNP0_CEV1NP_MSK << (channel * 4));
    evadcG->CEVNP1.U |= (channelSrcNr << (channel * 4));
}
#endif

IFX_INLINE void IfxEvadc_setChannelInputClass(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, IfxEvadc_InputClasses inputClass)
{
    evadcG->CHCTR[channelIndex].B.ICLSEL = inputClass;
}


IFX_INLINE void IfxEvadc_setChannelLimitCheckMode(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, IfxEvadc_LimitCheck limitCheck)
{
    evadcG->CHCTR[channelIndex].B.CHEVMODE = limitCheck;
}


IFX_INLINE void IfxEvadc_setDataModificationMode(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelResult resultRegister, IfxEvadc_DataModificationMode mode)
{
    evadcG->RCR[resultRegister].B.DMM = mode;
}


IFX_INLINE void IfxEvadc_setDataReductionControlMode(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelResult resultRegister, uint32 mode)
{
    evadcG->RCR[resultRegister].B.DRCTR = mode;
}


IFX_INLINE void IfxEvadc_setEmuxGlobalConversionMode(Ifx_EVADC *evadc, uint8 inputClassNum, IfxEvadc_ChannelNoiseReduction conversionMode)
{
    evadc->GLOB.ICLASS[inputClassNum].B.CME = conversionMode;
}


IFX_INLINE void IfxEvadc_setEmuxGlobalSampleTime(Ifx_EVADC *evadc, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime)
{
    evadc->GLOB.ICLASS[inputClassNum].B.STCE = IfxEvadc_calculateSampleTime(analogFrequency, sampleTime);
}


IFX_INLINE void IfxEvadc_setEmuxGroupConversionMode(Ifx_EVADC_G *evadcG, uint8 inputClassNum, IfxEvadc_ChannelNoiseReduction conversionMode)
{
    evadcG->ICLASS[inputClassNum].B.CME = conversionMode;
}


IFX_INLINE void IfxEvadc_setEmuxGroupSampletime(Ifx_EVADC_G *evadcG, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime)
{
    evadcG->ICLASS[inputClassNum].B.STCE = IfxEvadc_calculateSampleTime(analogFrequency, sampleTime);
}


IFX_INLINE void IfxEvadc_setEmuxInterfaceForGroup(Ifx_EVADC *evadc, IfxEvadc_EmuxInterface emuxInterface, IfxEvadc_GroupId group)
{
    if (emuxInterface == IfxEvadc_EmuxInterface_0)
    {
        evadc->EMUXSEL.B.EMUXGRP0 = group;
    }
    else
    {
        evadc->EMUXSEL.B.EMUXGRP1 = group;
    }
}

#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)
IFX_INLINE void IfxEvadc_setFastCompareAnalogClockSynchronizationDelay(Ifx_EVADC_FC *evadcFC, IfxEvadc_FastCompareAnalogClockSynchronizationDelay delay)
{
    Ifx_EVADC_FC_FCM tempFCM;
    tempFCM.U       = evadcFC->FCM.U;
    tempFCM.B.FCMWC = 1;  /*Enabling write permission to FCM.B.ACSD*/
    tempFCM.B.ACSD  = delay;
    evadcFC->FCM.U  = tempFCM.U;
}


IFX_INLINE void IfxEvadc_setFastCompareAnalogConverter(Ifx_EVADC_FC *evadcFC, IfxEvadc_FastCompareAnalogConverterControl mode)
{
    Ifx_EVADC_FC_FCM tempFCM;
    tempFCM.U       = evadcFC->FCM.U;
    tempFCM.B.FCMWC = 1;  /*Enabling write permission to FCM.B.ANON*/
    tempFCM.B.ANON  = mode;
    evadcFC->FCM.U  = tempFCM.U;
}


IFX_INLINE void IfxEvadc_setFastCompareAnalogInputPrechargeControl(Ifx_EVADC_FC *evadcFC, IfxEvadc_AnalogInputPrechargeControl mode)
{
    Ifx_EVADC_FC_FCCTRL tempFCCTRL;
    tempFCCTRL.U      = evadcFC->FCCTRL.U;
    tempFCCTRL.B.CPWC = 1; /*Enabling write permission to FCCTRL.B.AIPF*/
    tempFCCTRL.B.AIPF = mode;
    evadcFC->FCCTRL.U = tempFCCTRL.U;
}


IFX_INLINE void IfxEvadc_setFastCompareAnalogInternalClockDivider(Ifx_EVADC_FC *evadcFC, IfxEvadc_ClockDividerFactor divider)
{
    Ifx_EVADC_FC_FCCTRL tempFCCTRL;
    tempFCCTRL.U      = evadcFC->FCCTRL.U;
    tempFCCTRL.B.CPWC = 1; /*Enabling write permission to FCCTRL.B.DIVA*/
    tempFCCTRL.B.DIVA = divider;
    evadcFC->FCCTRL.U = tempFCCTRL.U;
}


IFX_INLINE void IfxEvadc_setFastCompareAutomaticUpdateMode(Ifx_EVADC_FC *evadcFC, IfxEvadc_FastCompareAutomaticUpdate mode)
{
    Ifx_EVADC_FC_FCM tempFCM;
    tempFCM.U       = evadcFC->FCM.U;
    tempFCM.B.FCMWC = 1;  /*Enabling write permission to FCM.B.AUE*/
    tempFCM.B.AUE   = mode;
    evadcFC->FCM.U  = tempFCM.U;
}


IFX_INLINE void IfxEvadc_setFastCompareChannelEventMode(Ifx_EVADC_FC *evadcFC, IfxEvadc_ChannelEventMode mode)
{
    Ifx_EVADC_FC_FCCTRL tempFCCTRL;
    tempFCCTRL.U          = evadcFC->FCCTRL.U;
    tempFCCTRL.B.CPWC     = 1; /*Enabling write permission to FCCTRL.B.CHEVMODE*/
    tempFCCTRL.B.CHEVMODE = mode;
    evadcFC->FCCTRL.U     = tempFCCTRL.U;
}


IFX_INLINE void IfxEvadc_setFastCompareExternalTriggerPolarity(Ifx_EVADC_FC *evadcFC, IfxEvadc_ExternalTriggerPolarity mode)
{
    Ifx_EVADC_FC_FCCTRL tempFCCTRL;
    tempFCCTRL.U       = evadcFC->FCCTRL.U;
    tempFCCTRL.B.XTWC  = 1; /*Enabling write permission to FCCTRL.B.XTPOL*/
    tempFCCTRL.B.XTPOL = mode;
    evadcFC->FCCTRL.U  = tempFCCTRL.U;
}


IFX_INLINE void IfxEvadc_setFastCompareGateOperatingMode(Ifx_EVADC_FC *evadcFC, IfxEvadc_GateOperatingMode mode)
{
    Ifx_EVADC_FC_FCCTRL tempFCCTRL;
    tempFCCTRL.U        = evadcFC->FCCTRL.U;
    tempFCCTRL.B.XTWC   = 1; /*Enabling write permission to FCCTRL.B.GTMODE*/
    tempFCCTRL.B.GTMODE = mode;
    evadcFC->FCCTRL.U   = tempFCCTRL.U;
}


IFX_INLINE void IfxEvadc_setFastCompareRampDirection(Ifx_EVADC_FC *evadcFC, IfxEvadc_RampDirection rampDirection)
{
    Ifx_EVADC_FC_FCM tempFCM;
    tempFCM.U        = evadcFC->FCM.U;
    tempFCM.B.FCMWC  = 1; /*Enabling write permission to FCM.B.FCRDIR*/
    tempFCM.B.FCRDIR = rampDirection;
    evadcFC->FCM.U   = tempFCM.U;
}


IFX_INLINE void IfxEvadc_setFastCompareReferenceValue(Ifx_EVADC_FC *evadcFC, uint16 referenceValue)
{
    if (evadcFC->FCM.B.AUE == IfxEvadc_FastCompareAutomaticUpdate_sw)
    {
        evadcFC->FCM.B.FCREF = referenceValue;
    }
    else
    {
        IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, evadcFC->FCM.B.AUE == IfxEvadc_FastCompareAutomaticUpdate_sw); /* Writing into FCM.B.FCREF requires FCM.B.AUE = 0 */
    }
}


IFX_INLINE void IfxEvadc_setFastCompareRunControl(Ifx_EVADC_FC *evadcFC, IfxEvadc_FastCompareRunControl mode)
{
    Ifx_EVADC_FC_FCM tempFCM;
    tempFCM.U         = evadcFC->FCM.U;
    tempFCM.B.FCMWC   = 1; /*Enabling write permission to FCM.B.RUNCOMP*/
    tempFCM.B.RUNCOMP = mode;
    evadcFC->FCM.U    = tempFCM.U;
}


IFX_INLINE void IfxEvadc_setFastCompareRunRampControl(Ifx_EVADC_FC *evadcFC, IfxEvadc_RampRunControl rampStartMode)
{
    Ifx_EVADC_FC_FCM tempFCM;
    tempFCM.U         = evadcFC->FCM.U;
    tempFCM.B.FCMWC   = 1; /*Enabling write permission to FCM.B.RUNRAMP*/
    tempFCM.B.RUNRAMP = rampStartMode;
    evadcFC->FCM.U    = tempFCM.U;
}


IFX_INLINE void IfxEvadc_setFastCompareSampleTimeControl(Ifx_EVADC_FC *evadcFC, uint8 additionalCycles)
{
    uint32 stcf = 0;

    if (additionalCycles > 15)
    {
/*
 *
 * Allowed values for additional clock cycles are as follows:
 *
 * Additional Clock Cycles = FCCTRL.B.STCF ;  STCF < 16
 * Additional Clock Cycles = (FCCTRL.B.STCF - 15) * 16; STCF>=16
 */

        IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, (additionalCycles % 16 == 0));
    }

    if (additionalCycles > 15)
    {
        stcf = (additionalCycles >> 4) + 15;
    }
    else
    {
        stcf = additionalCycles;
    }

    Ifx_EVADC_FC_FCCTRL tempFCCTRL;
    tempFCCTRL.U      = evadcFC->FCCTRL.U;
    tempFCCTRL.B.CPWC = 1; /*Enabling write permission to FCCTRL.B.STFC*/
    tempFCCTRL.B.STCF = stcf;
    evadcFC->FCCTRL.U = tempFCCTRL.U;
}


IFX_INLINE void IfxEvadc_setFastCompareServiceRequestGeneration(Ifx_EVADC_FC *evadcFC, IfxEvadc_FastCompareServiceRequestGeneration mode)
{
    Ifx_EVADC_FC_FCM tempFCM;
    tempFCM.U       = evadcFC->FCM.U;
    tempFCM.B.FCMWC = 1;  /*Enabling write permission to FCM.B.SRG*/
    tempFCM.B.SRG   = mode;
    evadcFC->FCM.U  = tempFCM.U;
}


IFX_INLINE void IfxEvadc_setFastCompareTriggerInterval(Ifx_EVADC_FC *evadcFC, uint8 interval)
{
    Ifx_EVADC_FC_FCM tempFCM;
    tempFCM.U        = evadcFC->FCM.U;
    tempFCM.B.FCMWC  = 1; /*Enabling write permission to FCM.B.FCTRIV*/
    tempFCM.B.FCTRIV = interval;
    evadcFC->FCM.U   = tempFCM.U;
}


IFX_INLINE void IfxEvadc_setFastCompareTriggerOperatingMode(Ifx_EVADC_FC *evadcFC, IfxEvadc_TriggerOperatingMode mode)
{
    Ifx_EVADC_FC_FCCTRL tempFCCTRL;
    tempFCCTRL.U        = evadcFC->FCCTRL.U;
    tempFCCTRL.B.XTWC   = 1; /*Enabling write permission to FCCTRL.B.XTMODE*/
    tempFCCTRL.B.XTMODE = mode;
    evadcFC->FCCTRL.U   = tempFCCTRL.U;
}
#endif /*#if !defined(DEVICE_TC33XED) && !defined(DEVICE_TC33X) && !defined (DEVICE_TC35X)*/

IFX_INLINE void IfxEvadc_setFifoMode(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelResult resultRegister, IfxEvadc_FifoMode mode)
{
    evadcG->RCR[resultRegister].B.FEN = mode;
}


IFX_INLINE void IfxEvadc_setGlobalConversionMode(Ifx_EVADC *evadc, uint8 InputClassNum, IfxEvadc_ChannelNoiseReduction conversionMode)
{
    evadc->GLOB.ICLASS[InputClassNum].B.CMS = conversionMode;
}


IFX_INLINE void IfxEvadc_setGlobalSampleTime(Ifx_EVADC *evadc, uint8 groupInputClassNum, float32 analogFrequency, float32 sampleTime)
{
    evadc->GLOB.ICLASS[groupInputClassNum].B.STCS = IfxEvadc_calculateSampleTime(analogFrequency, sampleTime);
}


IFX_INLINE void IfxEvadc_setGroupConversionMode(Ifx_EVADC_G *evadcG, uint8 inputClassNum, IfxEvadc_ChannelNoiseReduction conversionMode)
{
    evadcG->ICLASS[inputClassNum].B.CMS = conversionMode;
}


IFX_INLINE void IfxEvadc_setGroupConversionModeEMUX(Ifx_EVADC_G *evadcG, uint8 inputClassNum, IfxEvadc_ChannelNoiseReductionEMUX conversionMode)
{
    evadcG->ICLASS[inputClassNum].B.CME = conversionMode;
}


IFX_INLINE void IfxEvadc_setGroupSampleTime(Ifx_EVADC_G *evadcG, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime)
{
    evadcG->ICLASS[inputClassNum].B.STCS = IfxEvadc_calculateSampleTime(analogFrequency, sampleTime);
}


IFX_INLINE void IfxEvadc_setGroupSampleTimeEMUX(Ifx_EVADC_G *evadcG, uint8 inputClassNum, float32 analogFrequency, float32 sampleTime)
{
    evadcG->ICLASS[inputClassNum].B.STCE = IfxEvadc_calculateSampleTime(analogFrequency, sampleTime);
}


IFX_INLINE void IfxEvadc_setLowerBoundary(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, IfxEvadc_BoundarySelection lowerBoundary)
{
    evadcG->CHCTR[channelIndex].B.BNDSELL = lowerBoundary;
}


IFX_INLINE void IfxEvadc_setMasterIndex(Ifx_EVADC_G *evadcG, uint8 masterIndex)
{
    evadcG->SYNCTR.B.STSEL = masterIndex;
    evadcG->SYNCTR.U      |= (0x00000008U << masterIndex);
}


IFX_INLINE void IfxEvadc_setReferenceInput(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, IfxEvadc_ChannelReference reference)
{
    evadcG->CHCTR[channelIndex].B.REFSEL = reference;
}


IFX_INLINE void IfxEvadc_setResultNodeEventPointer0(Ifx_EVADC_G *evadcG, IfxEvadc_SrcNr resultSrcNr, IfxEvadc_ChannelResult resultRegister)
{
    evadcG->REVNP0.U &= ~(IFX_EVADC_GLOB_EVNP_REV0NP_MSK << (resultRegister * 4));
    evadcG->REVNP0.U |= (resultSrcNr << (resultRegister * 4));
}


IFX_INLINE void IfxEvadc_setResultNodeEventPointer1(Ifx_EVADC_G *evadcG, IfxEvadc_SrcNr resultSrcNr, IfxEvadc_ChannelResult resultRegister)
{
    evadcG->REVNP1.U &= ~(IFX_EVADC_G_REVNP1_REV8NP_MSK << ((resultRegister - IfxEvadc_ChannelResult_8) * 4));
    evadcG->REVNP1.U |= (resultSrcNr << ((resultRegister - IfxEvadc_ChannelResult_8) * 4));
}


IFX_INLINE void IfxEvadc_setResultPosition(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, boolean rightAlignedStorage)
{
    evadcG->CHCTR[channelIndex].B.RESPOS = rightAlignedStorage;
}


IFX_INLINE void IfxEvadc_setSleepMode(Ifx_EVADC *evadc, IfxEvadc_SleepMode mode)
{
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(passwd);
    evadc->CLC.B.EDIS = mode;
    IfxScuWdt_setCpuEndinit(passwd);
}


IFX_INLINE void IfxEvadc_setSuspendMode(Ifx_EVADC *evadc, IfxEvadc_SuspendMode mode)
{
    Ifx_EVADC_OCS ocs;

    // remove protection and configure the suspend mode.
    ocs.B.SUS_P  = 1;
    ocs.B.SUS    = mode;
    evadc->OCS.U = ocs.U;
}


IFX_INLINE void IfxEvadc_setSyncRequest(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, boolean synchonize)
{
    evadcG->CHCTR[channelIndex].B.SYNC = synchonize;
}


IFX_INLINE void IfxEvadc_setUpperBoundary(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, IfxEvadc_BoundarySelection upperBoundary)
{
    evadcG->CHCTR[channelIndex].B.BNDSELU = upperBoundary;
}


IFX_INLINE void IfxEvadc_spreadEarlySamplePointEMUXConversions(Ifx_EVADC_G *evadcG, uint8 inputClassNum, IfxEvadc_SpreadEarlySamplePointEMUXConversionsMode mode)
{
    evadcG->ICLASS[inputClassNum].B.SESPE = mode;
}


IFX_INLINE void IfxEvadc_spreadEarlySamplePointStandardConversions(Ifx_EVADC_G *evadcG, uint8 inputClassNum, IfxEvadc_SpreadEarlySamplePointStandardConversionsMode mode)
{
    evadcG->ICLASS[inputClassNum].B.SESPS = mode;
}


IFX_INLINE void IfxEvadc_startQueue(Ifx_EVADC_G *group, IfxEvadc_RequestSource sourceType)
{
    switch (sourceType)
    {
    case IfxEvadc_RequestSource_queue0:
        group->Q[0].QMR.B.TREV = 1;
        break;
    case IfxEvadc_RequestSource_queue1:
        group->Q[1].QMR.B.TREV = 1;
        break;
    case IfxEvadc_RequestSource_queue2:
        group->Q[2].QMR.B.TREV = 1;
        break;
    }
}


IFX_INLINE void IfxEvadc_storeGroupResult(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channelIndex, IfxEvadc_ChannelResult resultRegister)
{
    evadcG->CHCTR[channelIndex].B.RESREG = resultRegister;
}


IFX_INLINE void IfxEvadc_disableReferencePrecharge(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group)
{
    IFX_UNUSED_PARAMETER(group);
#if defined(DEVICE_TC38EVOX) || defined(DEVICE_TC38X) || defined(DEVICE_TC39XB)
    evadcG->ANCFG.B.RPE = 0;
#elif defined(DEVICE_TC33XED) || defined(DEVICE_TC35X)
    if (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)
	{
		evadcG->ANCFG.B.RPE = 0;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)); /*Settings are only for Primary & Secondary groups*/
	}
#else
	if (((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || ((group > 7) && (group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))))
	{
		evadcG->ANCFG.B.RPE = 0;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, ((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || (group > 7 && group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))); /*Settings are only for Primary & Secondary groups*/
	}
#endif
}


IFX_INLINE void IfxEvadc_disableInputBuffer(Ifx_EVADC_G *evadcG, IfxEvadc_GroupId group)
{
    IFX_UNUSED_PARAMETER(group);
#if defined(DEVICE_TC38EVOX) || defined(DEVICE_TC38X) || defined(DEVICE_TC39XB)
    evadcG->ANCFG.B.BE = 0;
#elif defined(DEVICE_TC33XED) || defined(DEVICE_TC35X)
    if (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)
	{
		evadcG->ANCFG.B.BE = 0;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, (group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS)); /*Settings are only for Primary & Secondary groups*/
	}
#else
	if (((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || ((group > 7) && (group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))))
	{
		evadcG->ANCFG.B.BE = 0;
	}
	else
	{
		IFX_ASSERT(IFX_VERBOSE_LEVEL_WARNING, ((group < IFXEVADC_NUM_ADC_PRIMARY_GROUPS) || (group > 7 && group < (8 + IFXEVADC_NUM_ADC_SECONDARY_GROUPS)))); /*Settings are only for Primary & Secondary groups*/
	}
#endif
}


IFX_INLINE boolean IfxEvadc_isModuleEnabled(Ifx_EVADC *evadc)
{
    return evadc->CLC.B.DISS == 0;
}


IFX_INLINE void IfxEvadc_enableStartupCalibration(Ifx_EVADC *evadc)
{
    evadc->GLOBCFG.B.SUCAL = 0x1U;
}


IFX_INLINE void IfxEvadc_selectQueueGatingMode(Ifx_EVADC_G *evadcG, IfxEvadc_RequestSource queue, IfxEvadc_GatingMode gatingMode)
{
    switch (queue)
    {
    case IfxEvadc_RequestSource_queue0:
        evadcG->Q[0].QMR.B.ENGT = gatingMode;
        break;
    case IfxEvadc_RequestSource_queue1:
        evadcG->Q[1].QMR.B.ENGT = gatingMode;
        break;
    case IfxEvadc_RequestSource_queue2:
        evadcG->Q[2].QMR.B.ENGT = gatingMode;
        break;
    }
}


IFX_INLINE void IfxEvadc_setChannelRequest(Ifx_EVADC_G *evadcG, IfxEvadc_RequestSource queue, IfxEvadc_ChannelId channel)
{
    switch (queue)
    {
    case IfxEvadc_RequestSource_queue0:
        evadcG->Q[0].QINR.B.REQCHNR = channel;
        break;
    case IfxEvadc_RequestSource_queue1:
        evadcG->Q[1].QINR.B.REQCHNR = channel;
        break;
    case IfxEvadc_RequestSource_queue2:
        evadcG->Q[2].QINR.B.REQCHNR = channel;
        break;
    }
}


IFX_INLINE void IfxEvadc_configureIclass(Ifx_EVADC_G *evadcG, uint8 inputClassNum, uint32 value)
{
    evadcG->ICLASS[inputClassNum].U = value;
}


IFX_INLINE volatile uint32 *IfxEvadc_getResultRegisterAddress(Ifx_EVADC_G *evadcG, IfxEvadc_ChannelId channel)
{
    return (volatile uint32 *)&(evadcG->RES[channel].U);
}


IFX_INLINE void IfxEvadc_setGlobalBoundary(Ifx_EVADC *evadc, uint16 bound0, uint16 bound1)
{
    Ifx_EVADC_G_BOUND gBound;
    gBound.U            = evadc->GLOB.BOUND.U;

    gBound.B.BOUNDARY0  = bound0;
    gBound.B.BOUNDARY1  = bound1;

    evadc->GLOB.BOUND.U = gBound.U;
}


IFX_INLINE void IfxEvadc_setGroupBoundary(Ifx_EVADC_G *evadcG, uint16 bound0, uint16 bound1)
{
    Ifx_EVADC_G_BOUND grpBound;
    grpBound.U           = evadcG->BOUND.U;
    grpBound.B.BOUNDARY0 = bound0;
    grpBound.B.BOUNDARY1 = bound1;
    evadcG->BOUND.U      = grpBound.U;
}


#endif /* IFXEVADC_H */
