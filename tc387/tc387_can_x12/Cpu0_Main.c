/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "IfxCan.h"
#include "IfxCan_Can.h"
#include "IfxCpu.h"
#include "IfxCpu_Irq.h"
#include "IfxPort.h"
#include "IfxScuWdt.h"
#include "Ifx_Cfg_Ssw.h"
#include "Ifx_Types.h"

IFX_ALIGN(4) IfxCpu_syncEvent cpuSyncEvent = 0;

#define CAN_PRIORITY 110
#define STD_FILTER_NUM 1
#define EXT_FILTER_NUM 1

// channel 0~11
typedef enum {
  CAN0 = 0,
  CAN1,
  CAN2,
  CAN3,
  CAN4,
  CAN5,
  CAN6,
  CAN7,
  CAN8,
  CAN9,
  CAN10,
  CAN11,
  CAN_NUM
} canChannel;

// clang-format off
static const IfxCan_Can_Pins can_pins[CAN_NUM] = {
    {&IfxCan_TXD00_P02_0_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD00A_P02_1_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD01_P15_2_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD01A_P15_3_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD02_P32_5_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD02C_P32_6_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD03_P20_10_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD03E_P20_9_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD10_P00_0_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD10A_P00_1_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD11_P00_4_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD11B_P00_5_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD12_P20_7_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD12A_P20_6_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD13_P33_4_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD13B_P33_5_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD20_P34_1_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD20C_P34_2_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD21_P20_3_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD21C_P20_0_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD22_P33_12_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD22A_P33_13_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
    {&IfxCan_TXD23_P14_9_OUT, IfxPort_OutputMode_pushPull, &IfxCan_RXD23A_P14_10_IN, IfxPort_InputMode_pullUp, IfxPort_PadDriver_cmosAutomotiveSpeed4},
};
// clang-format on

static IfxCan_Filter can_std_default_filter[CAN_NUM][STD_FILTER_NUM] = {{
    {.number = 0,
     .elementConfiguration = IfxCan_FilterElementConfiguration_storeInRxFifo0,
     .type = IfxCan_FilterType_classic,
     .id1 = 0,
     .id2 = 0,
     .rxBufferOffset = IfxCan_RxBufferId_0},
}};
static IfxCan_Filter can_ext_default_filter[CAN_NUM][EXT_FILTER_NUM] = {{
    {.number = 0,
     .elementConfiguration = IfxCan_FilterElementConfiguration_storeInRxFifo0,
     .type = IfxCan_FilterType_classic,
     .id1 = 0,
     .id2 = 0,
     .rxBufferOffset = IfxCan_RxBufferId_0},
}};

typedef struct {
  canChannel channel;
  IfxCan_Can_Config config;         /* CAN module configuration structure */
  IfxCan_Can module;                /* CAN module handle                  */
  IfxCan_Can_Node node;             /* CAN node handle data structure     */
  IfxCan_Can_NodeConfig nodeConfig; /* CAN node configuration structure   */
  IfxCan_Filter filter;             /* CAN filter configuration structure */
  IfxCan_Message txMsg;             /* Transmitted CAN message structure  */
  IfxCan_Message rxMsg;             /* Received CAN message structure     */
  uint8 txData[64];                 /* Transmitted CAN data array         */
  uint8 rxData[64];                 /* Received CAN data array            */
  boolean busOff;                   /* Bus off status                     */
  void (*can_rx_callback)(canChannel channel, IfxCan_Message *msg);
  void (*can_tx_callback)(canChannel channel, IfxCan_Message *msg);
  void (*can_error_callback)(canChannel channel, IfxCan_Message *msg);
} mcmcanType;

mcmcanType can[CAN_NUM];

/* 记录每个物理 CAN 模块(CAN0/CAN1)是否已经完成初始化，避免后续节点重复 reset 模块
 * 组0: 逻辑通道 CAN0~CAN3 -> 硬件 MODULE_CAN0
 * 组1: 逻辑通道 CAN4~CAN7 -> 硬件 MODULE_CAN1
 * 组2: 逻辑通道 CAN8~CAN11 -> 硬件 MODULE_CAN2
 */
static boolean g_canModuleInitialized[3] = {FALSE, FALSE, FALSE};

#define CAN_RX_ISR(x, tos, priority)                                           \
  IFX_INTERRUPT(isr_canrx_##x, tos, priority);                                 \
  void isr_canrx_##x(void) {                                                   \
    while (IfxCan_Can_getRxFifo0FillLevel(&can[x].node)) {                     \
      IfxCan_Node_clearInterruptFlag(can[x].node.node,                         \
                                     IfxCan_Interrupt_rxFifo0NewMessage);      \
      can[x].rxMsg.readFromRxFifo0 = TRUE;                                     \
      IfxCan_Can_readMessage(&can[x].node, &can[x].rxMsg,                      \
                             (uint32 *)&can[x].rxData);                        \
      if (can[x].can_rx_callback != NULL) {                                    \
        can[x].can_rx_callback(can[x].channel, &can[x].rxMsg);                 \
      }                                                                        \
    }                                                                          \
  }

#define CAN_TX_ISR(x, tos, priority)                                           \
  IFX_INTERRUPT(isr_cantx_##x, tos, priority);                                 \
  void isr_cantx_##x(void) {                                                   \
    IfxCan_Node_clearInterruptFlag(can[x].node.node,                           \
                                   IfxCan_Interrupt_transmissionCompleted);    \
    if (can[x].can_tx_callback != NULL) {                                      \
      can[x].can_tx_callback(can[x].channel, &can[x].txMsg);                   \
    }                                                                          \
  }

#define CAN_BUSOFF_ISR(x, tos, priority)                                       \
  IFX_INTERRUPT(isr_canbo_##x, tos, priority);                                 \
  void isr_canbo_##x(void) {                                                   \
    IfxCan_Node_clearInterruptFlag(can[x].node.node,                           \
                                   IfxCan_Interrupt_busOffStatus);             \
    can[x].busOff = TRUE;                                                      \
    if (can[x].can_error_callback != NULL) {                                   \
      can[x].can_error_callback(can[x].channel, NULL);                         \
    }                                                                          \
  }

CAN_RX_ISR(0, 0, CAN_PRIORITY + 0);
CAN_TX_ISR(0, 0, CAN_PRIORITY + CAN_NUM + 0);
CAN_BUSOFF_ISR(0, 0, CAN_PRIORITY + 2 * CAN_NUM + 0);
CAN_RX_ISR(1, 0, CAN_PRIORITY + 1);
CAN_TX_ISR(1, 0, CAN_PRIORITY + CAN_NUM + 1);
CAN_BUSOFF_ISR(1, 0, CAN_PRIORITY + 2 * CAN_NUM + 1);
CAN_RX_ISR(2, 0, CAN_PRIORITY + 2);
CAN_TX_ISR(2, 0, CAN_PRIORITY + CAN_NUM + 2);
CAN_BUSOFF_ISR(2, 0, CAN_PRIORITY + 2 * CAN_NUM + 2);
CAN_RX_ISR(3, 0, CAN_PRIORITY + 3);
CAN_TX_ISR(3, 0, CAN_PRIORITY + CAN_NUM + 3);
CAN_BUSOFF_ISR(3, 0, CAN_PRIORITY + 2 * CAN_NUM + 3);
CAN_RX_ISR(4, 0, CAN_PRIORITY + 4);
CAN_TX_ISR(4, 0, CAN_PRIORITY + CAN_NUM + 4);
CAN_BUSOFF_ISR(4, 0, CAN_PRIORITY + 2 * CAN_NUM + 4);
CAN_RX_ISR(5, 0, CAN_PRIORITY + 5);
CAN_TX_ISR(5, 0, CAN_PRIORITY + CAN_NUM + 5);
CAN_BUSOFF_ISR(5, 0, CAN_PRIORITY + 2 * CAN_NUM + 5);
CAN_RX_ISR(6, 0, CAN_PRIORITY + 6);
CAN_TX_ISR(6, 0, CAN_PRIORITY + CAN_NUM + 6);
CAN_BUSOFF_ISR(6, 0, CAN_PRIORITY + 2 * CAN_NUM + 6);
CAN_RX_ISR(7, 0, CAN_PRIORITY + 7);
CAN_TX_ISR(7, 0, CAN_PRIORITY + CAN_NUM + 7);
CAN_BUSOFF_ISR(7, 0, CAN_PRIORITY + 2 * CAN_NUM + 7);
CAN_RX_ISR(8, 0, CAN_PRIORITY + 8);
CAN_TX_ISR(8, 0, CAN_PRIORITY + CAN_NUM + 8);
CAN_BUSOFF_ISR(8, 0, CAN_PRIORITY + 2 * CAN_NUM + 8);
CAN_RX_ISR(9, 0, CAN_PRIORITY + 9);
CAN_TX_ISR(9, 0, CAN_PRIORITY + CAN_NUM + 9);
CAN_BUSOFF_ISR(9, 0, CAN_PRIORITY + 2 * CAN_NUM + 9);
CAN_RX_ISR(10, 0, CAN_PRIORITY + 10);
CAN_TX_ISR(10, 0, CAN_PRIORITY + CAN_NUM + 10);
CAN_BUSOFF_ISR(10, 0, CAN_PRIORITY + 2 * CAN_NUM + 10);
CAN_RX_ISR(11, 0, CAN_PRIORITY + 11);
CAN_TX_ISR(11, 0, CAN_PRIORITY + CAN_NUM + 11);
CAN_BUSOFF_ISR(11, 0, CAN_PRIORITY + 2 * CAN_NUM + 11);

static uint8 dlc2len[16] = {0, 1,  2,  3,  4,  5,  6,  7,
                            8, 12, 16, 20, 24, 32, 48, 64};

// can rx callback, 把收到的帧全部echo回去
void can_rx_callback(canChannel channel, IfxCan_Message *msg) {
  // copy data to can1 tx buffer
  uint8 len = dlc2len[msg->dataLengthCode];
  for (uint8 i = 0; i < len; i++) {
    can[channel].txData[i] = can[channel].rxData[i];
  }
  can[channel].txMsg = *msg;
  if (!IfxCan_Can_isTxFifoQueueFull(&can[channel].node)) {
    while (IfxCan_Can_sendMessage(&can[channel].node, &can[channel].txMsg,
                                  (uint32 *)can[channel].txData) != IfxCan_Status_ok)
      ;
  }
  // 或者不copy，直接转发rxMsg ?
}

void init_can(mcmcanType *dev, canChannel channel, uint16 npre, uint8 ntseg1,
              uint8 ntseg2, uint16 dpre, uint8 dtseg1, uint8 dtseg2) {
  /* 根据 channel 选择物理模块: 0-3 -> MODULE_CAN0, 4-7 -> MODULE_CAN1, 8-11 -> MODULE_CAN2 */
  uint8 group = (channel < CAN4) ? 0 : (channel < CAN8) ? 1 : 2;
  Ifx_CAN *modulePtr = (group == 0) ? &MODULE_CAN0 : (group == 1) ? &MODULE_CAN1 : &MODULE_CAN2;

  /* 只对同一物理 CAN 模块初始化一次，防止后续节点重复 initModule 影响已配置节点 */
  if (!g_canModuleInitialized[group]) {
    IfxCan_Can_initModuleConfig(&dev->config, modulePtr);
    IfxCan_Can_initModule(&dev->module, &dev->config);
    g_canModuleInitialized[group] = TRUE;
  } else {
    /* 复用已初始化模块句柄（使用组内第一个节点的 module 结构体） */
    dev->module = can[(group == 0) ? CAN0 : (group == 1) ? CAN4 : CAN8].module;
  }

  IfxCan_Can_initNodeConfig(&dev->nodeConfig, &dev->module);

  // clang-format off
  dev->channel = channel;

  dev->nodeConfig.nodeId = (IfxCan_NodeId)(channel % 4);
  dev->nodeConfig.clockSource = IfxCan_ClockSource_both;
  dev->nodeConfig.frame.type = IfxCan_FrameType_transmitAndReceive;
  dev->nodeConfig.frame.mode = IfxCan_FrameMode_fdLongAndFast;

  /* Tx configuration */
  dev->nodeConfig.txConfig.txMode = IfxCan_TxMode_fifo;
  dev->nodeConfig.txConfig.dedicatedTxBuffersNumber = 0;
  dev->nodeConfig.txConfig.txFifoQueueSize = 32;
  dev->nodeConfig.txConfig.txBufferDataFieldSize = IfxCan_DataFieldSize_64;
  dev->nodeConfig.txConfig.txEventFifoSize = 0;

  /* Filter configuration */
  dev->nodeConfig.filterConfig.messageIdLength = IfxCan_MessageIdLength_both;
  dev->nodeConfig.filterConfig.standardListSize = 32;
  dev->nodeConfig.filterConfig.extendedListSize = 32;
  dev->nodeConfig.filterConfig.rejectRemoteFramesWithStandardId = TRUE;
  dev->nodeConfig.filterConfig.rejectRemoteFramesWithExtendedId = TRUE;
  dev->nodeConfig.filterConfig.standardFilterForNonMatchingFrames = IfxCan_NonMatchingFrame_reject;
  dev->nodeConfig.filterConfig.extendedFilterForNonMatchingFrames = IfxCan_NonMatchingFrame_reject;

  /* Rx configuration */
  dev->nodeConfig.rxConfig.rxMode = IfxCan_RxMode_fifo0;
  dev->nodeConfig.rxConfig.rxBufferDataFieldSize = IfxCan_DataFieldSize_64;
  dev->nodeConfig.rxConfig.rxFifo0DataFieldSize = IfxCan_DataFieldSize_64;
  dev->nodeConfig.rxConfig.rxFifo1DataFieldSize = IfxCan_DataFieldSize_64;
  dev->nodeConfig.rxConfig.rxFifo0OperatingMode = IfxCan_RxFifoMode_overwrite;
  dev->nodeConfig.rxConfig.rxFifo1OperatingMode = IfxCan_RxFifoMode_overwrite;
  dev->nodeConfig.rxConfig.rxFifo0WatermarkLevel = 0;
  dev->nodeConfig.rxConfig.rxFifo1WatermarkLevel = 0;
  dev->nodeConfig.rxConfig.rxFifo0Size = 16;
  dev->nodeConfig.rxConfig.rxFifo1Size = 0;

  /* Message RAM address offsets per channel within module */
  dev->nodeConfig.messageRAM.baseAddress = 0xF0200000u + (channel / 4) * 0x10000;
  dev->nodeConfig.messageRAM.standardFilterListStartAddress = (channel % 4) * 0x1000;
  dev->nodeConfig.messageRAM.extendedFilterListStartAddress = (channel % 4) * 0x1000 + 0x100;
  dev->nodeConfig.messageRAM.rxFifo0StartAddress = (channel % 4) * 0x1000 + 0x200;
  dev->nodeConfig.messageRAM.rxFifo1StartAddress = 0;
  dev->nodeConfig.messageRAM.rxBuffersStartAddress = 0;
  dev->nodeConfig.messageRAM.txEventFifoStartAddress = 0;
  dev->nodeConfig.messageRAM.txBuffersStartAddress = (channel % 4) * 0x1000 + 0x700;

  /* Interrupt configuration */
  dev->nodeConfig.interruptConfig.rxFifo0NewMessageEnabled = TRUE;
  dev->nodeConfig.interruptConfig.rxf0n.priority = CAN_PRIORITY + channel;
  dev->nodeConfig.interruptConfig.rxf0n.interruptLine = IfxCan_InterruptLine_0 + channel % 4;
  dev->nodeConfig.interruptConfig.rxf0n.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

  dev->nodeConfig.interruptConfig.transmissionCompletedEnabled = TRUE;
  dev->nodeConfig.interruptConfig.traco.priority = CAN_PRIORITY + CAN_NUM + channel;
  dev->nodeConfig.interruptConfig.traco.interruptLine = IfxCan_InterruptLine_4 + channel % 4;
  dev->nodeConfig.interruptConfig.traco.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

  dev->nodeConfig.interruptConfig.busOffStatusEnabled = TRUE;
  dev->nodeConfig.interruptConfig.boff.priority = CAN_PRIORITY + CAN_NUM * 2 + channel;
  dev->nodeConfig.interruptConfig.boff.interruptLine = IfxCan_InterruptLine_8 + channel % 4;
  dev->nodeConfig.interruptConfig.boff.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

  dev->nodeConfig.pins = &can_pins[channel];
  dev->nodeConfig.busLoopbackEnabled = FALSE;
  dev->nodeConfig.calculateBitTimingValues = FALSE;
  // clang-format on

  /* Initialize CAN node */
  IfxCan_Can_initNode(&dev->node, &dev->nodeConfig);

  // bit timing, tdc
  IfxCan_Node_enableConfigurationChange(dev->node.node);
  IfxCan_Node_setBitTimingValues(dev->node.node, ntseg2 - 1, ntseg2 - 1,
                                 ntseg1 - 1, npre - 1);
  IfxCan_Node_setFastBitTimingValues(dev->node.node, dtseg2 - 1, dtseg2 - 1,
                                     dtseg1 - 1, dpre - 1);
  IfxCan_Node_setTransceiverDelayCompensationOffset(dev->node.node, dtseg1 + 1);
  IfxCan_Node_disableConfigurationChange(dev->node.node);

  /* Initialize CAN filter */
  can_std_default_filter[channel][0] = can_std_default_filter[0][0];
  can_ext_default_filter[channel][0] = can_ext_default_filter[0][0];
  IfxCan_Can_setStandardFilter(&dev->node, &can_std_default_filter[channel][0]);
  IfxCan_Can_setExtendedFilter(&dev->node, &can_ext_default_filter[channel][0]);

  /* Initialize CAN message */
  IfxCan_Can_initMessage(&dev->txMsg);
  IfxCan_Can_initMessage(&dev->rxMsg);

  // callback
  switch (channel) {
  default:
    dev->can_rx_callback = can_rx_callback;
    dev->can_tx_callback = NULL;
    dev->can_error_callback = NULL;
    break;
  }
}

void init_can_simple(mcmcanType *dev, canChannel channel, uint32 baudRate,
                     float samplePoint, uint32 fastBaudRate,
                     float fastSamplePoint) {
  uint8 group = (channel < CAN4) ? 0 : (channel < CAN8) ? 1 : 2;
  Ifx_CAN *modulePtr = (group == 0) ? &MODULE_CAN0 : (group == 1) ? &MODULE_CAN1 : &MODULE_CAN2;

  if (!g_canModuleInitialized[group]) {
    IfxCan_Can_initModuleConfig(&dev->config, modulePtr);
    IfxCan_Can_initModule(&dev->module, &dev->config);
    g_canModuleInitialized[group] = TRUE;
  } else {
    dev->module = can[(group == 0) ? CAN0 : (group == 1) ? CAN4 : CAN8].module;
  }

  IfxCan_Can_initNodeConfig(&dev->nodeConfig, &dev->module);

  // clang-format off
  dev->channel = channel;

  dev->nodeConfig.nodeId = (IfxCan_NodeId)(channel % 4);
  dev->nodeConfig.clockSource = IfxCan_ClockSource_both;
  dev->nodeConfig.frame.type = IfxCan_FrameType_transmitAndReceive;
  dev->nodeConfig.frame.mode = IfxCan_FrameMode_fdLongAndFast;
  /* Nominal baud rate */
  dev->nodeConfig.baudRate.baudrate = baudRate;
  dev->nodeConfig.baudRate.samplePoint = (uint16)(samplePoint * 10000);
  dev->nodeConfig.baudRate.syncJumpWidth = 10000 - dev->nodeConfig.baudRate.samplePoint;
  /* Fast baud rate (CAN FD data phase) */
  dev->nodeConfig.fastBaudRate.baudrate = fastBaudRate;
  dev->nodeConfig.fastBaudRate.samplePoint = (uint16)(fastSamplePoint * 10000);
  dev->nodeConfig.fastBaudRate.syncJumpWidth = 10000 - dev->nodeConfig.fastBaudRate.samplePoint;

  /* Tx configuration */
  dev->nodeConfig.txConfig.txMode = IfxCan_TxMode_fifo;
  dev->nodeConfig.txConfig.dedicatedTxBuffersNumber = 0;
  dev->nodeConfig.txConfig.txFifoQueueSize = 32;
  dev->nodeConfig.txConfig.txBufferDataFieldSize = IfxCan_DataFieldSize_64;
  dev->nodeConfig.txConfig.txEventFifoSize = 0;

  /* Filter configuration */
  dev->nodeConfig.filterConfig.messageIdLength = IfxCan_MessageIdLength_both;
  dev->nodeConfig.filterConfig.standardListSize = 32;
  dev->nodeConfig.filterConfig.extendedListSize = 32;
  dev->nodeConfig.filterConfig.rejectRemoteFramesWithStandardId = TRUE;
  dev->nodeConfig.filterConfig.rejectRemoteFramesWithExtendedId = TRUE;
  dev->nodeConfig.filterConfig.standardFilterForNonMatchingFrames = IfxCan_NonMatchingFrame_reject;
  dev->nodeConfig.filterConfig.extendedFilterForNonMatchingFrames = IfxCan_NonMatchingFrame_reject;

  /* Rx configuration */
  dev->nodeConfig.rxConfig.rxMode = IfxCan_RxMode_fifo0;
  dev->nodeConfig.rxConfig.rxBufferDataFieldSize = IfxCan_DataFieldSize_64;
  dev->nodeConfig.rxConfig.rxFifo0DataFieldSize = IfxCan_DataFieldSize_64;
  dev->nodeConfig.rxConfig.rxFifo1DataFieldSize = IfxCan_DataFieldSize_64;
  dev->nodeConfig.rxConfig.rxFifo0OperatingMode = IfxCan_RxFifoMode_overwrite;
  dev->nodeConfig.rxConfig.rxFifo1OperatingMode = IfxCan_RxFifoMode_overwrite;
  dev->nodeConfig.rxConfig.rxFifo0WatermarkLevel = 0;
  dev->nodeConfig.rxConfig.rxFifo1WatermarkLevel = 0;
  dev->nodeConfig.rxConfig.rxFifo0Size = 16;
  dev->nodeConfig.rxConfig.rxFifo1Size = 0;

  /* Message RAM address offsets per channel within module */
  dev->nodeConfig.messageRAM.baseAddress = 0xF0200000u + (channel / 4) * 0x10000;
  dev->nodeConfig.messageRAM.standardFilterListStartAddress = (channel % 4) * 0x1000;
  dev->nodeConfig.messageRAM.extendedFilterListStartAddress = (channel % 4) * 0x1000 + 0x100;
  dev->nodeConfig.messageRAM.rxFifo0StartAddress = (channel % 4) * 0x1000 + 0x200;
  dev->nodeConfig.messageRAM.rxFifo1StartAddress = 0;
  dev->nodeConfig.messageRAM.rxBuffersStartAddress = 0;
  dev->nodeConfig.messageRAM.txEventFifoStartAddress = 0;
  dev->nodeConfig.messageRAM.txBuffersStartAddress = (channel % 4) * 0x1000 + 0x700;

  /* Interrupt configuration */
  dev->nodeConfig.interruptConfig.rxFifo0NewMessageEnabled = TRUE;
  dev->nodeConfig.interruptConfig.rxf0n.priority = CAN_PRIORITY + channel;
  dev->nodeConfig.interruptConfig.rxf0n.interruptLine = IfxCan_InterruptLine_0 + channel % 4;
  dev->nodeConfig.interruptConfig.rxf0n.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

  dev->nodeConfig.interruptConfig.transmissionCompletedEnabled = TRUE;
  dev->nodeConfig.interruptConfig.traco.priority = CAN_PRIORITY + CAN_NUM + channel;
  dev->nodeConfig.interruptConfig.traco.interruptLine = IfxCan_InterruptLine_4 + channel % 4;
  dev->nodeConfig.interruptConfig.traco.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

  dev->nodeConfig.interruptConfig.busOffStatusEnabled = TRUE;
  dev->nodeConfig.interruptConfig.boff.priority = CAN_PRIORITY + CAN_NUM * 2 + channel;
  dev->nodeConfig.interruptConfig.boff.interruptLine = IfxCan_InterruptLine_8 + channel % 4;
  dev->nodeConfig.interruptConfig.boff.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

  dev->nodeConfig.pins = &can_pins[channel];
  dev->nodeConfig.busLoopbackEnabled = FALSE;
  dev->nodeConfig.calculateBitTimingValues = TRUE;
  // clang-format on

  /* Initialize CAN node */
  IfxCan_Can_initNode(&dev->node, &dev->nodeConfig);

  // TDC
  IfxCan_Node_enableConfigurationChange(dev->node.node);
  IfxCan_Node_setTransceiverDelayCompensationOffset(
      dev->node.node, dev->node.node->DBTP.B.DTSEG1 + 2);
  IfxCan_Node_disableConfigurationChange(dev->node.node);

  /* Initialize CAN filter */
  can_std_default_filter[channel][0] = can_std_default_filter[0][0];
  can_ext_default_filter[channel][0] = can_ext_default_filter[0][0];
  IfxCan_Can_setStandardFilter(&dev->node, &can_std_default_filter[channel][0]);
  IfxCan_Can_setExtendedFilter(&dev->node, &can_ext_default_filter[channel][0]);

  /* Initialize CAN message */
  IfxCan_Can_initMessage(&dev->txMsg);
  IfxCan_Can_initMessage(&dev->rxMsg);

  // callback
  switch (channel) {
  default:
    dev->can_rx_callback = can_rx_callback;
    dev->can_tx_callback = NULL;
    dev->can_error_callback = NULL;
    break;
  }
}

void core0_main(void) {
  IfxCpu_enableInterrupts();

  /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
   * Enable the watchdogs and service them periodically if it is required
   */
  IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
  IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());

  /* Wait for CPU sync event */
  IfxCpu_emitEvent(&cpuSyncEvent);
  IfxCpu_waitEvent(&cpuSyncEvent, 1);

  // 所有通道 1000kbps 80%, 5Mbps 75%
  for (canChannel ch = CAN0; ch < CAN_NUM; ch++) {
    init_can(&can[ch], ch, 4, 15, 4, 1, 11, 4);
    // init_can_simple(&can[ch], ch, 1000000, 0.8, 5000000, 0.75);
  }

  // 所有通道 500kbps 80%, 2Mbps 80%
  // for (canChannel ch = CAN0; ch < CAN_NUM; ch++) {
  //   init_can_simple(&can[ch], ch, 500000, 0.8, 2000000, 0.8);
  // }

  // 所有通道 1Mbps 80%, 8Mbps 80%
  // for (canChannel ch = CAN0; ch < CAN_NUM; ch++) {
  //   init_can_simple(&can[ch], ch, 1000000, 0.8, 8000000, 0.8);
  //   // init_can(&can[ch], ch, 4, 15, 4, 1, 7, 2);
  // }

  while (1) {
  }
}
