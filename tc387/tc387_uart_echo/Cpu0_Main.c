/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"
#include "Ifx_Cfg_Ssw.h"
#include "Bsp.h"
#include "IfxPort.h"
#include "IfxAsclin_Asc.h"
#include "IfxCpu_Irq.h"
#include <stdarg.h>
#include <stdio.h>
#include <inttypes.h>

IFX_ALIGN(4) IfxCpu_syncEvent cpuSyncEvent = 0;

#define UART_TXBUF_SIZE 256
#define UART_RXBUF_SIZE 256
#define INTPRIO_ASCLIN4_TX 29
#define INTPRIO_ASCLIN4_RX 28

typedef struct
{
    uint8 txBuffer[UART_TXBUF_SIZE + sizeof(Ifx_Fifo) + 8];
    uint8 rxBuffer[UART_RXBUF_SIZE + sizeof(Ifx_Fifo) + 8];
    IfxAsclin_Asc ascHandle;
} App_AsclinAsc;
App_AsclinAsc uart4;

IFX_INTERRUPT(asclin4TxISR, 0, INTPRIO_ASCLIN4_TX);
void asclin4TxISR(void)
{
    IfxAsclin_Asc_isrTransmit(&uart4.ascHandle);
}

IFX_INTERRUPT(asclin4RxISR, 0, INTPRIO_ASCLIN4_RX);
void asclin4RxISR(void)
{
    IfxAsclin_Asc_isrReceive(&uart4.ascHandle);
}

void init_uart4(uint32 baud)
{
    /* Initialize an instance of IfxAsclin_Asc_Config with default values */
    IfxAsclin_Asc_Config ascConfig;
    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN4);

    /* Set the desired baud rate, 200MHz ASCLINF Freq */
    ascConfig.baudrate.baudrate = (float32)baud; // explicit cast avoids loss when storing in float field
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_16;
    ascConfig.bitTiming.medianFilter = IfxAsclin_SamplesPerBit_three;
    ascConfig.bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_12;

    /* ISR priorities and interrupt target */
    ascConfig.interrupt.txPriority = INTPRIO_ASCLIN4_TX;
    ascConfig.interrupt.rxPriority = INTPRIO_ASCLIN4_RX;
    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

    /* FIFO configuration */
    ascConfig.txBuffer = &uart4.txBuffer;
    ascConfig.txBufferSize = UART_TXBUF_SIZE;
    ascConfig.rxBuffer = &uart4.rxBuffer;
    ascConfig.rxBufferSize = UART_RXBUF_SIZE;

    /* Pin configuration */
    const IfxAsclin_Asc_Pins pins =
    {
        NULL_PTR,       IfxPort_InputMode_pullUp,     /* CTS pin not used */
        &IfxAsclin4_RXA_P00_12_IN,   IfxPort_InputMode_pullUp,     /* RX pin           */
        NULL_PTR,       IfxPort_OutputMode_pushPull,  /* RTS pin not used */
        &IfxAsclin4_TX_P00_9_OUT,   IfxPort_OutputMode_pushPull,  /* TX pin           */
        IfxPort_PadDriver_cmosAutomotiveSpeed4
    };
    ascConfig.pins = &pins;

    IfxAsclin_Asc_initModule(&uart4.ascHandle, &ascConfig); /* Initialize module with above parameters */
}

// print手动实现
void print(const char* fmt, ...)
{
    char buffer[256];
    va_list args;
    va_start(args, fmt);
    int len = vsnprintf(buffer, sizeof(buffer), fmt, args);
    va_end(args);
    if (len > 0)
    {
        Ifx_SizeT wlen = (Ifx_SizeT)len;
        IfxAsclin_Asc_write(&uart4.ascHandle, (uint8*)buffer, &wlen, TIME_INFINITE);
    }
}

#ifndef ECHO_LINE_TIMEOUT_MS
#define ECHO_LINE_TIMEOUT_MS  100u   /* 行超时时间：若超过该毫秒未收到'\n'，则发送当前缓冲 */
#endif

/* 将毫秒转为Tick（假设使用CPU0 STM0） */
static inline Ifx_TickTime msToTick(uint32 ms)
{
    return (Ifx_TickTime)((IfxStm_getFrequency(&MODULE_STM0) / 1000u) * ms);
}

/* 高级回显：
 * 特性：
 *  - 批量读取：IfxAsclin_Asc_read
 *  - 行结束：'\n'；可选处理'\r' (过滤)
 *  - 过滤 CR: 丢弃'\r'
 *  - 行超时：超过 ECHO_LINE_TIMEOUT_MS 毫秒未收满(未遇到'\n')，自动回显已有数据并加 '\r\n'
 *  - 非阻塞批量发送：聚合行后调用 IfxAsclin_Asc_write，一次写出（必要时分片）
 */
static void uart4_echo_task_advanced(void)
{
    static uint8  lineBuf[UART_RXBUF_SIZE];
    static Ifx_SizeT lineLen = 0;
    static Ifx_TickTime lineStartTick = 0; /* 记录当前行起始/最近刷新时间 */
    static boolean lineActive = FALSE;

    const Ifx_TickTime timeoutTick = msToTick(ECHO_LINE_TIMEOUT_MS);
    Ifx_TickTime now = IfxStm_get(&MODULE_STM0);

    /* 如果当前有活跃行且达到超时时间且缓冲内有数据，触发发送 */
    if (lineActive && lineLen > 0 && (now - lineStartTick) > timeoutTick)
    {
        /* 追加行尾（若最后不是\n，则补一个\r\n） */
        const uint8 trailer[] = {'\r','\n'};
        uint8 tempOut[UART_RXBUF_SIZE + 2];
        Ifx_SizeT outLen = 0;
        for (Ifx_SizeT i = 0; i < lineLen && outLen < (Ifx_SizeT)sizeof(tempOut); ++i)
        {
            tempOut[outLen++] = lineBuf[i];
        }
        if (outLen < (Ifx_SizeT)(sizeof(tempOut) - 1))
        {
            tempOut[outLen++] = trailer[0];
            tempOut[outLen++] = trailer[1];
        }
        /* 尝试一次写出；若写不完，分片 */
        Ifx_SizeT remain = outLen;
        Ifx_SizeT offset = 0;
        while (remain > 0)
        {
            Ifx_SizeT chunk = remain;
            IfxAsclin_Asc_write(&uart4.ascHandle, &tempOut[offset], &chunk, TIME_NULL); /* 非阻塞尝试 */
            if (chunk == 0)
            {
                /* 无空间：可选择 break 或忙等，这里忙等简单处理 */
                continue;
            }
            offset += chunk;
            remain -= chunk;
        }
        lineLen = 0;
        lineActive = FALSE;
    }

    /* 读取可用数据 */
    while (1)
    {
        sint32 avail = IfxAsclin_Asc_getReadCount(&uart4.ascHandle);
        if (avail <= 0)
        {
            break;
        }
        uint8 tempBuf[64];
        Ifx_SizeT want = (Ifx_SizeT)avail;
        if (want > (Ifx_SizeT)sizeof(tempBuf)) want = sizeof(tempBuf);
        Ifx_SizeT readCount = want;
        IfxAsclin_Asc_read(&uart4.ascHandle, tempBuf, &readCount, TIME_NULL);
        if (readCount == 0)
        {
            break; /* 没有实际读到 */
        }
        now = IfxStm_get(&MODULE_STM0);
        if (!lineActive)
        {
            lineStartTick = now;
            lineActive = TRUE;
        }
        for (Ifx_SizeT i = 0; i < readCount; ++i)
        {
            uint8 ch = tempBuf[i];
            if (ch == '\r')
            {
                /* 过滤 CR */
                continue;
            }
            if (ch == '\n')
            {
                /* 行结束，发送当前缓冲 + '\n' (已经过滤CR) */
                uint8 outBuf[UART_RXBUF_SIZE + 2];
                Ifx_SizeT outLen = 0;
                for (Ifx_SizeT k = 0; k < lineLen && outLen < (Ifx_SizeT)sizeof(outBuf); ++k)
                {
                    outBuf[outLen++] = lineBuf[k];
                }
                if (outLen < (Ifx_SizeT)sizeof(outBuf))
                {
                    outBuf[outLen++] = '\r';
                    outBuf[outLen++] = '\n'; /* 仅回显 LF，若想统一改成 CRLF 可替换为 '\r','\n' */
                }
                /* 分片非阻塞写 */
                Ifx_SizeT remain = outLen;
                Ifx_SizeT offset = 0;
                while (remain > 0)
                {
                    Ifx_SizeT chunk = remain;
                    IfxAsclin_Asc_write(&uart4.ascHandle, &outBuf[offset], &chunk, TIME_NULL);
                    if (chunk == 0)
                    {
                        continue; /* 等待Tx空闲 */
                    }
                    offset += chunk;
                    remain -= chunk;
                }
                lineLen = 0;
                lineActive = FALSE;
                /* 下一行开始重新计时 */
                lineStartTick = now;
                continue; /* 处理下一个字节 */
            }
            /* 普通数据加入缓冲 */
            if (lineLen < (Ifx_SizeT)sizeof(lineBuf))
            {
                lineBuf[lineLen++] = ch;
            }
            else
            {
                /* 缓冲满：立即发送(截断标记)并重置，然后继续把当前字节作为新行开头 */
                const char truncMsg[] = "[TRUNC]\n";
                Ifx_SizeT remain = lineLen;
                Ifx_SizeT offset = 0;
                while (remain > 0)
                {
                    Ifx_SizeT chunk = remain;
                    IfxAsclin_Asc_write(&uart4.ascHandle, &lineBuf[offset], &chunk, TIME_NULL);
                    if (chunk == 0) continue;
                    offset += chunk;
                    remain -= chunk;
                }
                /* 发送截断提示 */
                Ifx_SizeT tRemain = (Ifx_SizeT)(sizeof(truncMsg) - 1);
                offset = 0;
                while (tRemain > 0)
                {
                    Ifx_SizeT chunk = tRemain;
                    IfxAsclin_Asc_write(&uart4.ascHandle, (uint8*)&truncMsg[offset], &chunk, TIME_NULL);
                    if (chunk == 0) continue;
                    offset += chunk;
                    tRemain -= chunk;
                }
                lineLen = 0;
                lineBuf[lineLen++] = ch; /* 把当前字节作为新行第一个 */
                lineStartTick = now;
            }
        }
        /* 刚处理完一批数据，刷新行起始时间（表示活跃） */
        lineStartTick = now;
    }
}

void core0_main(void)
{
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&cpuSyncEvent);
    IfxCpu_waitEvent(&cpuSyncEvent, 1);

    init_uart4(4000000); /* 设置高波特率，4Mbps，可按需要修改 */
    
    while(1)
    {
        uart4_echo_task_advanced();
    }
}
